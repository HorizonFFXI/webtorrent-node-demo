const { isMainThread, parentPort, workerData } = require("worker_threads");

/************************************************************************************
 * MERGE
 *********************************************************************************/

 var __create = Object.create;
 var __defProp = Object.defineProperty;
 var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
 var __getOwnPropNames = Object.getOwnPropertyNames;
 var __getProtoOf = Object.getPrototypeOf;
 var __hasOwnProp = Object.prototype.hasOwnProperty;
 var __commonJS = (cb, mod) => function __require() {
   return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
 };
 var __export = (target, all) => {
   for (var name in all)
     __defProp(target, name, { get: all[name], enumerable: true });
 };
 var __copyProps = (to, from, except, desc) => {
   if (from && typeof from === "object" || typeof from === "function") {
     for (let key of __getOwnPropNames(from))
       if (!__hasOwnProp.call(to, key) && key !== except)
         __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
   }
   return to;
 };
 var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
   isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
   mod
 ));
 var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // node_modules/simple-concat/index.js
 var require_simple_concat = __commonJS({
   "node_modules/simple-concat/index.js"(exports, module2) {
     module2.exports = function(stream, cb) {
       var chunks = [];
       stream.on("data", function(chunk) {
         chunks.push(chunk);
       });
       stream.once("end", function() {
         if (cb)
           cb(null, Buffer.concat(chunks));
         cb = null;
       });
       stream.once("error", function(err) {
         if (cb)
           cb(err);
         cb = null;
       });
     };
   }
 });
 
 // node_modules/bencode/lib/util.js
 var require_util = __commonJS({
   "node_modules/bencode/lib/util.js"(exports, module2) {
     var util = module2.exports;
     util.digitCount = function digitCount(value) {
       const sign = value < 0 ? 1 : 0;
       value = Math.abs(Number(value || 1));
       return Math.floor(Math.log10(value)) + 1 + sign;
     };
     util.getType = function getType(value) {
       if (Buffer.isBuffer(value))
         return "buffer";
       if (ArrayBuffer.isView(value))
         return "arraybufferview";
       if (Array.isArray(value))
         return "array";
       if (value instanceof Number)
         return "number";
       if (value instanceof Boolean)
         return "boolean";
       if (value instanceof Set)
         return "set";
       if (value instanceof Map)
         return "map";
       if (value instanceof String)
         return "string";
       if (value instanceof ArrayBuffer)
         return "arraybuffer";
       return typeof value;
     };
   }
 });
 
 // node_modules/bencode/lib/encode.js
 var require_encode = __commonJS({
   "node_modules/bencode/lib/encode.js"(exports, module2) {
     var { getType } = require_util();
     function encode(data, buffer, offset) {
       const buffers = [];
       let result = null;
       encode._encode(buffers, data);
       result = Buffer.concat(buffers);
       encode.bytes = result.length;
       if (Buffer.isBuffer(buffer)) {
         result.copy(buffer, offset);
         return buffer;
       }
       return result;
     }
     encode.bytes = -1;
     encode._floatConversionDetected = false;
     encode._encode = function(buffers, data) {
       if (data == null) {
         return;
       }
       switch (getType(data)) {
         case "buffer":
           encode.buffer(buffers, data);
           break;
         case "object":
           encode.dict(buffers, data);
           break;
         case "map":
           encode.dictMap(buffers, data);
           break;
         case "array":
           encode.list(buffers, data);
           break;
         case "set":
           encode.listSet(buffers, data);
           break;
         case "string":
           encode.string(buffers, data);
           break;
         case "number":
           encode.number(buffers, data);
           break;
         case "boolean":
           encode.number(buffers, data);
           break;
         case "arraybufferview":
           encode.buffer(buffers, Buffer.from(data.buffer, data.byteOffset, data.byteLength));
           break;
         case "arraybuffer":
           encode.buffer(buffers, Buffer.from(data));
           break;
       }
     };
     var buffE = Buffer.from("e");
     var buffD = Buffer.from("d");
     var buffL = Buffer.from("l");
     encode.buffer = function(buffers, data) {
       buffers.push(Buffer.from(data.length + ":"), data);
     };
     encode.string = function(buffers, data) {
       buffers.push(Buffer.from(Buffer.byteLength(data) + ":" + data));
     };
     encode.number = function(buffers, data) {
       const maxLo = 2147483648;
       const hi = data / maxLo << 0;
       const lo = data % maxLo << 0;
       const val = hi * maxLo + lo;
       buffers.push(Buffer.from("i" + val + "e"));
       if (val !== data && !encode._floatConversionDetected) {
         encode._floatConversionDetected = true;
         console.warn(
           'WARNING: Possible data corruption detected with value "' + data + '":',
           'Bencoding only defines support for integers, value was converted to "' + val + '"'
         );
         console.trace();
       }
     };
     encode.dict = function(buffers, data) {
       buffers.push(buffD);
       let j = 0;
       let k;
       const keys = Object.keys(data).sort();
       const kl = keys.length;
       for (; j < kl; j++) {
         k = keys[j];
         if (data[k] == null)
           continue;
         encode.string(buffers, k);
         encode._encode(buffers, data[k]);
       }
       buffers.push(buffE);
     };
     encode.dictMap = function(buffers, data) {
       buffers.push(buffD);
       const keys = Array.from(data.keys()).sort();
       for (const key of keys) {
         if (data.get(key) == null)
           continue;
         Buffer.isBuffer(key) ? encode._encode(buffers, key) : encode.string(buffers, String(key));
         encode._encode(buffers, data.get(key));
       }
       buffers.push(buffE);
     };
     encode.list = function(buffers, data) {
       let i = 0;
       const c = data.length;
       buffers.push(buffL);
       for (; i < c; i++) {
         if (data[i] == null)
           continue;
         encode._encode(buffers, data[i]);
       }
       buffers.push(buffE);
     };
     encode.listSet = function(buffers, data) {
       buffers.push(buffL);
       for (const item of data) {
         if (item == null)
           continue;
         encode._encode(buffers, item);
       }
       buffers.push(buffE);
     };
     module2.exports = encode;
   }
 });
 
 // node_modules/bencode/lib/decode.js
 var require_decode = __commonJS({
   "node_modules/bencode/lib/decode.js"(exports, module2) {
     var INTEGER_START = 105;
     var STRING_DELIM = 58;
     var DICTIONARY_START = 100;
     var LIST_START = 108;
     var END_OF_TYPE = 101;
     function getIntFromBuffer(buffer, start, end) {
       let sum = 0;
       let sign = 1;
       for (let i = start; i < end; i++) {
         const num = buffer[i];
         if (num < 58 && num >= 48) {
           sum = sum * 10 + (num - 48);
           continue;
         }
         if (i === start && num === 43) {
           continue;
         }
         if (i === start && num === 45) {
           sign = -1;
           continue;
         }
         if (num === 46) {
           break;
         }
         throw new Error("not a number: buffer[" + i + "] = " + num);
       }
       return sum * sign;
     }
     function decode(data, start, end, encoding) {
       if (data == null || data.length === 0) {
         return null;
       }
       if (typeof start !== "number" && encoding == null) {
         encoding = start;
         start = void 0;
       }
       if (typeof end !== "number" && encoding == null) {
         encoding = end;
         end = void 0;
       }
       decode.position = 0;
       decode.encoding = encoding || null;
       decode.data = !Buffer.isBuffer(data) ? Buffer.from(data) : data.slice(start, end);
       decode.bytes = decode.data.length;
       return decode.next();
     }
     decode.bytes = 0;
     decode.position = 0;
     decode.data = null;
     decode.encoding = null;
     decode.next = function() {
       switch (decode.data[decode.position]) {
         case DICTIONARY_START:
           return decode.dictionary();
         case LIST_START:
           return decode.list();
         case INTEGER_START:
           return decode.integer();
         default:
           return decode.buffer();
       }
     };
     decode.find = function(chr) {
       let i = decode.position;
       const c = decode.data.length;
       const d = decode.data;
       while (i < c) {
         if (d[i] === chr)
           return i;
         i++;
       }
       throw new Error(
         'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
       );
     };
     decode.dictionary = function() {
       decode.position++;
       const dict = {};
       while (decode.data[decode.position] !== END_OF_TYPE) {
         dict[decode.buffer()] = decode.next();
       }
       decode.position++;
       return dict;
     };
     decode.list = function() {
       decode.position++;
       const lst = [];
       while (decode.data[decode.position] !== END_OF_TYPE) {
         lst.push(decode.next());
       }
       decode.position++;
       return lst;
     };
     decode.integer = function() {
       const end = decode.find(END_OF_TYPE);
       const number = getIntFromBuffer(decode.data, decode.position + 1, end);
       decode.position += end + 1 - decode.position;
       return number;
     };
     decode.buffer = function() {
       let sep = decode.find(STRING_DELIM);
       const length = getIntFromBuffer(decode.data, decode.position, sep);
       const end = ++sep + length;
       decode.position = end;
       return decode.encoding ? decode.data.toString(decode.encoding, sep, end) : decode.data.slice(sep, end);
     };
     module2.exports = decode;
   }
 });
 
 // node_modules/bencode/lib/encoding-length.js
 var require_encoding_length = __commonJS({
   "node_modules/bencode/lib/encoding-length.js"(exports, module2) {
     var { digitCount, getType } = require_util();
     function listLength(list) {
       let length = 1 + 1;
       for (const value of list) {
         length += encodingLength(value);
       }
       return length;
     }
     function mapLength(map) {
       let length = 1 + 1;
       for (const [key, value] of map) {
         const keyLength = Buffer.byteLength(key);
         length += digitCount(keyLength) + 1 + keyLength;
         length += encodingLength(value);
       }
       return length;
     }
     function objectLength(value) {
       let length = 1 + 1;
       const keys = Object.keys(value);
       for (let i = 0; i < keys.length; i++) {
         const keyLength = Buffer.byteLength(keys[i]);
         length += digitCount(keyLength) + 1 + keyLength;
         length += encodingLength(value[keys[i]]);
       }
       return length;
     }
     function stringLength(value) {
       const length = Buffer.byteLength(value);
       return digitCount(length) + 1 + length;
     }
     function arrayBufferLength(value) {
       const length = value.byteLength - value.byteOffset;
       return digitCount(length) + 1 + length;
     }
     function encodingLength(value) {
       const length = 0;
       if (value == null)
         return length;
       const type = getType(value);
       switch (type) {
         case "buffer":
           return digitCount(value.length) + 1 + value.length;
         case "arraybufferview":
           return arrayBufferLength(value);
         case "string":
           return stringLength(value);
         case "array":
         case "set":
           return listLength(value);
         case "number":
           return 1 + digitCount(Math.floor(value)) + 1;
         case "bigint":
           return 1 + value.toString().length + 1;
         case "object":
           return objectLength(value);
         case "map":
           return mapLength(value);
         default:
           throw new TypeError(`Unsupported value of type "${type}"`);
       }
     }
     module2.exports = encodingLength;
   }
 });
 
 // node_modules/bencode/lib/index.js
 var require_lib = __commonJS({
   "node_modules/bencode/lib/index.js"(exports, module2) {
     var bencode = module2.exports;
     bencode.encode = require_encode();
     bencode.decode = require_decode();
     bencode.byteLength = bencode.encodingLength = require_encoding_length();
   }
 });
 
 // node_modules/block-iterator/index.js
 var require_block_iterator = __commonJS({
   "node_modules/block-iterator/index.js"(exports, module2) {
     function concat(chunks, size) {
       if (typeof chunks[0] === "string")
         return chunks.join("");
       if (typeof chunks[0] === "number")
         return new Uint8Array(chunks);
       const b = new Uint8Array(size);
       let offset = 0;
       for (let i = 0, l = chunks.length; i < l; i++) {
         const chunk = chunks[i];
         b.set(chunk, offset);
         offset += chunk.byteLength || chunk.length;
       }
       return b;
     }
     module2.exports = async function* (iterator, size = 512, opts = {}) {
       if (typeof size === "object") {
         opts = size;
         size = opts.size;
       }
       let { nopad, zeroPadding = true } = opts;
       if (nopad)
         zeroPadding = false;
       let buffered = [];
       let bufferedBytes = 0;
       for await (const value of iterator) {
         bufferedBytes += value.byteLength || value.length || 1;
         buffered.push(value);
         if (bufferedBytes >= size) {
           const b = concat(buffered, bufferedBytes);
           let offset = 0;
           while (bufferedBytes >= size) {
             yield b.slice(offset, offset + size);
             bufferedBytes -= size;
             offset += size;
           }
           buffered = [b.slice(offset, b.length)];
         }
       }
       if (bufferedBytes)
         yield concat(buffered, zeroPadding ? size : bufferedBytes);
     };
   }
 });
 
 // node_modules/piece-length/index.js
 var require_piece_length = __commonJS({
   "node_modules/piece-length/index.js"(exports, module2) {
     module2.exports = length;
     function length(bytes) {
       return Math.max(16384, 1 << Math.log2(bytes < 1024 ? 1 : bytes / 1024) + 0.5 | 0);
     }
   }
 });
 
 // node_modules/is-file/index.js
 var require_is_file = __commonJS({
   "node_modules/is-file/index.js"(exports, module2) {
     "use strict";
     var fs2 = require("fs");
     module2.exports = function isFile(path2, cb) {
       if (!cb)
         return isFileSync(path2);
       fs2.stat(path2, function(err, stats) {
         if (err)
           return cb(err);
         return cb(null, stats.isFile());
       });
     };
     module2.exports.sync = isFileSync;
     function isFileSync(path2) {
       return fs2.existsSync(path2) && fs2.statSync(path2).isFile();
     }
   }
 });
 
 // node_modules/junk/index.js
 var require_junk = __commonJS({
   "node_modules/junk/index.js"(exports, module2) {
     "use strict";
     var blacklist = [
       "^npm-debug\\.log$",
       "^\\..*\\.swp$",
       "^\\.DS_Store$",
       "^\\.AppleDouble$",
       "^\\.LSOverride$",
       "^Icon\\r$",
       "^\\._.*",
       "^\\.Spotlight-V100(?:$|\\/)",
       "\\.Trashes",
       "^__MACOSX$",
       "~$",
       "^Thumbs\\.db$",
       "^ehthumbs\\.db$",
       "^Desktop\\.ini$",
       "@eaDir$"
     ];
     exports.re = () => {
       throw new Error("`junk.re` was renamed to `junk.regex`");
     };
     exports.regex = new RegExp(blacklist.join("|"));
     exports.is = (filename) => exports.regex.test(filename);
     exports.not = (filename) => !exports.is(filename);
     exports.default = module2.exports;
   }
 });
 
 // node_modules/join-async-iterator/index.js
 var require_join_async_iterator = __commonJS({
   "node_modules/join-async-iterator/index.js"(exports, module2) {
     module2.exports = async function* (iterators) {
       for (let iterator of iterators) {
         if (typeof iterator === "function")
           iterator = iterator();
         yield* iterator;
       }
     };
   }
 });
 
 // node_modules/queue-microtask/index.js
 var require_queue_microtask = __commonJS({
   "node_modules/queue-microtask/index.js"(exports, module2) {
     var promise;
     module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
       throw err;
     }, 0));
   }
 });
 
 // node_modules/run-parallel/index.js
 var require_run_parallel = __commonJS({
   "node_modules/run-parallel/index.js"(exports, module2) {
     module2.exports = runParallel;
     var queueMicrotask3 = require_queue_microtask();
     function runParallel(tasks, cb) {
       let results, pending, keys;
       let isSync = true;
       if (Array.isArray(tasks)) {
         results = [];
         pending = tasks.length;
       } else {
         keys = Object.keys(tasks);
         results = {};
         pending = keys.length;
       }
       function done(err) {
         function end() {
           if (cb)
             cb(err, results);
           cb = null;
         }
         if (isSync)
           queueMicrotask3(end);
         else
           end();
       }
       function each(i, err, result) {
         results[i] = result;
         if (--pending === 0 || err) {
           done(err);
         }
       }
       if (!pending) {
         done(null);
       } else if (keys) {
         keys.forEach(function(key) {
           tasks[key](function(err, result) {
             each(key, err, result);
           });
         });
       } else {
         tasks.forEach(function(task, i) {
           task(function(err, result) {
             each(i, err, result);
           });
         });
       }
       isSync = false;
     }
   }
 });
 
 // node_modules/simple-sha1/index.js
 var require_simple_sha1 = __commonJS({
   "node_modules/simple-sha1/index.js"(exports, module2) {
     var crypto = require("crypto");
     function sha1(buf, cb) {
       const hash = sha1sync(buf);
       process.nextTick(function() {
         cb(hash);
       });
     }
     function sha1sync(buf) {
       return crypto.createHash("sha1").update(buf).digest("hex");
     }
     module2.exports = sha1;
     module2.exports.sync = sha1sync;
   }
 });
 
 // node_modules/fast-readable-async-iterator/index.js
 var require_fast_readable_async_iterator = __commonJS({
   "node_modules/fast-readable-async-iterator/index.js"() {
     if (typeof ReadableStream !== "undefined" && !ReadableStream.prototype[Symbol.asyncIterator]) {
       ReadableStream.prototype[Symbol.asyncIterator] = function() {
         const reader = this.getReader();
         let last = reader.read();
         return {
           next() {
             const temp = last;
             last = reader.read();
             return temp;
           },
           return() {
             last.then(() => reader.releaseLock());
           },
           throw(err) {
             this.return();
             throw err;
           },
           [Symbol.asyncIterator]() {
             return this;
           }
         };
       };
     }
   }
 });
 
 // node_modules/wrappy/wrappy.js
 var require_wrappy = __commonJS({
   "node_modules/wrappy/wrappy.js"(exports, module2) {
     module2.exports = wrappy;
     function wrappy(fn, cb) {
       if (fn && cb)
         return wrappy(fn)(cb);
       if (typeof fn !== "function")
         throw new TypeError("need wrapper function");
       Object.keys(fn).forEach(function(k) {
         wrapper[k] = fn[k];
       });
       return wrapper;
       function wrapper() {
         var args = new Array(arguments.length);
         for (var i = 0; i < args.length; i++) {
           args[i] = arguments[i];
         }
         var ret = fn.apply(this, args);
         var cb2 = args[args.length - 1];
         if (typeof ret === "function" && ret !== cb2) {
           Object.keys(cb2).forEach(function(k) {
             ret[k] = cb2[k];
           });
         }
         return ret;
       }
     }
   }
 });
 
 // node_modules/once/once.js
 var require_once = __commonJS({
   "node_modules/once/once.js"(exports, module2) {
     var wrappy = require_wrappy();
     module2.exports = wrappy(once);
     module2.exports.strict = wrappy(onceStrict);
     once.proto = once(function() {
       Object.defineProperty(Function.prototype, "once", {
         value: function() {
           return once(this);
         },
         configurable: true
       });
       Object.defineProperty(Function.prototype, "onceStrict", {
         value: function() {
           return onceStrict(this);
         },
         configurable: true
       });
     });
     function once(fn) {
       var f = function() {
         if (f.called)
           return f.value;
         f.called = true;
         return f.value = fn.apply(this, arguments);
       };
       f.called = false;
       return f;
     }
     function onceStrict(fn) {
       var f = function() {
         if (f.called)
           throw new Error(f.onceError);
         f.called = true;
         return f.value = fn.apply(this, arguments);
       };
       var name = fn.name || "Function wrapped with `once`";
       f.onceError = name + " shouldn't be called more than once";
       f.called = false;
       return f;
     }
   }
 });
 
 // node_modules/create-torrent/get-files.js
 var require_get_files = __commonJS({
   "node_modules/create-torrent/get-files.js"(exports, module2) {
     var corePath = require("path");
     var fs2 = require("fs");
     var junk = require_junk();
     var once = require_once();
     var parallel2 = require_run_parallel();
     function notHidden(file) {
       return file[0] !== ".";
     }
     function traversePath(path2, fn, cb) {
       fs2.stat(path2, (err, stats) => {
         if (err)
           return cb(err);
         if (stats.isDirectory()) {
           fs2.readdir(path2, (err2, entries) => {
             if (err2)
               return cb(err2);
             parallel2(entries.filter(notHidden).filter(junk.not).map((entry) => (cb2) => {
               traversePath(corePath.join(path2, entry), fn, cb2);
             }), cb);
           });
         } else if (stats.isFile()) {
           fn(path2, cb);
         }
       });
     }
     function getFilePathStream(path2) {
       return () => fs2.createReadStream(path2);
     }
     function getFiles(path2, keepRoot, cb) {
       traversePath(path2, getFileInfo, (err, files) => {
         if (err)
           return cb(err);
         if (Array.isArray(files))
           files = files.flat(Infinity);
         else
           files = [files];
         path2 = corePath.normalize(path2);
         if (keepRoot) {
           path2 = path2.slice(0, path2.lastIndexOf(corePath.sep) + 1);
         }
         if (path2[path2.length - 1] !== corePath.sep)
           path2 += corePath.sep;
         files.forEach((file) => {
           file.getStream = getFilePathStream(file.path);
           file.path = file.path.replace(path2, "").split(corePath.sep);
         });
         cb(null, files);
       });
     }
     function getFileInfo(path2, cb) {
       cb = once(cb);
       fs2.stat(path2, (err, stat) => {
         if (err)
           return cb(err);
         const info = {
           length: stat.size,
           path: path2
         };
         cb(null, info);
       });
     }
     module2.exports = getFiles;
   }
 });
 
 // node_modules/create-torrent/index.js
 var require_create_torrent = __commonJS({
   "node_modules/create-torrent/index.js"(exports, module2) {
     var bencode = require_lib();
     var blockIterator = require_block_iterator();
     var calcPieceLength = require_piece_length();
     var corePath = require("path");
     var isFile = require_is_file();
     var junk = require_junk();
     var joinIterator = require_join_async_iterator();
     var parallel2 = require_run_parallel();
     var queueMicrotask3 = require_queue_microtask();
     var sha1 = require_simple_sha1();
     require_fast_readable_async_iterator();
     var getFiles = require_get_files();
     var announceList = [
       ["udp://tracker.leechers-paradise.org:6969"],
       ["udp://tracker.coppersurfer.tk:6969"],
       ["udp://tracker.opentrackr.org:1337"],
       ["udp://explodie.org:6969"],
       ["udp://tracker.empire-js.us:1337"],
       ["wss://tracker.btorrent.xyz"],
       ["wss://tracker.openwebtorrent.com"]
     ];
     function createTorrent(input, opts, cb) {
       if (typeof opts === "function")
         [opts, cb] = [cb, opts];
       opts = opts ? Object.assign({}, opts) : {};
       _parseInput(input, opts, (err, files, singleFileTorrent) => {
         if (err)
           return cb(err);
         opts.singleFileTorrent = singleFileTorrent;
         onFiles(files, opts, cb);
       });
     }
     function parseInput(input, opts, cb) {
       if (typeof opts === "function")
         [opts, cb] = [cb, opts];
       opts = opts ? Object.assign({}, opts) : {};
       _parseInput(input, opts, cb);
     }
     var pathSymbol = Symbol("itemPath");
     function _parseInput(input, opts, cb) {
       if (isFileList(input))
         input = Array.from(input);
       if (!Array.isArray(input))
         input = [input];
       if (input.length === 0)
         throw new Error("invalid input type");
       input.forEach((item) => {
         if (item == null)
           throw new Error(`invalid input type: ${item}`);
       });
       input = input.map((item) => {
         if (isBlob(item) && typeof item.path === "string" && typeof getFiles === "function")
           return item.path;
         return item;
       });
       if (input.length === 1 && typeof input[0] !== "string" && !input[0].name)
         input[0].name = opts.name;
       let commonPrefix = null;
       input.forEach((item, i) => {
         if (typeof item === "string") {
           return;
         }
         let path2 = item.fullPath || item.name;
         if (!path2) {
           path2 = `Unknown File ${i + 1}`;
           item.unknownName = true;
         }
         item[pathSymbol] = path2.split("/");
         if (!item[pathSymbol][0]) {
           item[pathSymbol].shift();
         }
         if (item[pathSymbol].length < 2) {
           commonPrefix = null;
         } else if (i === 0 && input.length > 1) {
           commonPrefix = item[pathSymbol][0];
         } else if (item[pathSymbol][0] !== commonPrefix) {
           commonPrefix = null;
         }
       });
       const filterJunkFiles = opts.filterJunkFiles === void 0 ? true : opts.filterJunkFiles;
       if (filterJunkFiles) {
         input = input.filter((item) => {
           if (typeof item === "string") {
             return true;
           }
           return !isJunkPath(item[pathSymbol]);
         });
       }
       if (commonPrefix) {
         input.forEach((item) => {
           const pathless = (Buffer.isBuffer(item) || isReadable(item)) && !item[pathSymbol];
           if (typeof item === "string" || pathless)
             return;
           item[pathSymbol].shift();
         });
       }
       if (!opts.name && commonPrefix) {
         opts.name = commonPrefix;
       }
       if (!opts.name) {
         input.some((item) => {
           if (typeof item === "string") {
             opts.name = corePath.basename(item);
             return true;
           } else if (!item.unknownName) {
             opts.name = item[pathSymbol][item[pathSymbol].length - 1];
             return true;
           }
           return false;
         });
       }
       if (!opts.name) {
         opts.name = `Unnamed Torrent ${Date.now()}`;
       }
       const numPaths = input.reduce((sum, item) => sum + Number(typeof item === "string"), 0);
       let isSingleFileTorrent = input.length === 1;
       if (input.length === 1 && typeof input[0] === "string") {
         if (typeof getFiles !== "function") {
           throw new Error("filesystem paths do not work in the browser");
         }
         isFile(input[0], (err, pathIsFile) => {
           if (err)
             return cb(err);
           isSingleFileTorrent = pathIsFile;
           processInput();
         });
       } else {
         queueMicrotask3(processInput);
       }
       function processInput() {
         parallel2(input.map((item) => (cb2) => {
           const file = {};
           if (isBlob(item)) {
             file.getStream = item.stream();
             file.length = item.size;
           } else if (Buffer.isBuffer(item)) {
             file.getStream = [item];
             file.length = item.length;
           } else if (isReadable(item)) {
             file.getStream = getStreamStream(item, file);
             file.length = 0;
           } else if (typeof item === "string") {
             if (typeof getFiles !== "function") {
               throw new Error("filesystem paths do not work in the browser");
             }
             const keepRoot = numPaths > 1 || isSingleFileTorrent;
             getFiles(item, keepRoot, cb2);
             return;
           } else {
             throw new Error("invalid input type");
           }
           file.path = item[pathSymbol];
           cb2(null, file);
         }), (err, files) => {
           if (err)
             return cb(err);
           files = files.flat();
           cb(null, files, isSingleFileTorrent);
         });
       }
     }
     var MAX_OUTSTANDING_HASHES = 5;
     async function getPieceList(files, pieceLength, estimatedTorrentLength, opts, cb) {
       const pieces = [];
       let length = 0;
       let hashedLength = 0;
       const streams = files.map((file) => file.getStream);
       const onProgress = opts.onProgress;
       let remainingHashes = 0;
       let pieceNum = 0;
       let ended = false;
       const iterator = blockIterator(joinIterator(streams), pieceLength, { zeroPadding: false });
       try {
         for await (const chunk of iterator) {
           await new Promise((resolve) => {
             length += chunk.length;
             const i = pieceNum;
             ++pieceNum;
             if (++remainingHashes < MAX_OUTSTANDING_HASHES)
               resolve();
             sha1(chunk, (hash) => {
               pieces[i] = hash;
               --remainingHashes;
               hashedLength += chunk.length;
               if (onProgress)
                 onProgress(hashedLength, estimatedTorrentLength);
               resolve();
               if (ended && remainingHashes === 0)
                 cb(null, Buffer.from(pieces.join(""), "hex"), length);
             });
           });
         }
         if (remainingHashes === 0)
           return cb(null, Buffer.from(pieces.join(""), "hex"), length);
         ended = true;
       } catch (err) {
         cb(err);
       }
     }
     function onFiles(files, opts, cb) {
       let announceList2 = opts.announceList;
       if (!announceList2) {
         if (typeof opts.announce === "string")
           announceList2 = [[opts.announce]];
         else if (Array.isArray(opts.announce)) {
           announceList2 = opts.announce.map((u) => [u]);
         }
       }
       if (!announceList2)
         announceList2 = [];
       if (globalThis.WEBTORRENT_ANNOUNCE) {
         if (typeof globalThis.WEBTORRENT_ANNOUNCE === "string") {
           announceList2.push([[globalThis.WEBTORRENT_ANNOUNCE]]);
         } else if (Array.isArray(globalThis.WEBTORRENT_ANNOUNCE)) {
           announceList2 = announceList2.concat(globalThis.WEBTORRENT_ANNOUNCE.map((u) => [u]));
         }
       }
       if (opts.announce === void 0 && opts.announceList === void 0) {
         announceList2 = announceList2.concat(module2.exports.announceList);
       }
       if (typeof opts.urlList === "string")
         opts.urlList = [opts.urlList];
       const torrent = {
         info: {
           name: opts.name
         },
         "creation date": Math.ceil((Number(opts.creationDate) || Date.now()) / 1e3),
         encoding: "UTF-8"
       };
       if (announceList2.length !== 0) {
         torrent.announce = announceList2[0][0];
         torrent["announce-list"] = announceList2;
       }
       if (opts.comment !== void 0)
         torrent.comment = opts.comment;
       if (opts.createdBy !== void 0)
         torrent["created by"] = opts.createdBy;
       if (opts.private !== void 0)
         torrent.info.private = Number(opts.private);
       if (opts.info !== void 0)
         Object.assign(torrent.info, opts.info);
       if (opts.sslCert !== void 0)
         torrent.info["ssl-cert"] = opts.sslCert;
       if (opts.urlList !== void 0)
         torrent["url-list"] = opts.urlList;
       const estimatedTorrentLength = files.reduce(sumLength, 0);
       const pieceLength = opts.pieceLength || calcPieceLength(estimatedTorrentLength);
       torrent.info["piece length"] = pieceLength;
       getPieceList(
         files,
         pieceLength,
         estimatedTorrentLength,
         opts,
         (err, pieces, torrentLength) => {
           if (err)
             return cb(err);
           torrent.info.pieces = pieces;
           files.forEach((file) => {
             delete file.getStream;
           });
           if (opts.singleFileTorrent) {
             torrent.info.length = torrentLength;
           } else {
             torrent.info.files = files;
           }
           cb(null, bencode.encode(torrent));
         }
       );
     }
     function isJunkPath(path2) {
       const filename = path2[path2.length - 1];
       return filename[0] === "." && junk.is(filename);
     }
     function sumLength(sum, file) {
       return sum + file.length;
     }
     function isBlob(obj) {
       return typeof Blob !== "undefined" && obj instanceof Blob;
     }
     function isFileList(obj) {
       return typeof FileList !== "undefined" && obj instanceof FileList;
     }
     function isReadable(obj) {
       return typeof obj === "object" && obj != null && typeof obj.pipe === "function";
     }
     async function* getStreamStream(readable, file) {
       for await (const chunk of readable) {
         file.length += chunk.length;
         yield chunk;
       }
     }
     module2.exports = createTorrent;
     module2.exports.parseInput = parseInput;
     module2.exports.announceList = announceList;
     module2.exports.isJunkPath = isJunkPath;
   }
 });
 
 // node_modules/ms/index.js
 var require_ms = __commonJS({
   "node_modules/ms/index.js"(exports, module2) {
     var s = 1e3;
     var m = s * 60;
     var h = m * 60;
     var d = h * 24;
     var w = d * 7;
     var y = d * 365.25;
     module2.exports = function(val, options) {
       options = options || {};
       var type = typeof val;
       if (type === "string" && val.length > 0) {
         return parse(val);
       } else if (type === "number" && isFinite(val)) {
         return options.long ? fmtLong(val) : fmtShort(val);
       }
       throw new Error(
         "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
       );
     };
     function parse(str) {
       str = String(str);
       if (str.length > 100) {
         return;
       }
       var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
         str
       );
       if (!match) {
         return;
       }
       var n = parseFloat(match[1]);
       var type = (match[2] || "ms").toLowerCase();
       switch (type) {
         case "years":
         case "year":
         case "yrs":
         case "yr":
         case "y":
           return n * y;
         case "weeks":
         case "week":
         case "w":
           return n * w;
         case "days":
         case "day":
         case "d":
           return n * d;
         case "hours":
         case "hour":
         case "hrs":
         case "hr":
         case "h":
           return n * h;
         case "minutes":
         case "minute":
         case "mins":
         case "min":
         case "m":
           return n * m;
         case "seconds":
         case "second":
         case "secs":
         case "sec":
         case "s":
           return n * s;
         case "milliseconds":
         case "millisecond":
         case "msecs":
         case "msec":
         case "ms":
           return n;
         default:
           return void 0;
       }
     }
     function fmtShort(ms) {
       var msAbs = Math.abs(ms);
       if (msAbs >= d) {
         return Math.round(ms / d) + "d";
       }
       if (msAbs >= h) {
         return Math.round(ms / h) + "h";
       }
       if (msAbs >= m) {
         return Math.round(ms / m) + "m";
       }
       if (msAbs >= s) {
         return Math.round(ms / s) + "s";
       }
       return ms + "ms";
     }
     function fmtLong(ms) {
       var msAbs = Math.abs(ms);
       if (msAbs >= d) {
         return plural(ms, msAbs, d, "day");
       }
       if (msAbs >= h) {
         return plural(ms, msAbs, h, "hour");
       }
       if (msAbs >= m) {
         return plural(ms, msAbs, m, "minute");
       }
       if (msAbs >= s) {
         return plural(ms, msAbs, s, "second");
       }
       return ms + " ms";
     }
     function plural(ms, msAbs, n, name) {
       var isPlural = msAbs >= n * 1.5;
       return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
     }
   }
 });
 
 // node_modules/debug/src/common.js
 var require_common = __commonJS({
   "node_modules/debug/src/common.js"(exports, module2) {
     function setup(env) {
       createDebug.debug = createDebug;
       createDebug.default = createDebug;
       createDebug.coerce = coerce;
       createDebug.disable = disable;
       createDebug.enable = enable;
       createDebug.enabled = enabled;
       createDebug.humanize = require_ms();
       createDebug.destroy = destroy;
       Object.keys(env).forEach((key) => {
         createDebug[key] = env[key];
       });
       createDebug.names = [];
       createDebug.skips = [];
       createDebug.formatters = {};
       function selectColor(namespace) {
         let hash = 0;
         for (let i = 0; i < namespace.length; i++) {
           hash = (hash << 5) - hash + namespace.charCodeAt(i);
           hash |= 0;
         }
         return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
       }
       createDebug.selectColor = selectColor;
       function createDebug(namespace) {
         let prevTime;
         let enableOverride = null;
         let namespacesCache;
         let enabledCache;
         function debug(...args) {
           if (!debug.enabled) {
             return;
           }
           const self = debug;
           const curr = Number(new Date());
           const ms = curr - (prevTime || curr);
           self.diff = ms;
           self.prev = prevTime;
           self.curr = curr;
           prevTime = curr;
           args[0] = createDebug.coerce(args[0]);
           if (typeof args[0] !== "string") {
             args.unshift("%O");
           }
           let index = 0;
           args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
             if (match === "%%") {
               return "%";
             }
             index++;
             const formatter = createDebug.formatters[format];
             if (typeof formatter === "function") {
               const val = args[index];
               match = formatter.call(self, val);
               args.splice(index, 1);
               index--;
             }
             return match;
           });
           createDebug.formatArgs.call(self, args);
           const logFn = self.log || createDebug.log;
           logFn.apply(self, args);
         }
         debug.namespace = namespace;
         debug.useColors = createDebug.useColors();
         debug.color = createDebug.selectColor(namespace);
         debug.extend = extend;
         debug.destroy = createDebug.destroy;
         Object.defineProperty(debug, "enabled", {
           enumerable: true,
           configurable: false,
           get: () => {
             if (enableOverride !== null) {
               return enableOverride;
             }
             if (namespacesCache !== createDebug.namespaces) {
               namespacesCache = createDebug.namespaces;
               enabledCache = createDebug.enabled(namespace);
             }
             return enabledCache;
           },
           set: (v) => {
             enableOverride = v;
           }
         });
         if (typeof createDebug.init === "function") {
           createDebug.init(debug);
         }
         return debug;
       }
       function extend(namespace, delimiter) {
         const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
         newDebug.log = this.log;
         return newDebug;
       }
       function enable(namespaces) {
         createDebug.save(namespaces);
         createDebug.namespaces = namespaces;
         createDebug.names = [];
         createDebug.skips = [];
         let i;
         const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
         const len = split.length;
         for (i = 0; i < len; i++) {
           if (!split[i]) {
             continue;
           }
           namespaces = split[i].replace(/\*/g, ".*?");
           if (namespaces[0] === "-") {
             createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
           } else {
             createDebug.names.push(new RegExp("^" + namespaces + "$"));
           }
         }
       }
       function disable() {
         const namespaces = [
           ...createDebug.names.map(toNamespace),
           ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
         ].join(",");
         createDebug.enable("");
         return namespaces;
       }
       function enabled(name) {
         if (name[name.length - 1] === "*") {
           return true;
         }
         let i;
         let len;
         for (i = 0, len = createDebug.skips.length; i < len; i++) {
           if (createDebug.skips[i].test(name)) {
             return false;
           }
         }
         for (i = 0, len = createDebug.names.length; i < len; i++) {
           if (createDebug.names[i].test(name)) {
             return true;
           }
         }
         return false;
       }
       function toNamespace(regexp) {
         return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
       }
       function coerce(val) {
         if (val instanceof Error) {
           return val.stack || val.message;
         }
         return val;
       }
       function destroy() {
         console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
       }
       createDebug.enable(createDebug.load());
       return createDebug;
     }
     module2.exports = setup;
   }
 });
 
 // node_modules/debug/src/browser.js
 var require_browser = __commonJS({
   "node_modules/debug/src/browser.js"(exports, module2) {
     exports.formatArgs = formatArgs;
     exports.save = save;
     exports.load = load;
     exports.useColors = useColors;
     exports.storage = localstorage();
     exports.destroy = (() => {
       let warned = false;
       return () => {
         if (!warned) {
           warned = true;
           console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
         }
       };
     })();
     exports.colors = [
       "#0000CC",
       "#0000FF",
       "#0033CC",
       "#0033FF",
       "#0066CC",
       "#0066FF",
       "#0099CC",
       "#0099FF",
       "#00CC00",
       "#00CC33",
       "#00CC66",
       "#00CC99",
       "#00CCCC",
       "#00CCFF",
       "#3300CC",
       "#3300FF",
       "#3333CC",
       "#3333FF",
       "#3366CC",
       "#3366FF",
       "#3399CC",
       "#3399FF",
       "#33CC00",
       "#33CC33",
       "#33CC66",
       "#33CC99",
       "#33CCCC",
       "#33CCFF",
       "#6600CC",
       "#6600FF",
       "#6633CC",
       "#6633FF",
       "#66CC00",
       "#66CC33",
       "#9900CC",
       "#9900FF",
       "#9933CC",
       "#9933FF",
       "#99CC00",
       "#99CC33",
       "#CC0000",
       "#CC0033",
       "#CC0066",
       "#CC0099",
       "#CC00CC",
       "#CC00FF",
       "#CC3300",
       "#CC3333",
       "#CC3366",
       "#CC3399",
       "#CC33CC",
       "#CC33FF",
       "#CC6600",
       "#CC6633",
       "#CC9900",
       "#CC9933",
       "#CCCC00",
       "#CCCC33",
       "#FF0000",
       "#FF0033",
       "#FF0066",
       "#FF0099",
       "#FF00CC",
       "#FF00FF",
       "#FF3300",
       "#FF3333",
       "#FF3366",
       "#FF3399",
       "#FF33CC",
       "#FF33FF",
       "#FF6600",
       "#FF6633",
       "#FF9900",
       "#FF9933",
       "#FFCC00",
       "#FFCC33"
     ];
     function useColors() {
       if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
         return true;
       }
       if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
         return false;
       }
       return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
     }
     function formatArgs(args) {
       args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
       if (!this.useColors) {
         return;
       }
       const c = "color: " + this.color;
       args.splice(1, 0, c, "color: inherit");
       let index = 0;
       let lastC = 0;
       args[0].replace(/%[a-zA-Z%]/g, (match) => {
         if (match === "%%") {
           return;
         }
         index++;
         if (match === "%c") {
           lastC = index;
         }
       });
       args.splice(lastC, 0, c);
     }
     exports.log = console.debug || console.log || (() => {
     });
     function save(namespaces) {
       try {
         if (namespaces) {
           exports.storage.setItem("debug", namespaces);
         } else {
           exports.storage.removeItem("debug");
         }
       } catch (error) {
       }
     }
     function load() {
       let r;
       try {
         r = exports.storage.getItem("debug");
       } catch (error) {
       }
       if (!r && typeof process !== "undefined" && "env" in process) {
         r = process.env.DEBUG;
       }
       return r;
     }
     function localstorage() {
       try {
         return localStorage;
       } catch (error) {
       }
     }
     module2.exports = require_common()(exports);
     var { formatters } = module2.exports;
     formatters.j = function(v) {
       try {
         return JSON.stringify(v);
       } catch (error) {
         return "[UnexpectedJSONParseError]: " + error.message;
       }
     };
   }
 });
 
 // node_modules/debug/src/node.js
 var require_node = __commonJS({
   "node_modules/debug/src/node.js"(exports, module2) {
     var tty = require("tty");
     var util = require("util");
     exports.init = init;
     exports.log = log;
     exports.formatArgs = formatArgs;
     exports.save = save;
     exports.load = load;
     exports.useColors = useColors;
     exports.destroy = util.deprecate(
       () => {
       },
       "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
     );
     exports.colors = [6, 2, 3, 4, 5, 1];
     try {
       const supportsColor = require("supports-color");
       if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
         exports.colors = [
           20,
           21,
           26,
           27,
           32,
           33,
           38,
           39,
           40,
           41,
           42,
           43,
           44,
           45,
           56,
           57,
           62,
           63,
           68,
           69,
           74,
           75,
           76,
           77,
           78,
           79,
           80,
           81,
           92,
           93,
           98,
           99,
           112,
           113,
           128,
           129,
           134,
           135,
           148,
           149,
           160,
           161,
           162,
           163,
           164,
           165,
           166,
           167,
           168,
           169,
           170,
           171,
           172,
           173,
           178,
           179,
           184,
           185,
           196,
           197,
           198,
           199,
           200,
           201,
           202,
           203,
           204,
           205,
           206,
           207,
           208,
           209,
           214,
           215,
           220,
           221
         ];
       }
     } catch (error) {
     }
     exports.inspectOpts = Object.keys(process.env).filter((key) => {
       return /^debug_/i.test(key);
     }).reduce((obj, key) => {
       const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
         return k.toUpperCase();
       });
       let val = process.env[key];
       if (/^(yes|on|true|enabled)$/i.test(val)) {
         val = true;
       } else if (/^(no|off|false|disabled)$/i.test(val)) {
         val = false;
       } else if (val === "null") {
         val = null;
       } else {
         val = Number(val);
       }
       obj[prop] = val;
       return obj;
     }, {});
     function useColors() {
       return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
     }
     function formatArgs(args) {
       const { namespace: name, useColors: useColors2 } = this;
       if (useColors2) {
         const c = this.color;
         const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
         const prefix = `  ${colorCode};1m${name} \x1B[0m`;
         args[0] = prefix + args[0].split("\n").join("\n" + prefix);
         args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
       } else {
         args[0] = getDate() + name + " " + args[0];
       }
     }
     function getDate() {
       if (exports.inspectOpts.hideDate) {
         return "";
       }
       return new Date().toISOString() + " ";
     }
     function log(...args) {
       return process.stderr.write(util.format(...args) + "\n");
     }
     function save(namespaces) {
       if (namespaces) {
         process.env.DEBUG = namespaces;
       } else {
         delete process.env.DEBUG;
       }
     }
     function load() {
       return process.env.DEBUG;
     }
     function init(debug) {
       debug.inspectOpts = {};
       const keys = Object.keys(exports.inspectOpts);
       for (let i = 0; i < keys.length; i++) {
         debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
       }
     }
     module2.exports = require_common()(exports);
     var { formatters } = module2.exports;
     formatters.o = function(v) {
       this.inspectOpts.colors = this.useColors;
       return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
     };
     formatters.O = function(v) {
       this.inspectOpts.colors = this.useColors;
       return util.inspect(v, this.inspectOpts);
     };
   }
 });
 
 // node_modules/debug/src/index.js
 var require_src = __commonJS({
   "node_modules/debug/src/index.js"(exports, module2) {
     if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
       module2.exports = require_browser();
     } else {
       module2.exports = require_node();
     }
   }
 });
 
 // node_modules/randombytes/index.js
 var require_randombytes = __commonJS({
   "node_modules/randombytes/index.js"(exports, module2) {
     module2.exports = require("crypto").randomBytes;
   }
 });
 
 // node_modules/k-bucket/index.js
 var require_k_bucket = __commonJS({
   "node_modules/k-bucket/index.js"(exports, module2) {
     "use strict";
     var randomBytes = require_randombytes();
     var { EventEmitter } = require("events");
     function arrayEquals(array1, array2) {
       if (array1 === array2) {
         return true;
       }
       if (array1.length !== array2.length) {
         return false;
       }
       for (let i = 0, length = array1.length; i < length; ++i) {
         if (array1[i] !== array2[i]) {
           return false;
         }
       }
       return true;
     }
     function createNode() {
       return { contacts: [], dontSplit: false, left: null, right: null };
     }
     function ensureInt8(name, val) {
       if (!(val instanceof Uint8Array)) {
         throw new TypeError(name + " is not a Uint8Array");
       }
     }
     var KBucket = class extends EventEmitter {
       constructor(options = {}) {
         super();
         this.localNodeId = options.localNodeId || randomBytes(20);
         this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
         this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
         this.distance = options.distance || KBucket.distance;
         this.arbiter = options.arbiter || KBucket.arbiter;
         this.metadata = Object.assign({}, options.metadata);
         ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
         this.root = createNode();
       }
       static arbiter(incumbent, candidate) {
         return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
       }
       static distance(firstId, secondId) {
         let distance = 0;
         let i = 0;
         const min = Math.min(firstId.length, secondId.length);
         const max = Math.max(firstId.length, secondId.length);
         for (; i < min; ++i) {
           distance = distance * 256 + (firstId[i] ^ secondId[i]);
         }
         for (; i < max; ++i)
           distance = distance * 256 + 255;
         return distance;
       }
       add(contact) {
         ensureInt8("contact.id", (contact || {}).id);
         let bitIndex = 0;
         let node = this.root;
         while (node.contacts === null) {
           node = this._determineNode(node, contact.id, bitIndex++);
         }
         const index = this._indexOf(node, contact.id);
         if (index >= 0) {
           this._update(node, index, contact);
           return this;
         }
         if (node.contacts.length < this.numberOfNodesPerKBucket) {
           node.contacts.push(contact);
           this.emit("added", contact);
           return this;
         }
         if (node.dontSplit) {
           this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
           return this;
         }
         this._split(node, bitIndex);
         return this.add(contact);
       }
       closest(id, n = Infinity) {
         ensureInt8("id", id);
         if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
           throw new TypeError("n is not positive number");
         }
         let contacts = [];
         for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
           const node = nodes.pop();
           if (node.contacts === null) {
             const detNode = this._determineNode(node, id, bitIndex++);
             nodes.push(node.left === detNode ? node.right : node.left);
             nodes.push(detNode);
           } else {
             contacts = contacts.concat(node.contacts);
           }
         }
         return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
       }
       count() {
         let count = 0;
         for (const nodes = [this.root]; nodes.length > 0; ) {
           const node = nodes.pop();
           if (node.contacts === null)
             nodes.push(node.right, node.left);
           else
             count += node.contacts.length;
         }
         return count;
       }
       _determineNode(node, id, bitIndex) {
         const bytesDescribedByBitIndex = bitIndex >> 3;
         const bitIndexWithinByte = bitIndex % 8;
         if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
           return node.left;
         }
         const byteUnderConsideration = id[bytesDescribedByBitIndex];
         if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
           return node.right;
         }
         return node.left;
       }
       get(id) {
         ensureInt8("id", id);
         let bitIndex = 0;
         let node = this.root;
         while (node.contacts === null) {
           node = this._determineNode(node, id, bitIndex++);
         }
         const index = this._indexOf(node, id);
         return index >= 0 ? node.contacts[index] : null;
       }
       _indexOf(node, id) {
         for (let i = 0; i < node.contacts.length; ++i) {
           if (arrayEquals(node.contacts[i].id, id))
             return i;
         }
         return -1;
       }
       remove(id) {
         ensureInt8("the id as parameter 1", id);
         let bitIndex = 0;
         let node = this.root;
         while (node.contacts === null) {
           node = this._determineNode(node, id, bitIndex++);
         }
         const index = this._indexOf(node, id);
         if (index >= 0) {
           const contact = node.contacts.splice(index, 1)[0];
           this.emit("removed", contact);
         }
         return this;
       }
       _split(node, bitIndex) {
         node.left = createNode();
         node.right = createNode();
         for (const contact of node.contacts) {
           this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
         }
         node.contacts = null;
         const detNode = this._determineNode(node, this.localNodeId, bitIndex);
         const otherNode = node.left === detNode ? node.right : node.left;
         otherNode.dontSplit = true;
       }
       toArray() {
         let result = [];
         for (const nodes = [this.root]; nodes.length > 0; ) {
           const node = nodes.pop();
           if (node.contacts === null)
             nodes.push(node.right, node.left);
           else
             result = result.concat(node.contacts);
         }
         return result;
       }
       *toIterable() {
         for (const nodes = [this.root]; nodes.length > 0; ) {
           const node = nodes.pop();
           if (node.contacts === null) {
             nodes.push(node.right, node.left);
           } else {
             yield* node.contacts;
           }
         }
       }
       _update(node, index, contact) {
         if (!arrayEquals(node.contacts[index].id, contact.id)) {
           throw new Error("wrong index for _update");
         }
         const incumbent = node.contacts[index];
         const selection = this.arbiter(incumbent, contact);
         if (selection === incumbent && incumbent !== contact)
           return;
         node.contacts.splice(index, 1);
         node.contacts.push(selection);
         this.emit("updated", incumbent, selection);
       }
     };
     module2.exports = KBucket;
   }
 });
 
 // node_modules/k-rpc-socket/index.js
 var require_k_rpc_socket = __commonJS({
   "node_modules/k-rpc-socket/index.js"(exports, module2) {
     var dgram = require("dgram");
     var bencode = require_lib();
     var isIP = require("net").isIP;
     var dns = require("dns");
     var util = require("util");
     var events = require("events");
     var ETIMEDOUT = new Error("Query timed out");
     ETIMEDOUT.code = "ETIMEDOUT";
     var EUNEXPECTEDNODE = new Error("Unexpected node id");
     EUNEXPECTEDNODE.code = "EUNEXPECTEDNODE";
     module2.exports = RPC;
     function RPC(opts) {
       if (!(this instanceof RPC))
         return new RPC(opts);
       if (!opts)
         opts = {};
       var self = this;
       this.timeout = opts.timeout || 2e3;
       this.inflight = 0;
       this.destroyed = false;
       this.isIP = opts.isIP || isIP;
       this.socket = opts.socket || dgram.createSocket("udp4");
       this.socket.on("message", onmessage);
       this.socket.on("error", onerror);
       this.socket.on("listening", onlistening);
       this._tick = 0;
       this._ids = [];
       this._reqs = [];
       this._timer = setInterval(check, Math.floor(this.timeout / 4));
       events.EventEmitter.call(this);
       function check() {
         var missing = self.inflight;
         if (!missing)
           return;
         for (var i = 0; i < self._reqs.length; i++) {
           var req = self._reqs[i];
           if (!req)
             continue;
           if (req.ttl)
             req.ttl--;
           else
             self._cancel(i, ETIMEDOUT);
           if (!--missing)
             return;
         }
       }
       function onlistening() {
         self.emit("listening");
       }
       function onerror(err) {
         if (err.code === "EACCES" || err.code === "EADDRINUSE")
           self.emit("error", err);
         else
           self.emit("warning", err);
       }
       function onmessage(buf, rinfo) {
         if (self.destroyed)
           return;
         if (!rinfo.port)
           return;
         try {
           var message = bencode.decode(buf);
         } catch (e) {
           return self.emit("warning", e);
         }
         var type = message && message.y && message.y.toString();
         if (type === "r" || type === "e") {
           if (!Buffer.isBuffer(message.t))
             return;
           try {
             var tid = message.t.readUInt16BE(0);
           } catch (err2) {
             return self.emit("warning", err2);
           }
           var index = self._ids.indexOf(tid);
           if (index === -1 || tid === 0) {
             self.emit("response", message, rinfo);
             self.emit("warning", new Error("Unexpected transaction id: " + tid));
             return;
           }
           var req = self._reqs[index];
           if (req.peer.host !== rinfo.address) {
             self.emit("response", message, rinfo);
             self.emit("warning", new Error("Out of order response"));
             return;
           }
           self._ids[index] = 0;
           self._reqs[index] = null;
           self.inflight--;
           if (type === "e") {
             var isArray = Array.isArray(message.e);
             var err = new Error(isArray ? message.e.join(" ") : "Unknown error");
             err.code = isArray && message.e.length && typeof message.e[0] === "number" ? message.e[0] : 0;
             req.callback(err, message, rinfo, req.message);
             self.emit("update");
             self.emit("postupdate");
             return;
           }
           var rid = message.r && message.r.id;
           if (req.peer && req.peer.id && rid && !req.peer.id.equals(rid)) {
             req.callback(EUNEXPECTEDNODE, null, rinfo);
             self.emit("update");
             self.emit("postupdate");
             return;
           }
           req.callback(null, message, rinfo, req.message);
           self.emit("update");
           self.emit("postupdate");
           self.emit("response", message, rinfo);
         } else if (type === "q") {
           self.emit("query", message, rinfo);
         } else {
           self.emit("warning", new Error("Unknown type: " + type));
         }
       }
     }
     util.inherits(RPC, events.EventEmitter);
     RPC.prototype.address = function() {
       return this.socket.address();
     };
     RPC.prototype.response = function(peer, req, res, cb) {
       this.send(peer, { t: req.t, y: "r", r: res }, cb);
     };
     RPC.prototype.error = function(peer, req, error, cb) {
       this.send(peer, { t: req.t, y: "e", e: [].concat(error.message || error) }, cb);
     };
     RPC.prototype.send = function(peer, message, cb) {
       var buf = bencode.encode(message);
       this.socket.send(buf, 0, buf.length, peer.port, peer.address || peer.host, cb || noop2);
     };
     RPC.prototype.bind = function() {
       this.socket.bind.apply(this.socket, arguments);
     };
     RPC.prototype.destroy = function(cb) {
       this.destroyed = true;
       clearInterval(this._timer);
       if (cb)
         this.socket.on("close", cb);
       for (var i = 0; i < this._ids.length; i++)
         this._cancel(i);
       this.socket.close();
     };
     RPC.prototype.query = function(peer, query, cb) {
       if (!cb)
         cb = noop2;
       if (!this.isIP(peer.host))
         return this._resolveAndQuery(peer, query, cb);
       var message = {
         t: Buffer.allocUnsafe(2),
         y: "q",
         q: query.q,
         a: query.a
       };
       var req = {
         ttl: 4,
         peer,
         message,
         callback: cb
       };
       if (this._tick === 65535)
         this._tick = 0;
       var tid = ++this._tick;
       var free = this._ids.indexOf(0);
       if (free === -1)
         free = this._ids.push(0) - 1;
       this._ids[free] = tid;
       while (this._reqs.length < free)
         this._reqs.push(null);
       this._reqs[free] = req;
       this.inflight++;
       message.t.writeUInt16BE(tid, 0);
       this.send(peer, message);
       return tid;
     };
     RPC.prototype.cancel = function(tid, err) {
       var index = this._ids.indexOf(tid);
       if (index > -1)
         this._cancel(index, err);
     };
     RPC.prototype._cancel = function(index, err) {
       var req = this._reqs[index];
       this._ids[index] = 0;
       this._reqs[index] = null;
       if (req) {
         this.inflight--;
         req.callback(err || new Error("Query was cancelled"), null, req.peer);
         this.emit("update");
         this.emit("postupdate");
       }
     };
     RPC.prototype._resolveAndQuery = function(peer, query, cb) {
       var self = this;
       dns.lookup(peer.host, function(err, ip) {
         if (err)
           return cb(err);
         if (self.destroyed)
           return cb(new Error("k-rpc-socket is destroyed"));
         self.query({ host: ip, port: peer.port }, query, cb);
       });
     };
     function noop2() {
     }
   }
 });
 
 // node_modules/k-rpc/index.js
 var require_k_rpc = __commonJS({
   "node_modules/k-rpc/index.js"(exports, module2) {
     var socket = require_k_rpc_socket();
     var KBucket = require_k_bucket();
     var events = require("events");
     var randombytes2 = require_randombytes();
     var util = require("util");
     var K = 20;
     var MAX_CONCURRENCY = 16;
     var BOOTSTRAP_NODES = [
       { host: "router.bittorrent.com", port: 6881 },
       { host: "router.utorrent.com", port: 6881 },
       { host: "dht.transmissionbt.com", port: 6881 }
     ];
     module2.exports = RPC;
     function RPC(opts) {
       if (!(this instanceof RPC))
         return new RPC(opts);
       if (!opts)
         opts = {};
       var self = this;
       this._idLength = opts.idLength || 20;
       this.id = toBuffer(opts.id || opts.nodeId || randombytes2(this._idLength));
       this.socket = opts.krpcSocket || socket(opts);
       this.bootstrap = toBootstrapArray(opts.nodes || opts.bootstrap);
       this.concurrency = opts.concurrency || MAX_CONCURRENCY;
       this.backgroundConcurrency = opts.backgroundConcurrency || this.concurrency / 4 | 0;
       this.k = opts.k || K;
       this.destroyed = false;
       this.pending = [];
       this.nodes = null;
       this.socket.setMaxListeners(0);
       this.socket.on("query", onquery);
       this.socket.on("response", onresponse);
       this.socket.on("warning", onwarning);
       this.socket.on("error", onerror);
       this.socket.on("update", onupdate);
       this.socket.on("listening", onlistening);
       events.EventEmitter.call(this);
       this.clear();
       function onupdate() {
         while (self.pending.length && self.socket.inflight < self.concurrency) {
           var next = self.pending.shift();
           self.query(next[0], next[1], next[2]);
         }
       }
       function onerror(err) {
         self.emit("error", err);
       }
       function onlistening() {
         self.emit("listening");
       }
       function onwarning(err) {
         self.emit("warning", err);
       }
       function onquery(query, peer) {
         addNode(query.a, peer);
         self.emit("query", query, peer);
       }
       function onresponse(reply, peer) {
         addNode(reply.r, peer);
       }
       function addNode(data, peer) {
         if (data && isNodeId(data.id, self._idLength) && !data.id.equals(self.id)) {
           var old = self.nodes.get(data.id);
           if (old) {
             old.seen = Date.now();
             return;
           }
           self._addNode({
             id: data.id,
             host: peer.address || peer.host,
             port: peer.port,
             distance: 0,
             seen: Date.now()
           });
         }
       }
     }
     util.inherits(RPC, events.EventEmitter);
     RPC.prototype.response = function(node, query, response, nodes, cb) {
       if (typeof nodes === "function") {
         cb = nodes;
         nodes = null;
       }
       if (!response.id)
         response.id = this.id;
       if (nodes)
         response.nodes = encodeNodes(nodes, this._idLength);
       this.socket.response(node, query, response, cb);
     };
     RPC.prototype.error = function(node, query, error, cb) {
       this.socket.error(node, query, error, cb);
     };
     RPC.prototype.bind = function() {
       this.socket.bind.apply(this.socket, arguments);
     };
     RPC.prototype.address = function() {
       return this.socket.address();
     };
     RPC.prototype.queryAll = function(nodes, message, visit, cb) {
       if (!message.a)
         message.a = {};
       if (!message.a.id)
         message.a.id = this.id;
       var stop = false;
       var missing = nodes.length;
       var hits = 0;
       var error = null;
       if (!missing)
         return cb(new Error("No nodes to query"), 0);
       for (var i = 0; i < nodes.length; i++) {
         this.query(nodes[i], message, done);
       }
       function done(err, res, peer) {
         if (!err)
           hits++;
         else if (err.code >= 300 && err.code < 400)
           error = err;
         if (!err && !stop) {
           if (visit && visit(res, peer) === false)
             stop = true;
         }
         if (!--missing)
           cb(hits ? null : error || new Error("All queries failed"), hits);
       }
     };
     RPC.prototype.query = function(node, message, cb) {
       if (this.socket.inflight >= this.concurrency) {
         this.pending.push([node, message, cb]);
       } else {
         if (!message.a)
           message.a = {};
         if (!message.a.id)
           message.a.id = this.id;
         if (node.token)
           message.a.token = node.token;
         this.socket.query(node, message, cb);
       }
     };
     RPC.prototype.destroy = function(cb) {
       this.destroyed = true;
       this.socket.destroy(cb);
     };
     RPC.prototype.clear = function() {
       var self = this;
       this.nodes = new KBucket({
         localNodeId: this.id,
         numberOfNodesPerKBucket: this.k,
         numberOfNodesToPing: this.concurrency
       });
       this.nodes.on("ping", onping);
       function onping(older, newer) {
         self.emit("ping", older, function swap(deadNode) {
           if (!deadNode)
             return;
           if (deadNode.id)
             self.nodes.remove(deadNode.id);
           self._addNode(newer);
         });
       }
     };
     RPC.prototype.populate = function(target, message, cb) {
       this._closest(target, message, true, null, cb);
     };
     RPC.prototype.closest = function(target, message, visit, cb) {
       this._closest(target, message, false, visit, cb);
     };
     RPC.prototype._addNode = function(node) {
       var old = this.nodes.get(node.id);
       this.nodes.add(node);
       if (!old)
         this.emit("node", node);
     };
     RPC.prototype._closest = function(target, message, background, visit, cb) {
       if (!cb)
         cb = noop2;
       var self = this;
       var count = 0;
       var queried = {};
       var pending = 0;
       var once = true;
       var stop = false;
       if (!message.a)
         message.a = {};
       if (!message.a.id)
         message.a.id = this.id;
       var table = new KBucket({
         localNodeId: target,
         numberOfNodesPerKBucket: this.k,
         numberOfNodesToPing: this.concurrency
       });
       var evt = background ? "postupdate" : "update";
       this.socket.on(evt, kick);
       kick();
       function kick() {
         if (self.destroyed || self.socket.inflight >= self.concurrency)
           return;
         var otherInflight = self.pending.length + self.socket.inflight - pending;
         if (background && self.socket.inflight >= self.backgroundConcurrency && otherInflight)
           return;
         var closest = table.closest(target, self.k);
         if (!closest.length || closest.length < self.bootstrap.length) {
           closest = self.nodes.closest(target, self.k);
           if (!closest.length || closest.length < self.bootstrap.length)
             bootstrap();
         }
         for (var i = 0; i < closest.length; i++) {
           if (stop)
             break;
           if (self.socket.inflight >= self.concurrency)
             return;
           var peer = closest[i];
           var id = peer.host + ":" + peer.port;
           if (queried[id])
             continue;
           queried[id] = true;
           pending++;
           self.socket.query(peer, message, afterQuery);
         }
         if (!pending) {
           self.socket.removeListener(evt, kick);
           process.nextTick(done);
         }
       }
       function done() {
         cb(null, count);
       }
       function bootstrap() {
         if (!once)
           return;
         once = false;
         self.bootstrap.forEach(function(peer) {
           pending++;
           self.socket.query(peer, message, afterQuery);
         });
       }
       function afterQuery(err, res, peer) {
         pending--;
         if (peer)
           queried[(peer.address || peer.host) + ":" + peer.port] = true;
         if (peer && peer.id && self.nodes.get(peer.id)) {
           if (err && (err.code === "EUNEXPECTEDNODE" || err.code === "ETIMEDOUT")) {
             self.nodes.remove(peer.id);
           }
         }
         var r = res && res.r;
         if (!r)
           return kick();
         if (!err && isNodeId(r.id, self._idLength)) {
           count++;
           add({
             id: r.id,
             port: peer.port,
             host: peer.host || peer.address,
             distance: 0
           });
         }
         var nodes = r.nodes ? parseNodes(r.nodes, self._idLength) : [];
         for (var i = 0; i < nodes.length; i++)
           add(nodes[i]);
         if (visit && visit(res, peer) === false)
           stop = true;
         kick();
       }
       function add(node) {
         if (node.id.equals(self.id))
           return;
         table.add(node);
       }
     };
     function toBootstrapArray(val) {
       if (val === false)
         return [];
       if (val === true)
         return BOOTSTRAP_NODES;
       return [].concat(val || BOOTSTRAP_NODES).map(parsePeer);
     }
     function isNodeId(id, idLength) {
       return id && Buffer.isBuffer(id) && id.length === idLength;
     }
     function encodeNodes(nodes, idLength) {
       var buf = Buffer.allocUnsafe(nodes.length * (idLength + 6));
       var ptr = 0;
       for (var i = 0; i < nodes.length; i++) {
         var node = nodes[i];
         if (!isNodeId(node.id, idLength))
           continue;
         node.id.copy(buf, ptr);
         ptr += idLength;
         var ip = (node.host || node.address).split(".");
         for (var j = 0; j < 4; j++)
           buf[ptr++] = parseInt(ip[j] || 0, 10);
         buf.writeUInt16BE(node.port, ptr);
         ptr += 2;
       }
       if (ptr === buf.length)
         return buf;
       return buf.slice(0, ptr);
     }
     function parseNodes(buf, idLength) {
       var contacts = [];
       try {
         for (var i = 0; i < buf.length; i += idLength + 6) {
           var port = buf.readUInt16BE(i + (idLength + 4));
           if (!port)
             continue;
           contacts.push({
             id: buf.slice(i, i + idLength),
             host: parseIp(buf, i + idLength),
             port,
             distance: 0,
             token: null
           });
         }
       } catch (err) {
       }
       return contacts;
     }
     function parseIp(buf, offset) {
       return buf[offset++] + "." + buf[offset++] + "." + buf[offset++] + "." + buf[offset++];
     }
     function parsePeer(peer) {
       if (typeof peer === "string")
         return { host: peer.split(":")[0], port: Number(peer.split(":")[1]) };
       return peer;
     }
     function noop2() {
     }
     function toBuffer(str) {
       if (Buffer.isBuffer(str))
         return str;
       if (ArrayBuffer.isView(str))
         return Buffer.from(str.buffer, str.byteOffset, str.byteLength);
       if (typeof str === "string")
         return Buffer.from(str, "hex");
       throw new Error("Pass a buffer or a string");
     }
   }
 });
 
 // node_modules/last-one-wins/index.js
 var require_last_one_wins = __commonJS({
   "node_modules/last-one-wins/index.js"(exports, module2) {
     module2.exports = function(work) {
       var pending = null;
       var callback = null;
       var callbacks = null;
       var next = null;
       return function(val, cb) {
         next = val;
         update(cb || noop2);
       };
       function update(cb) {
         if (callback) {
           if (!pending)
             pending = [];
           pending.push(cb);
           return;
         }
         var val = next;
         next = null;
         callback = cb;
         work(val, done);
       }
       function done(err) {
         var cb = callback;
         var cbs = callbacks;
         callbacks = null;
         callback = null;
         if (pending) {
           callbacks = pending;
           pending = null;
           update(noop2);
         }
         if (cbs) {
           for (var i = 0; i < cbs.length; i++)
             cbs[i](err);
         }
         cb(err);
       }
     };
     function noop2(_) {
     }
   }
 });
 
 // node_modules/inherits/inherits_browser.js
 var require_inherits_browser = __commonJS({
   "node_modules/inherits/inherits_browser.js"(exports, module2) {
     if (typeof Object.create === "function") {
       module2.exports = function inherits(ctor, superCtor) {
         if (superCtor) {
           ctor.super_ = superCtor;
           ctor.prototype = Object.create(superCtor.prototype, {
             constructor: {
               value: ctor,
               enumerable: false,
               writable: true,
               configurable: true
             }
           });
         }
       };
     } else {
       module2.exports = function inherits(ctor, superCtor) {
         if (superCtor) {
           ctor.super_ = superCtor;
           var TempCtor = function() {
           };
           TempCtor.prototype = superCtor.prototype;
           ctor.prototype = new TempCtor();
           ctor.prototype.constructor = ctor;
         }
       };
     }
   }
 });
 
 // node_modules/inherits/inherits.js
 var require_inherits = __commonJS({
   "node_modules/inherits/inherits.js"(exports, module2) {
     try {
       util = require("util");
       if (typeof util.inherits !== "function")
         throw "";
       module2.exports = util.inherits;
     } catch (e) {
       module2.exports = require_inherits_browser();
     }
     var util;
   }
 });
 
 // node_modules/lru/index.js
 var require_lru = __commonJS({
   "node_modules/lru/index.js"(exports, module2) {
     var events = require("events");
     var inherits = require_inherits();
     module2.exports = LRU;
     function LRU(opts) {
       if (!(this instanceof LRU))
         return new LRU(opts);
       if (typeof opts === "number")
         opts = { max: opts };
       if (!opts)
         opts = {};
       events.EventEmitter.call(this);
       this.cache = {};
       this.head = this.tail = null;
       this.length = 0;
       this.max = opts.max || 1e3;
       this.maxAge = opts.maxAge || 0;
     }
     inherits(LRU, events.EventEmitter);
     Object.defineProperty(LRU.prototype, "keys", {
       get: function() {
         return Object.keys(this.cache);
       }
     });
     LRU.prototype.clear = function() {
       this.cache = {};
       this.head = this.tail = null;
       this.length = 0;
     };
     LRU.prototype.remove = function(key) {
       if (typeof key !== "string")
         key = "" + key;
       if (!this.cache.hasOwnProperty(key))
         return;
       var element = this.cache[key];
       delete this.cache[key];
       this._unlink(key, element.prev, element.next);
       return element.value;
     };
     LRU.prototype._unlink = function(key, prev, next) {
       this.length--;
       if (this.length === 0) {
         this.head = this.tail = null;
       } else {
         if (this.head === key) {
           this.head = prev;
           this.cache[this.head].next = null;
         } else if (this.tail === key) {
           this.tail = next;
           this.cache[this.tail].prev = null;
         } else {
           this.cache[prev].next = next;
           this.cache[next].prev = prev;
         }
       }
     };
     LRU.prototype.peek = function(key) {
       if (!this.cache.hasOwnProperty(key))
         return;
       var element = this.cache[key];
       if (!this._checkAge(key, element))
         return;
       return element.value;
     };
     LRU.prototype.set = function(key, value) {
       if (typeof key !== "string")
         key = "" + key;
       var element;
       if (this.cache.hasOwnProperty(key)) {
         element = this.cache[key];
         element.value = value;
         if (this.maxAge)
           element.modified = Date.now();
         if (key === this.head)
           return value;
         this._unlink(key, element.prev, element.next);
       } else {
         element = { value, modified: 0, next: null, prev: null };
         if (this.maxAge)
           element.modified = Date.now();
         this.cache[key] = element;
         if (this.length === this.max)
           this.evict();
       }
       this.length++;
       element.next = null;
       element.prev = this.head;
       if (this.head)
         this.cache[this.head].next = key;
       this.head = key;
       if (!this.tail)
         this.tail = key;
       return value;
     };
     LRU.prototype._checkAge = function(key, element) {
       if (this.maxAge && Date.now() - element.modified > this.maxAge) {
         this.remove(key);
         this.emit("evict", { key, value: element.value });
         return false;
       }
       return true;
     };
     LRU.prototype.get = function(key) {
       if (typeof key !== "string")
         key = "" + key;
       if (!this.cache.hasOwnProperty(key))
         return;
       var element = this.cache[key];
       if (!this._checkAge(key, element))
         return;
       if (this.head !== key) {
         if (key === this.tail) {
           this.tail = element.next;
           this.cache[this.tail].prev = null;
         } else {
           this.cache[element.prev].next = element.next;
         }
         this.cache[element.next].prev = element.prev;
         this.cache[this.head].next = key;
         element.prev = this.head;
         element.next = null;
         this.head = key;
       }
       return element.value;
     };
     LRU.prototype.evict = function() {
       if (!this.tail)
         return;
       var key = this.tail;
       var value = this.remove(this.tail);
       this.emit("evict", { key, value });
     };
   }
 });
 
 // node_modules/b4a/index.js
 var require_b4a = __commonJS({
   "node_modules/b4a/index.js"(exports, module2) {
     function isBuffer(value) {
       return Buffer.isBuffer(value) || value instanceof Uint8Array;
     }
     function isEncoding(encoding) {
       return Buffer.isEncoding(encoding);
     }
     function alloc(size, fill2, encoding) {
       return Buffer.alloc(size, fill2, encoding);
     }
     function allocUnsafe(size) {
       return Buffer.allocUnsafe(size);
     }
     function allocUnsafeSlow(size) {
       return Buffer.allocUnsafeSlow(size);
     }
     function byteLength(string, encoding) {
       return Buffer.byteLength(string, encoding);
     }
     function compare(a, b) {
       return Buffer.compare(a, b);
     }
     function concat(buffers, totalLength) {
       return Buffer.concat(buffers, totalLength);
     }
     function copy(source, target, targetStart, start, end) {
       return toBuffer(source).copy(target, targetStart, start, end);
     }
     function equals(a, b) {
       return toBuffer(a).equals(b);
     }
     function fill(buffer, value, offset, end, encoding) {
       return toBuffer(buffer).fill(value, offset, end, encoding);
     }
     function from(value, encodingOrOffset, length) {
       return Buffer.from(value, encodingOrOffset, length);
     }
     function includes(buffer, value, byteOffset, encoding) {
       return toBuffer(buffer).includes(value, byteOffset, encoding);
     }
     function indexOf(buffer, value, byfeOffset, encoding) {
       return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
     }
     function lastIndexOf(buffer, value, byteOffset, encoding) {
       return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
     }
     function swap16(buffer) {
       return toBuffer(buffer).swap16();
     }
     function swap32(buffer) {
       return toBuffer(buffer).swap32();
     }
     function swap64(buffer) {
       return toBuffer(buffer).swap64();
     }
     function toBuffer(buffer) {
       if (Buffer.isBuffer(buffer))
         return buffer;
       return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
     }
     function toString(buffer, encoding, start, end) {
       return toBuffer(buffer).toString(encoding, start, end);
     }
     function write(buffer, string, offset, length, encoding) {
       return toBuffer(buffer).write(string, offset, length, encoding);
     }
     function writeDoubleLE(buffer, value, offset) {
       return toBuffer(buffer).writeDoubleLE(value, offset);
     }
     function writeFloatLE(buffer, value, offset) {
       return toBuffer(buffer).writeFloatLE(value, offset);
     }
     function writeUInt32LE(buffer, value, offset) {
       return toBuffer(buffer).writeUInt32LE(value, offset);
     }
     function writeInt32LE(buffer, value, offset) {
       return toBuffer(buffer).writeInt32LE(value, offset);
     }
     function readDoubleLE(buffer, offset) {
       return toBuffer(buffer).readDoubleLE(offset);
     }
     function readFloatLE(buffer, offset) {
       return toBuffer(buffer).readFloatLE(offset);
     }
     function readUInt32LE(buffer, offset) {
       return toBuffer(buffer).readUInt32LE(offset);
     }
     function readInt32LE(buffer, offset) {
       return toBuffer(buffer).readInt32LE(offset);
     }
     module2.exports = {
       isBuffer,
       isEncoding,
       alloc,
       allocUnsafe,
       allocUnsafeSlow,
       byteLength,
       compare,
       concat,
       copy,
       equals,
       fill,
       from,
       includes,
       indexOf,
       lastIndexOf,
       swap16,
       swap32,
       swap64,
       toBuffer,
       toString,
       write,
       writeDoubleLE,
       writeFloatLE,
       writeUInt32LE,
       writeInt32LE,
       readDoubleLE,
       readFloatLE,
       readUInt32LE,
       readInt32LE
     };
   }
 });
 
 // node_modules/record-cache/index.js
 var require_record_cache = __commonJS({
   "node_modules/record-cache/index.js"(exports, module2) {
     var b4a = require_b4a();
     var EMPTY = [];
     module2.exports = RecordCache;
     function RecordSet() {
       this.list = [];
       this.map = /* @__PURE__ */ new Map();
     }
     RecordSet.prototype.add = function(record, value) {
       var k = toString(record);
       var r = this.map.get(k);
       if (r)
         return false;
       r = { index: this.list.length, record: value || record };
       this.list.push(r);
       this.map.set(k, r);
       return true;
     };
     RecordSet.prototype.remove = function(record) {
       var k = toString(record);
       var r = this.map.get(k);
       if (!r)
         return false;
       swap(this.list, r.index, this.list.length - 1);
       this.list.pop();
       this.map.delete(k);
       return true;
     };
     function RecordStore() {
       this.records = /* @__PURE__ */ new Map();
       this.size = 0;
     }
     RecordStore.prototype.add = function(name, record, value) {
       var r = this.records.get(name);
       if (!r) {
         r = new RecordSet();
         this.records.set(name, r);
       }
       if (r.add(record, value)) {
         this.size++;
         return true;
       }
       return false;
     };
     RecordStore.prototype.remove = function(name, record, value) {
       var r = this.records.get(name);
       if (!r)
         return false;
       if (r.remove(record, value)) {
         this.size--;
         if (!r.map.size)
           this.records.delete(name);
         return true;
       }
       return false;
     };
     RecordStore.prototype.get = function(name) {
       var r = this.records.get(name);
       return r ? r.list : EMPTY;
     };
     function RecordCache(opts) {
       if (!(this instanceof RecordCache))
         return new RecordCache(opts);
       if (!opts)
         opts = {};
       this.maxSize = opts.maxSize || Infinity;
       this.maxAge = opts.maxAge || 0;
       this._onstale = opts.onStale || opts.onstale || null;
       this._fresh = new RecordStore();
       this._stale = new RecordStore();
       this._interval = null;
       this._gced = false;
       if (this.maxAge && this.maxAge < Infinity) {
         var tick = Math.ceil(2 / 3 * this.maxAge);
         this._interval = setInterval(this._gcAuto.bind(this), tick);
         if (this._interval.unref)
           this._interval.unref();
       }
     }
     Object.defineProperty(RecordCache.prototype, "size", {
       get: function() {
         return this._fresh.size + this._stale.size;
       }
     });
     RecordCache.prototype.add = function(name, record, value) {
       this._stale.remove(name, record, value);
       if (this._fresh.add(name, record, value) && this._fresh.size > this.maxSize) {
         this._gc();
       }
     };
     RecordCache.prototype.remove = function(name, record, value) {
       this._fresh.remove(name, record, value);
       this._stale.remove(name, record, value);
     };
     RecordCache.prototype.get = function(name, n) {
       var a = this._fresh.get(name);
       var b = this._stale.get(name);
       var aLen = a.length;
       var bLen = b.length;
       var len = aLen + bLen;
       if (n > len || !n)
         n = len;
       var result = new Array(n);
       for (var i = 0; i < n; i++) {
         var j = Math.floor(Math.random() * (aLen + bLen));
         if (j < aLen) {
           result[i] = a[j].record;
           swap(a, j, --aLen);
         } else {
           j -= aLen;
           result[i] = b[j].record;
           swap(b, j, --bLen);
         }
       }
       return result;
     };
     RecordCache.prototype._gcAuto = function() {
       if (!this._gced)
         this._gc();
       this._gced = false;
     };
     RecordCache.prototype._gc = function() {
       if (this._onstale && this._stale.size > 0)
         this._onstale(this._stale);
       this._stale = this._fresh;
       this._fresh = new RecordStore();
       this._gced = true;
     };
     RecordCache.prototype.clear = function() {
       this._gc();
       this._gc();
     };
     RecordCache.prototype.destroy = function() {
       this.clear();
       clearInterval(this._interval);
       this._interval = null;
     };
     function toString(record) {
       return b4a.isBuffer(record) ? b4a.toString(record, "hex") : record;
     }
     function swap(list, a, b) {
       var tmp = list[a];
       tmp.index = b;
       list[b].index = a;
       list[a] = list[b];
       list[b] = tmp;
     }
   }
 });
 
 // node_modules/bittorrent-dht/client.js
 var require_client = __commonJS({
   "node_modules/bittorrent-dht/client.js"(exports, module2) {
     var bencode = require_lib();
     var debug = require_src()("bittorrent-dht");
     var KBucket = require_k_bucket();
     var krpc = require_k_rpc();
     var low = require_last_one_wins();
     var LRU = require_lru();
     var randombytes2 = require_randombytes();
     var records = require_record_cache();
     var simpleSha1 = require_simple_sha1();
     var { EventEmitter } = require("events");
     var ROTATE_INTERVAL = 5 * 60 * 1e3;
     var BUCKET_OUTDATED_TIMESPAN = 15 * 60 * 1e3;
     var DHT = class extends EventEmitter {
       constructor(opts = {}) {
         super();
         this._tables = new LRU({ maxAge: ROTATE_INTERVAL, max: opts.maxTables || 1e3 });
         this._values = new LRU(opts.maxValues || 1e3);
         this._peers = records({
           maxAge: opts.maxAge || 0,
           maxSize: opts.maxPeers || 1e4
         });
         this._secrets = null;
         this._hash = opts.hash || sha1;
         this._hashLength = this._hash(Buffer.from("")).length;
         this._rpc = opts.krpc || krpc(Object.assign({ idLength: this._hashLength }, opts));
         this._rpc.on("query", onquery);
         this._rpc.on("node", onnode);
         this._rpc.on("warning", onwarning);
         this._rpc.on("error", onerror);
         this._rpc.on("listening", onlistening);
         this._rotateSecrets();
         this._verify = opts.verify || null;
         this._host = opts.host || null;
         this._interval = setInterval(rotateSecrets, ROTATE_INTERVAL);
         this._runningBucketCheck = false;
         this._bucketCheckTimeout = null;
         this._bucketOutdatedTimeSpan = opts.timeBucketOutdated || BUCKET_OUTDATED_TIMESPAN;
         this.listening = false;
         this.destroyed = false;
         this.nodeId = this._rpc.id;
         this.nodes = this._rpc.nodes;
         const onping = low(ping);
         this._rpc.on("ping", (older, swap) => {
           onping({ older, swap });
         });
         process.nextTick(bootstrap);
         this._debug("new DHT %s", this.nodeId);
         const self = this;
         function ping(opts2, cb) {
           const older = opts2.older;
           const swap = opts2.swap;
           self._debug("received ping", older);
           self._checkNodes(older, false, (_, deadNode) => {
             if (deadNode) {
               self._debug("swaping dead node with newer", deadNode);
               swap(deadNode);
               return cb();
             }
             self._debug("no node added, all other nodes ok");
             cb();
           });
         }
         function onlistening() {
           self.listening = true;
           self._debug("listening %d", self.address().port);
           self.updateBucketTimestamp();
           self._setBucketCheckInterval();
           self.emit("listening");
         }
         function onquery(query, peer) {
           self._onquery(query, peer);
         }
         function rotateSecrets() {
           self._rotateSecrets();
         }
         function bootstrap() {
           if (!self.destroyed)
             self._bootstrap(opts.bootstrap !== false);
         }
         function onwarning(err) {
           self.emit("warning", err);
         }
         function onerror(err) {
           self.emit("error", err);
         }
         function onnode(node) {
           self.emit("node", node);
         }
       }
       _setBucketCheckInterval() {
         const self = this;
         const interval = 1 * 60 * 1e3;
         this._runningBucketCheck = true;
         queueNext();
         function checkBucket() {
           const diff = Date.now() - self._rpc.nodes.metadata.lastChange;
           if (diff < self._bucketOutdatedTimeSpan)
             return queueNext();
           self._pingAll(() => {
             if (self.destroyed)
               return;
             if (self.nodes.toArray().length < 1) {
               self._bootstrap(true);
             }
             queueNext();
           });
         }
         function queueNext() {
           if (!self._runningBucketCheck || self.destroyed)
             return;
           const nextTimeout = Math.floor(Math.random() * interval + interval / 2);
           self._bucketCheckTimeout = setTimeout(checkBucket, nextTimeout);
         }
       }
       _pingAll(cb) {
         this._checkAndRemoveNodes(this.nodes.toArray(), cb);
       }
       removeBucketCheckInterval() {
         this._runningBucketCheck = false;
         clearTimeout(this._bucketCheckTimeout);
       }
       updateBucketTimestamp() {
         this._rpc.nodes.metadata.lastChange = Date.now();
       }
       _checkAndRemoveNodes(nodes, cb) {
         const self = this;
         this._checkNodes(nodes, true, (_, node) => {
           if (node)
             self.removeNode(node.id);
           cb(null, node);
         });
       }
       _checkNodes(nodes, force, cb) {
         const self = this;
         test(nodes);
         function test(acc) {
           let current = null;
           while (acc.length) {
             current = acc.pop();
             if (!current.id || force)
               break;
             if (Date.now() - (current.seen || 0) > 1e4)
               break;
             current = null;
           }
           if (!current)
             return cb(null);
           self._sendPing(current, (err) => {
             if (!err) {
               self.updateBucketTimestamp();
               return test(acc);
             }
             cb(null, current);
           });
         }
       }
       addNode(node) {
         const self = this;
         if (node.id) {
           node.id = toBuffer(node.id);
           const old = !!this._rpc.nodes.get(node.id);
           this._rpc.nodes.add(node);
           if (!old) {
             this.emit("node", node);
             this.updateBucketTimestamp();
           }
           return;
         }
         this._sendPing(node, (_, node2) => {
           if (node2)
             self.addNode(node2);
         });
       }
       removeNode(id) {
         this._rpc.nodes.remove(toBuffer(id));
       }
       _sendPing(node, cb) {
         const self = this;
         const expectedId = node.id;
         this._rpc.query(node, { q: "ping" }, (err, pong, node2) => {
           if (err)
             return cb(err);
           if (!pong.r || !pong.r.id || !Buffer.isBuffer(pong.r.id) || pong.r.id.length !== self._hashLength) {
             return cb(new Error("Bad reply"));
           }
           if (Buffer.isBuffer(expectedId) && !expectedId.equals(pong.r.id)) {
             return cb(new Error("Unexpected node id"));
           }
           self.updateBucketTimestamp();
           cb(null, {
             id: pong.r.id,
             host: node2.host || node2.address,
             port: node2.port
           });
         });
       }
       toJSON() {
         const self = this;
         const values = {};
         Object.keys(this._values.cache).forEach((key) => {
           const value = self._values.cache[key].value;
           values[key] = {
             v: value.v.toString("hex"),
             id: value.id.toString("hex")
           };
           if (value.seq != null)
             values[key].seq = value.seq;
           if (value.sig != null)
             values[key].sig = value.sig.toString("hex");
           if (value.k != null)
             values[key].k = value.k.toString("hex");
         });
         return {
           nodes: this._rpc.nodes.toArray().map(toNode),
           values
         };
       }
       put(opts, cb) {
         if (Buffer.isBuffer(opts) || typeof opts === "string")
           opts = { v: opts };
         const isMutable = !!opts.k;
         if (opts.v === void 0) {
           throw new Error("opts.v not given");
         }
         if (opts.v.length >= 1e3) {
           throw new Error("v must be less than 1000 bytes in put()");
         }
         if (isMutable && opts.cas !== void 0 && typeof opts.cas !== "number") {
           throw new Error("opts.cas must be an integer if provided");
         }
         if (isMutable && opts.k.length !== 32) {
           throw new Error("opts.k ed25519 public key must be 32 bytes");
         }
         if (isMutable && typeof opts.sign !== "function" && !Buffer.isBuffer(opts.sig)) {
           throw new Error("opts.sign function or options.sig signature is required for mutable put");
         }
         if (isMutable && opts.salt && opts.salt.length > 64) {
           throw new Error("opts.salt is > 64 bytes long");
         }
         if (isMutable && opts.seq === void 0) {
           throw new Error("opts.seq not provided for a mutable update");
         }
         if (isMutable && typeof opts.seq !== "number") {
           throw new Error("opts.seq not an integer");
         }
         return this._put(opts, cb);
       }
       _put(opts, cb) {
         if (!cb)
           cb = noop2;
         const isMutable = !!opts.k;
         const v = typeof opts.v === "string" ? Buffer.from(opts.v) : opts.v;
         const key = isMutable ? this._hash(opts.salt ? Buffer.concat([opts.k, opts.salt]) : opts.k) : this._hash(bencode.encode(v));
         const table = this._tables.get(key.toString("hex"));
         if (!table)
           return this._preput(key, opts, cb);
         const message = {
           q: "put",
           a: {
             id: this._rpc.id,
             token: null,
             v
           }
         };
         if (isMutable) {
           if (typeof opts.cas === "number")
             message.a.cas = opts.cas;
           if (opts.salt)
             message.a.salt = opts.salt;
           message.a.k = opts.k;
           message.a.seq = opts.seq;
           if (typeof opts.sign === "function")
             message.a.sig = opts.sign(encodeSigData(message.a));
           else if (Buffer.isBuffer(opts.sig))
             message.a.sig = opts.sig;
         } else {
           this._values.set(key.toString("hex"), message.a);
         }
         this._rpc.queryAll(table.closest(key), message, null, (err, n) => {
           if (err)
             return cb(err, key, n);
           cb(null, key, n);
         });
         return key;
       }
       _preput(key, opts, cb) {
         const self = this;
         this._closest(key, {
           q: "get",
           a: {
             id: this._rpc.id,
             target: key
           }
         }, null, (err, n) => {
           if (err)
             return cb(err);
           self.put(opts, cb);
         });
         return key;
       }
       get(key, opts, cb) {
         key = toBuffer(key);
         if (typeof opts === "function") {
           cb = opts;
           opts = null;
         }
         if (!opts)
           opts = {};
         const verify = opts.verify || this._verify;
         const hash = this._hash;
         let value = this._values.get(key.toString("hex")) || null;
         if (value && opts.cache !== false) {
           value = createGetResponse(this._rpc.id, null, value);
           return process.nextTick(done);
         }
         this._closest(key, {
           q: "get",
           a: {
             id: this._rpc.id,
             target: key
           }
         }, onreply, done);
         function done(err) {
           if (err)
             return cb(err);
           cb(null, value);
         }
         function onreply(message) {
           const r = message.r;
           if (!r || !r.v)
             return true;
           const isMutable = r.k || r.sig;
           if (opts.salt)
             r.salt = Buffer.from(opts.salt);
           if (isMutable) {
             if (!verify || !r.sig || !r.k)
               return true;
             if (!verify(r.sig, encodeSigData(r), r.k))
               return true;
             if (hash(r.salt ? Buffer.concat([r.k, r.salt]) : r.k).equals(key)) {
               if (!value || r.seq > value.seq)
                 value = r;
             }
           } else {
             if (hash(bencode.encode(r.v)).equals(key)) {
               value = r;
               return false;
             }
           }
           return true;
         }
       }
       announce(infoHash, port, cb) {
         if (typeof port === "function")
           return this.announce(infoHash, 0, port);
         infoHash = toBuffer(infoHash);
         if (!cb)
           cb = noop2;
         const table = this._tables.get(infoHash.toString("hex"));
         if (!table)
           return this._preannounce(infoHash, port, cb);
         if (this._host) {
           const dhtPort = this.listening ? this.address().port : 0;
           this._addPeer(
             { host: this._host, port: port || dhtPort },
             infoHash,
             { host: this._host, port: dhtPort }
           );
         }
         const message = {
           q: "announce_peer",
           a: {
             id: this._rpc.id,
             token: null,
             info_hash: infoHash,
             port,
             implied_port: port ? 0 : 1
           }
         };
         this._debug("announce %s %d", infoHash, port);
         this._rpc.queryAll(table.closest(infoHash), message, null, cb);
       }
       _preannounce(infoHash, port, cb) {
         const self = this;
         this.lookup(infoHash, (err) => {
           if (self.destroyed)
             return cb(new Error("dht is destroyed"));
           if (err)
             return cb(err);
           self.announce(infoHash, port, cb);
         });
       }
       lookup(infoHash, cb) {
         infoHash = toBuffer(infoHash);
         if (!cb)
           cb = noop2;
         const self = this;
         let aborted = false;
         this._debug("lookup %s", infoHash);
         process.nextTick(emit);
         this._closest(infoHash, {
           q: "get_peers",
           a: {
             id: this._rpc.id,
             info_hash: infoHash
           }
         }, onreply, cb);
         function emit(values, from) {
           if (!values)
             values = self._peers.get(infoHash.toString("hex"), 100);
           const peers = decodePeers(values);
           for (let i = 0; i < peers.length; i++) {
             self.emit("peer", peers[i], infoHash, from || null);
           }
         }
         function onreply(message, node) {
           if (aborted)
             return false;
           if (message.r.values)
             emit(message.r.values, node);
         }
         return function abort() {
           aborted = true;
         };
       }
       address() {
         return this._rpc.address();
       }
       listen(...args) {
         this._rpc.bind(...args);
       }
       destroy(cb) {
         if (this.destroyed) {
           if (cb)
             process.nextTick(cb);
           return;
         }
         this.destroyed = true;
         const self = this;
         clearInterval(this._interval);
         this.removeBucketCheckInterval();
         this._peers.destroy();
         this._debug("destroying");
         this._rpc.destroy(() => {
           self.emit("close");
           if (cb)
             cb();
         });
       }
       _onquery(query, peer) {
         if (query.q === void 0 || query.q === null)
           return;
         const q = query.q.toString();
         this._debug("received %s query from %s:%d", q, peer.address, peer.port);
         if (!query.a)
           return;
         switch (q) {
           case "ping":
             return this._rpc.response(peer, query, { id: this._rpc.id });
           case "find_node":
             return this._onfindnode(query, peer);
           case "get_peers":
             return this._ongetpeers(query, peer);
           case "announce_peer":
             return this._onannouncepeer(query, peer);
           case "get":
             return this._onget(query, peer);
           case "put":
             return this._onput(query, peer);
         }
       }
       _onfindnode(query, peer) {
         const target = query.a.target;
         if (!target)
           return this._rpc.error(peer, query, [203, "`find_node` missing required `a.target` field"]);
         this.emit("find_node", target);
         const nodes = this._rpc.nodes.closest(target);
         this._rpc.response(peer, query, { id: this._rpc.id }, nodes);
       }
       _ongetpeers(query, peer) {
         const host = peer.address || peer.host;
         const infoHash = query.a.info_hash;
         if (!infoHash)
           return this._rpc.error(peer, query, [203, "`get_peers` missing required `a.info_hash` field"]);
         this.emit("get_peers", infoHash);
         const r = { id: this._rpc.id, token: this._generateToken(host) };
         const peers = this._peers.get(infoHash.toString("hex"));
         if (peers.length) {
           r.values = peers;
           this._rpc.response(peer, query, r);
         } else {
           this._rpc.response(peer, query, r, this._rpc.nodes.closest(infoHash));
         }
       }
       _onannouncepeer(query, peer) {
         const host = peer.address || peer.host;
         const port = query.a.implied_port ? peer.port : query.a.port;
         if (!port || typeof port !== "number" || port <= 0 || port > 65535)
           return;
         const infoHash = query.a.info_hash;
         const token = query.a.token;
         if (!infoHash || !token)
           return;
         if (!this._validateToken(host, token)) {
           return this._rpc.error(peer, query, [203, "cannot `announce_peer` with bad token"]);
         }
         this.emit("announce_peer", infoHash, { host, port: peer.port });
         this._addPeer({ host, port }, infoHash, { host, port: peer.port });
         this._rpc.response(peer, query, { id: this._rpc.id });
       }
       _addPeer(peer, infoHash, from) {
         this._peers.add(infoHash.toString("hex"), encodePeer(peer.host, peer.port));
         this.emit("announce", peer, infoHash, from);
       }
       _onget(query, peer) {
         const host = peer.address || peer.host;
         const target = query.a.target;
         if (!target)
           return;
         const token = this._generateToken(host);
         const value = this._values.get(target.toString("hex"));
         this.emit("get", target, value);
         if (!value) {
           const nodes = this._rpc.nodes.closest(target);
           this._rpc.response(peer, query, { id: this._rpc.id, token }, nodes);
         } else {
           this._rpc.response(peer, query, createGetResponse(this._rpc.id, token, value));
         }
       }
       _onput(query, peer) {
         const host = peer.address || peer.host;
         const a = query.a;
         if (!a)
           return;
         const v = query.a.v;
         if (!v)
           return;
         const id = query.a.id;
         if (!id)
           return;
         const token = a.token;
         if (!token)
           return;
         if (!this._validateToken(host, token)) {
           return this._rpc.error(peer, query, [203, "cannot `put` with bad token"]);
         }
         if (v.length > 1e3) {
           return this._rpc.error(peer, query, [205, "data payload too large"]);
         }
         const isMutable = !!(a.k || a.sig);
         if (isMutable && !a.k && !a.sig)
           return;
         const key = isMutable ? this._hash(a.salt ? Buffer.concat([a.k, a.salt]) : a.k) : this._hash(bencode.encode(v));
         const keyHex = key.toString("hex");
         this.emit("put", key, v);
         if (isMutable) {
           if (!this._verify)
             return this._rpc.error(peer, query, [400, "verification not supported"]);
           if (!this._verify(a.sig, encodeSigData(a), a.k))
             return;
           const prev = this._values.get(keyHex);
           if (prev && typeof a.cas === "number" && prev.seq !== a.cas) {
             return this._rpc.error(peer, query, [301, "CAS mismatch, re-read and try again"]);
           }
           if (prev && typeof prev.seq === "number" && !(a.seq > prev.seq)) {
             return this._rpc.error(peer, query, [302, "sequence number less than current"]);
           }
           this._values.set(keyHex, { v, k: a.k, salt: a.salt, sig: a.sig, seq: a.seq, id });
         } else {
           this._values.set(keyHex, { v, id });
         }
         this._rpc.response(peer, query, { id: this._rpc.id });
       }
       _bootstrap(populate) {
         const self = this;
         if (!populate)
           return process.nextTick(ready);
         this._rpc.populate(self._rpc.id, {
           q: "find_node",
           a: {
             id: self._rpc.id,
             target: self._rpc.id
           }
         }, ready);
         function ready() {
           if (self.ready)
             return;
           self._debug("emit ready");
           self.ready = true;
           self.emit("ready");
         }
       }
       _closest(target, message, onmessage, cb) {
         const self = this;
         const table = new KBucket({
           localNodeId: target,
           numberOfNodesPerKBucket: this._rpc.k
         });
         this._rpc.closest(target, message, onreply, done);
         function done(err, n) {
           if (err)
             return cb(err);
           self._tables.set(target.toString("hex"), table);
           self._debug("visited %d nodes", n);
           cb(null, n);
         }
         function onreply(message2, node) {
           if (!message2.r)
             return true;
           if (message2.r.token && message2.r.id && Buffer.isBuffer(message2.r.id) && message2.r.id.length === self._hashLength) {
             self._debug("found node %s (target: %s)", message2.r.id, target);
             table.add({
               id: message2.r.id,
               host: node.host || node.address,
               port: node.port,
               token: message2.r.token
             });
           }
           if (!onmessage)
             return true;
           return onmessage(message2, node);
         }
       }
       _debug() {
         if (!debug.enabled)
           return;
         const args = [].slice.call(arguments);
         args[0] = `[${this.nodeId.toString("hex").substring(0, 7)}] ${args[0]}`;
         for (let i = 1; i < args.length; i++) {
           if (Buffer.isBuffer(args[i]))
             args[i] = args[i].toString("hex");
         }
         debug(...args);
       }
       _validateToken(host, token) {
         const tokenA = this._generateToken(host, this._secrets[0]);
         const tokenB = this._generateToken(host, this._secrets[1]);
         return token.equals(tokenA) || token.equals(tokenB);
       }
       _generateToken(host, secret) {
         if (!secret)
           secret = this._secrets[0];
         return this._hash(Buffer.concat([Buffer.from(host), secret]));
       }
       _rotateSecrets() {
         if (!this._secrets) {
           this._secrets = [randombytes2(this._hashLength), randombytes2(this._hashLength)];
         } else {
           this._secrets[1] = this._secrets[0];
           this._secrets[0] = randombytes2(this._hashLength);
         }
       }
     };
     function noop2() {
     }
     function sha1(buf) {
       return Buffer.from(simpleSha1.sync(buf), "hex");
     }
     function createGetResponse(id, token, value) {
       const r = { id, token, v: value.v };
       if (value.sig) {
         r.sig = value.sig;
         r.k = value.k;
         if (typeof value.seq === "number")
           r.seq = value.seq;
       }
       return r;
     }
     function encodePeer(host, port) {
       const buf = Buffer.allocUnsafe(6);
       const ip = host.split(".");
       for (let i = 0; i < 4; i++)
         buf[i] = parseInt(ip[i] || 0, 10);
       buf.writeUInt16BE(port, 4);
       return buf;
     }
     function decodePeers(buf) {
       const peers = [];
       try {
         for (let i = 0; i < buf.length; i++) {
           const port = buf[i].readUInt16BE(4);
           if (!port)
             continue;
           peers.push({
             host: parseIp(buf[i], 0),
             port
           });
         }
       } catch (err) {
       }
       return peers;
     }
     function parseIp(buf, offset) {
       return `${buf[offset++]}.${buf[offset++]}.${buf[offset++]}.${buf[offset++]}`;
     }
     function encodeSigData(msg) {
       const ref = { seq: msg.seq || 0, v: msg.v };
       if (msg.salt)
         ref.salt = msg.salt;
       return bencode.encode(ref).slice(1, -1);
     }
     function toNode(node) {
       return {
         host: node.host,
         port: node.port
       };
     }
     function toBuffer(str) {
       if (Buffer.isBuffer(str))
         return str;
       if (ArrayBuffer.isView(str))
         return Buffer.from(str.buffer, str.byteOffset, str.byteLength);
       if (typeof str === "string")
         return Buffer.from(str, "hex");
       throw new Error("Pass a buffer or a string");
     }
     module2.exports = DHT;
   }
 });
 
 // node_modules/mimic-response/index.js
 var require_mimic_response = __commonJS({
   "node_modules/mimic-response/index.js"(exports, module2) {
     "use strict";
     var knownProperties = [
       "aborted",
       "complete",
       "headers",
       "httpVersion",
       "httpVersionMinor",
       "httpVersionMajor",
       "method",
       "rawHeaders",
       "rawTrailers",
       "setTimeout",
       "socket",
       "statusCode",
       "statusMessage",
       "trailers",
       "url"
     ];
     module2.exports = (fromStream, toStream) => {
       if (toStream._readableState.autoDestroy) {
         throw new Error("The second stream must have the `autoDestroy` option set to `false`");
       }
       const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
       const properties = {};
       for (const property of fromProperties) {
         if (property in toStream) {
           continue;
         }
         properties[property] = {
           get() {
             const value = fromStream[property];
             const isFunction = typeof value === "function";
             return isFunction ? value.bind(fromStream) : value;
           },
           set(value) {
             fromStream[property] = value;
           },
           enumerable: true,
           configurable: false
         };
       }
       Object.defineProperties(toStream, properties);
       fromStream.once("aborted", () => {
         toStream.destroy();
         toStream.emit("aborted");
       });
       fromStream.once("close", () => {
         if (fromStream.complete) {
           if (toStream.readable) {
             toStream.once("end", () => {
               toStream.emit("close");
             });
           } else {
             toStream.emit("close");
           }
         } else {
           toStream.emit("close");
         }
       });
       return toStream;
     };
   }
 });
 
 // node_modules/decompress-response/index.js
 var require_decompress_response = __commonJS({
   "node_modules/decompress-response/index.js"(exports, module2) {
     "use strict";
     var { Transform, PassThrough } = require("stream");
     var zlib = require("zlib");
     var mimicResponse = require_mimic_response();
     module2.exports = (response) => {
       const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
       if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
         return response;
       }
       const isBrotli = contentEncoding === "br";
       if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
         response.destroy(new Error("Brotli is not supported on Node.js < 12"));
         return response;
       }
       let isEmpty = true;
       const checker = new Transform({
         transform(data, _encoding, callback) {
           isEmpty = false;
           callback(null, data);
         },
         flush(callback) {
           callback();
         }
       });
       const finalStream = new PassThrough({
         autoDestroy: false,
         destroy(error, callback) {
           response.destroy();
           callback(error);
         }
       });
       const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
       decompressStream.once("error", (error) => {
         if (isEmpty && !response.readable) {
           finalStream.end();
           return;
         }
         finalStream.destroy(error);
       });
       mimicResponse(response, finalStream);
       response.pipe(checker).pipe(decompressStream).pipe(finalStream);
       return finalStream;
     };
   }
 });
 
 // node_modules/simple-get/index.js
 var require_simple_get = __commonJS({
   "node_modules/simple-get/index.js"(exports, module2) {
     module2.exports = simpleGet;
     var concat = require_simple_concat();
     var decompressResponse = require_decompress_response();
     var http = require("http");
     var https = require("https");
     var once = require_once();
     var querystring = require("querystring");
     var url = require("url");
     var isStream = (o) => o !== null && typeof o === "object" && typeof o.pipe === "function";
     function simpleGet(opts, cb) {
       opts = Object.assign({ maxRedirects: 10 }, typeof opts === "string" ? { url: opts } : opts);
       cb = once(cb);
       if (opts.url) {
         const { hostname, port, protocol: protocol2, auth, path: path2 } = url.parse(opts.url);
         delete opts.url;
         if (!hostname && !port && !protocol2 && !auth)
           opts.path = path2;
         else
           Object.assign(opts, { hostname, port, protocol: protocol2, auth, path: path2 });
       }
       const headers = { "accept-encoding": "gzip, deflate" };
       if (opts.headers)
         Object.keys(opts.headers).forEach((k) => headers[k.toLowerCase()] = opts.headers[k]);
       opts.headers = headers;
       let body;
       if (opts.body) {
         body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body;
       } else if (opts.form) {
         body = typeof opts.form === "string" ? opts.form : querystring.stringify(opts.form);
         opts.headers["content-type"] = "application/x-www-form-urlencoded";
       }
       if (body) {
         if (!opts.method)
           opts.method = "POST";
         if (!isStream(body))
           opts.headers["content-length"] = Buffer.byteLength(body);
         if (opts.json && !opts.form)
           opts.headers["content-type"] = "application/json";
       }
       delete opts.body;
       delete opts.form;
       if (opts.json)
         opts.headers.accept = "application/json";
       if (opts.method)
         opts.method = opts.method.toUpperCase();
       const originalHost = opts.hostname;
       const protocol = opts.protocol === "https:" ? https : http;
       const req = protocol.request(opts, (res) => {
         if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
           opts.url = res.headers.location;
           delete opts.headers.host;
           res.resume();
           const redirectHost = url.parse(opts.url).hostname;
           if (redirectHost !== null && redirectHost !== originalHost) {
             delete opts.headers.cookie;
             delete opts.headers.authorization;
           }
           if (opts.method === "POST" && [301, 302].includes(res.statusCode)) {
             opts.method = "GET";
             delete opts.headers["content-length"];
             delete opts.headers["content-type"];
           }
           if (opts.maxRedirects-- === 0)
             return cb(new Error("too many redirects"));
           else
             return simpleGet(opts, cb);
         }
         const tryUnzip = typeof decompressResponse === "function" && opts.method !== "HEAD";
         cb(null, tryUnzip ? decompressResponse(res) : res);
       });
       req.on("timeout", () => {
         req.abort();
         cb(new Error("Request timed out"));
       });
       req.on("error", cb);
       if (isStream(body))
         body.on("error", cb).pipe(req);
       else
         req.end(body);
       return req;
     }
     simpleGet.concat = (opts, cb) => {
       return simpleGet(opts, (err, res) => {
         if (err)
           return cb(err);
         concat(res, (err2, data) => {
           if (err2)
             return cb(err2);
           if (opts.json) {
             try {
               data = JSON.parse(data.toString());
             } catch (err3) {
               return cb(err3, res, data);
             }
           }
           cb(null, res, data);
         });
       });
     };
     ["get", "post", "put", "patch", "head", "delete"].forEach((method) => {
       simpleGet[method] = (opts, cb) => {
         if (typeof opts === "string")
           opts = { url: opts };
         return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb);
       };
     });
   }
 });
 
 // node_modules/ip/lib/ip.js
 var require_ip = __commonJS({
   "node_modules/ip/lib/ip.js"(exports) {
     var ip = exports;
     var { Buffer: Buffer2 } = require("buffer");
     var os2 = require("os");
     ip.toBuffer = function(ip2, buff, offset) {
       offset = ~~offset;
       var result;
       if (this.isV4Format(ip2)) {
         result = buff || new Buffer2(offset + 4);
         ip2.split(/\./g).map((byte) => {
           result[offset++] = parseInt(byte, 10) & 255;
         });
       } else if (this.isV6Format(ip2)) {
         var sections = ip2.split(":", 8);
         var i;
         for (i = 0; i < sections.length; i++) {
           var isv4 = this.isV4Format(sections[i]);
           var v4Buffer;
           if (isv4) {
             v4Buffer = this.toBuffer(sections[i]);
             sections[i] = v4Buffer.slice(0, 2).toString("hex");
           }
           if (v4Buffer && ++i < 8) {
             sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
           }
         }
         if (sections[0] === "") {
           while (sections.length < 8)
             sections.unshift("0");
         } else if (sections[sections.length - 1] === "") {
           while (sections.length < 8)
             sections.push("0");
         } else if (sections.length < 8) {
           for (i = 0; i < sections.length && sections[i] !== ""; i++)
             ;
           var argv = [i, 1];
           for (i = 9 - sections.length; i > 0; i--) {
             argv.push("0");
           }
           sections.splice.apply(sections, argv);
         }
         result = buff || new Buffer2(offset + 16);
         for (i = 0; i < sections.length; i++) {
           var word = parseInt(sections[i], 16);
           result[offset++] = word >> 8 & 255;
           result[offset++] = word & 255;
         }
       }
       if (!result) {
         throw Error(`Invalid ip address: ${ip2}`);
       }
       return result;
     };
     ip.toString = function(buff, offset, length) {
       offset = ~~offset;
       length = length || buff.length - offset;
       var result = [];
       var i;
       if (length === 4) {
         for (i = 0; i < length; i++) {
           result.push(buff[offset + i]);
         }
         result = result.join(".");
       } else if (length === 16) {
         for (i = 0; i < length; i += 2) {
           result.push(buff.readUInt16BE(offset + i).toString(16));
         }
         result = result.join(":");
         result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
         result = result.replace(/:{3,4}/, "::");
       }
       return result;
     };
     var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
     var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
     ip.isV4Format = function(ip2) {
       return ipv4Regex.test(ip2);
     };
     ip.isV6Format = function(ip2) {
       return ipv6Regex.test(ip2);
     };
     function _normalizeFamily(family) {
       if (family === 4) {
         return "ipv4";
       }
       if (family === 6) {
         return "ipv6";
       }
       return family ? family.toLowerCase() : "ipv4";
     }
     ip.fromPrefixLen = function(prefixlen, family) {
       if (prefixlen > 32) {
         family = "ipv6";
       } else {
         family = _normalizeFamily(family);
       }
       var len = 4;
       if (family === "ipv6") {
         len = 16;
       }
       var buff = new Buffer2(len);
       for (var i = 0, n = buff.length; i < n; ++i) {
         var bits = 8;
         if (prefixlen < 8) {
           bits = prefixlen;
         }
         prefixlen -= bits;
         buff[i] = ~(255 >> bits) & 255;
       }
       return ip.toString(buff);
     };
     ip.mask = function(addr, mask) {
       addr = ip.toBuffer(addr);
       mask = ip.toBuffer(mask);
       var result = new Buffer2(Math.max(addr.length, mask.length));
       var i;
       if (addr.length === mask.length) {
         for (i = 0; i < addr.length; i++) {
           result[i] = addr[i] & mask[i];
         }
       } else if (mask.length === 4) {
         for (i = 0; i < mask.length; i++) {
           result[i] = addr[addr.length - 4 + i] & mask[i];
         }
       } else {
         for (i = 0; i < result.length - 6; i++) {
           result[i] = 0;
         }
         result[10] = 255;
         result[11] = 255;
         for (i = 0; i < addr.length; i++) {
           result[i + 12] = addr[i] & mask[i + 12];
         }
         i += 12;
       }
       for (; i < result.length; i++) {
         result[i] = 0;
       }
       return ip.toString(result);
     };
     ip.cidr = function(cidrString) {
       var cidrParts = cidrString.split("/");
       var addr = cidrParts[0];
       if (cidrParts.length !== 2) {
         throw new Error(`invalid CIDR subnet: ${addr}`);
       }
       var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
       return ip.mask(addr, mask);
     };
     ip.subnet = function(addr, mask) {
       var networkAddress = ip.toLong(ip.mask(addr, mask));
       var maskBuffer = ip.toBuffer(mask);
       var maskLength = 0;
       for (var i = 0; i < maskBuffer.length; i++) {
         if (maskBuffer[i] === 255) {
           maskLength += 8;
         } else {
           var octet = maskBuffer[i] & 255;
           while (octet) {
             octet = octet << 1 & 255;
             maskLength++;
           }
         }
       }
       var numberOfAddresses = Math.pow(2, 32 - maskLength);
       return {
         networkAddress: ip.fromLong(networkAddress),
         firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
         lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
         broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
         subnetMask: mask,
         subnetMaskLength: maskLength,
         numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
         length: numberOfAddresses,
         contains(other) {
           return networkAddress === ip.toLong(ip.mask(other, mask));
         }
       };
     };
     ip.cidrSubnet = function(cidrString) {
       var cidrParts = cidrString.split("/");
       var addr = cidrParts[0];
       if (cidrParts.length !== 2) {
         throw new Error(`invalid CIDR subnet: ${addr}`);
       }
       var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
       return ip.subnet(addr, mask);
     };
     ip.not = function(addr) {
       var buff = ip.toBuffer(addr);
       for (var i = 0; i < buff.length; i++) {
         buff[i] = 255 ^ buff[i];
       }
       return ip.toString(buff);
     };
     ip.or = function(a, b) {
       var i;
       a = ip.toBuffer(a);
       b = ip.toBuffer(b);
       if (a.length === b.length) {
         for (i = 0; i < a.length; ++i) {
           a[i] |= b[i];
         }
         return ip.toString(a);
       }
       var buff = a;
       var other = b;
       if (b.length > a.length) {
         buff = b;
         other = a;
       }
       var offset = buff.length - other.length;
       for (i = offset; i < buff.length; ++i) {
         buff[i] |= other[i - offset];
       }
       return ip.toString(buff);
     };
     ip.isEqual = function(a, b) {
       var i;
       a = ip.toBuffer(a);
       b = ip.toBuffer(b);
       if (a.length === b.length) {
         for (i = 0; i < a.length; i++) {
           if (a[i] !== b[i])
             return false;
         }
         return true;
       }
       if (b.length === 4) {
         var t = b;
         b = a;
         a = t;
       }
       for (i = 0; i < 10; i++) {
         if (b[i] !== 0)
           return false;
       }
       var word = b.readUInt16BE(10);
       if (word !== 0 && word !== 65535)
         return false;
       for (i = 0; i < 4; i++) {
         if (a[i] !== b[i + 12])
           return false;
       }
       return true;
     };
     ip.isPrivate = function(addr) {
       return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
     };
     ip.isPublic = function(addr) {
       return !ip.isPrivate(addr);
     };
     ip.isLoopback = function(addr) {
       return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
     };
     ip.loopback = function(family) {
       family = _normalizeFamily(family);
       if (family !== "ipv4" && family !== "ipv6") {
         throw new Error("family must be ipv4 or ipv6");
       }
       return family === "ipv4" ? "127.0.0.1" : "fe80::1";
     };
     ip.address = function(name, family) {
       var interfaces = os2.networkInterfaces();
       family = _normalizeFamily(family);
       if (name && name !== "private" && name !== "public") {
         var res = interfaces[name].filter((details) => {
           var itemFamily = _normalizeFamily(details.family);
           return itemFamily === family;
         });
         if (res.length === 0) {
           return void 0;
         }
         return res[0].address;
       }
       var all = Object.keys(interfaces).map((nic) => {
         var addresses = interfaces[nic].filter((details) => {
           details.family = _normalizeFamily(details.family);
           if (details.family !== family || ip.isLoopback(details.address)) {
             return false;
           }
           if (!name) {
             return true;
           }
           return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
         });
         return addresses.length ? addresses[0].address : void 0;
       }).filter(Boolean);
       return !all.length ? ip.loopback(family) : all[0];
     };
     ip.toLong = function(ip2) {
       var ipl = 0;
       ip2.split(".").forEach((octet) => {
         ipl <<= 8;
         ipl += parseInt(octet);
       });
       return ipl >>> 0;
     };
     ip.fromLong = function(ipl) {
       return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;
     };
   }
 });
 
 // node_modules/ip-set/index.js
 var require_ip_set = __commonJS({
   "node_modules/ip-set/index.js"(exports, module2) {
     var ip = require_ip();
     var IPSetNode = class {
       constructor(start, end) {
         this.start = start;
         this.end = end;
         this.max = end;
         this.depth = 1;
         this.left = null;
         this.right = null;
       }
       add(start, end) {
         const d = start - this.start;
         let update = false;
         if (d === 0 && this.end < end) {
           this.end = end;
           update = true;
         } else if (d < 0) {
           if (this.left) {
             update = this.left.add(start, end);
             if (update)
               this._balance();
           } else {
             this.left = new IPSetNode(start, end);
             update = true;
           }
         } else if (d > 0) {
           if (this.right) {
             update = this.right.add(start, end);
             if (update)
               this._balance();
           } else {
             this.right = new IPSetNode(start, end);
             update = true;
           }
         }
         if (update)
           this._update();
         return update;
       }
       contains(addr) {
         let node = this;
         while (node && !(addr >= node.start && addr <= node.end)) {
           if (node.left && node.left.max >= addr)
             node = node.left;
           else
             node = node.right;
         }
         return !!node;
       }
       _balance() {
         const ldepth = this.left ? this.left.depth : 0;
         const rdepth = this.right ? this.right.depth : 0;
         if (ldepth > rdepth + 1) {
           const lldepth = this.left.left ? this.left.left.depth : 0;
           const lrdepth = this.left.right ? this.left.right.depth : 0;
           if (lldepth < lrdepth)
             this.left._rotateRR();
           this._rotateLL();
         } else if (ldepth + 1 < rdepth) {
           const rrdepth = this.right.right ? this.right.right.depth : 0;
           const rldepth = this.right.left ? this.right.left.depth : 0;
           if (rldepth > rrdepth)
             this.right._rotateLL();
           this._rotateRR();
         }
       }
       _rotateLL() {
         const _start = this.start;
         const _end = this.end;
         const _right = this.right;
         this.start = this.left.start;
         this.end = this.left.end;
         this.right = this.left;
         this.left = this.left.left;
         this.right.left = this.right.right;
         this.right.right = _right;
         this.right.start = _start;
         this.right.end = _end;
         this.right._update();
         this._update();
       }
       _rotateRR() {
         const _start = this.start;
         const _end = this.end;
         const _left = this.left;
         this.start = this.right.start;
         this.end = this.right.end;
         this.end = this.right.end;
         this.left = this.right;
         this.right = this.right.right;
         this.left.right = this.left.left;
         this.left.left = _left;
         this.left.start = _start;
         this.left.end = _end;
         this.left._update();
         this._update();
       }
       _update() {
         this.depth = 1;
         if (this.left)
           this.depth = this.left.depth + 1;
         if (this.right && this.depth <= this.right.depth)
           this.depth = this.right.depth + 1;
         this.max = Math.max(this.end, this.left ? this.left.max : 0, this.right ? this.right.max : 0);
       }
     };
     var IPSet = class {
       constructor(blocklist) {
         this.tree = null;
         if (Array.isArray(blocklist)) {
           blocklist.forEach((block) => {
             this.add(block);
           });
         }
       }
       add(start, end) {
         if (!start)
           return;
         if (typeof start === "object") {
           end = start.end;
           start = start.start;
         }
         const cidrStr = /\/\d{1,2}/;
         if (typeof start === "string" && cidrStr.test(start)) {
           const ipSubnet = ip.cidrSubnet(start);
           start = ipSubnet.networkAddress;
           end = ipSubnet.broadcastAddress;
         }
         if (typeof start !== "number")
           start = ip.toLong(start);
         if (!end)
           end = start;
         if (typeof end !== "number")
           end = ip.toLong(end);
         if (start < 0 || end > 4294967295 || end < start)
           throw new Error("Invalid block range");
         if (this.tree)
           this.tree.add(start, end);
         else
           this.tree = new IPSetNode(start, end);
       }
       contains(addr) {
         if (!this.tree)
           return false;
         if (typeof addr !== "number")
           addr = ip.toLong(addr);
         return this.tree.contains(addr);
       }
     };
     module2.exports = IPSet;
   }
 });
 
 // node_modules/netmask/lib/netmask.js
 var require_netmask = __commonJS({
   "node_modules/netmask/lib/netmask.js"(exports) {
     (function() {
       var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
       long2ip = function(long) {
         var a, b, c, d;
         a = (long & 255 << 24) >>> 24;
         b = (long & 255 << 16) >>> 16;
         c = (long & 255 << 8) >>> 8;
         d = long & 255;
         return [a, b, c, d].join(".");
       };
       ip2long = function(ip) {
         var b, c, i, j, n, ref;
         b = [];
         for (i = j = 0; j <= 3; i = ++j) {
           if (ip.length === 0) {
             break;
           }
           if (i > 0) {
             if (ip[0] !== ".") {
               throw new Error("Invalid IP");
             }
             ip = ip.substring(1);
           }
           ref = atob(ip), n = ref[0], c = ref[1];
           ip = ip.substring(c);
           b.push(n);
         }
         if (ip.length !== 0) {
           throw new Error("Invalid IP");
         }
         switch (b.length) {
           case 1:
             if (b[0] > 4294967295) {
               throw new Error("Invalid IP");
             }
             return b[0] >>> 0;
           case 2:
             if (b[0] > 255 || b[1] > 16777215) {
               throw new Error("Invalid IP");
             }
             return (b[0] << 24 | b[1]) >>> 0;
           case 3:
             if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
               throw new Error("Invalid IP");
             }
             return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
           case 4:
             if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
               throw new Error("Invalid IP");
             }
             return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
           default:
             throw new Error("Invalid IP");
         }
       };
       chr = function(b) {
         return b.charCodeAt(0);
       };
       chr0 = chr("0");
       chra = chr("a");
       chrA = chr("A");
       atob = function(s) {
         var base, dmax, i, n, start;
         n = 0;
         base = 10;
         dmax = "9";
         i = 0;
         if (s.length > 1 && s[i] === "0") {
           if (s[i + 1] === "x" || s[i + 1] === "X") {
             i += 2;
             base = 16;
           } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
             i++;
             base = 8;
             dmax = "7";
           }
         }
         start = i;
         while (i < s.length) {
           if ("0" <= s[i] && s[i] <= dmax) {
             n = n * base + (chr(s[i]) - chr0) >>> 0;
           } else if (base === 16) {
             if ("a" <= s[i] && s[i] <= "f") {
               n = n * base + (10 + chr(s[i]) - chra) >>> 0;
             } else if ("A" <= s[i] && s[i] <= "F") {
               n = n * base + (10 + chr(s[i]) - chrA) >>> 0;
             } else {
               break;
             }
           } else {
             break;
           }
           if (n > 4294967295) {
             throw new Error("too large");
           }
           i++;
         }
         if (i === start) {
           throw new Error("empty octet");
         }
         return [n, i];
       };
       Netmask = function() {
         function Netmask2(net, mask) {
           var error, i, j, ref;
           if (typeof net !== "string") {
             throw new Error("Missing `net' parameter");
           }
           if (!mask) {
             ref = net.split("/", 2), net = ref[0], mask = ref[1];
           }
           if (!mask) {
             mask = 32;
           }
           if (typeof mask === "string" && mask.indexOf(".") > -1) {
             try {
               this.maskLong = ip2long(mask);
             } catch (error1) {
               error = error1;
               throw new Error("Invalid mask: " + mask);
             }
             for (i = j = 32; j >= 0; i = --j) {
               if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                 this.bitmask = i;
                 break;
               }
             }
           } else if (mask || mask === 0) {
             this.bitmask = parseInt(mask, 10);
             this.maskLong = 0;
             if (this.bitmask > 0) {
               this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
             }
           } else {
             throw new Error("Invalid mask: empty");
           }
           try {
             this.netLong = (ip2long(net) & this.maskLong) >>> 0;
           } catch (error1) {
             error = error1;
             throw new Error("Invalid net address: " + net);
           }
           if (!(this.bitmask <= 32)) {
             throw new Error("Invalid mask for ip4: " + mask);
           }
           this.size = Math.pow(2, 32 - this.bitmask);
           this.base = long2ip(this.netLong);
           this.mask = long2ip(this.maskLong);
           this.hostmask = long2ip(~this.maskLong);
           this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
           this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
           this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
         }
         Netmask2.prototype.contains = function(ip) {
           if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
             ip = new Netmask2(ip);
           }
           if (ip instanceof Netmask2) {
             return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
           } else {
             return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
           }
         };
         Netmask2.prototype.next = function(count) {
           if (count == null) {
             count = 1;
           }
           return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
         };
         Netmask2.prototype.forEach = function(fn) {
           var index, lastLong, long;
           long = ip2long(this.first);
           lastLong = ip2long(this.last);
           index = 0;
           while (long <= lastLong) {
             fn(long2ip(long), long, index);
             index++;
             long++;
           }
         };
         Netmask2.prototype.toString = function() {
           return this.base + "/" + this.bitmask;
         };
         return Netmask2;
       }();
       exports.ip2long = ip2long;
       exports.long2ip = long2ip;
       exports.Netmask = Netmask;
     }).call(exports);
   }
 });
 
 // node_modules/through/index.js
 var require_through = __commonJS({
   "node_modules/through/index.js"(exports, module2) {
     var Stream = require("stream");
     exports = module2.exports = through;
     through.through = through;
     function through(write, end, opts) {
       write = write || function(data) {
         this.queue(data);
       };
       end = end || function() {
         this.queue(null);
       };
       var ended = false, destroyed = false, buffer = [], _ended = false;
       var stream = new Stream();
       stream.readable = stream.writable = true;
       stream.paused = false;
       stream.autoDestroy = !(opts && opts.autoDestroy === false);
       stream.write = function(data) {
         write.call(this, data);
         return !stream.paused;
       };
       function drain() {
         while (buffer.length && !stream.paused) {
           var data = buffer.shift();
           if (null === data)
             return stream.emit("end");
           else
             stream.emit("data", data);
         }
       }
       stream.queue = stream.push = function(data) {
         if (_ended)
           return stream;
         if (data === null)
           _ended = true;
         buffer.push(data);
         drain();
         return stream;
       };
       stream.on("end", function() {
         stream.readable = false;
         if (!stream.writable && stream.autoDestroy)
           process.nextTick(function() {
             stream.destroy();
           });
       });
       function _end() {
         stream.writable = false;
         end.call(stream);
         if (!stream.readable && stream.autoDestroy)
           stream.destroy();
       }
       stream.end = function(data) {
         if (ended)
           return;
         ended = true;
         if (arguments.length)
           stream.write(data);
         _end();
         return stream;
       };
       stream.destroy = function() {
         if (destroyed)
           return;
         destroyed = true;
         ended = true;
         buffer.length = 0;
         stream.writable = stream.readable = false;
         stream.emit("close");
         return stream;
       };
       stream.pause = function() {
         if (stream.paused)
           return;
         stream.paused = true;
         return stream;
       };
       stream.resume = function() {
         if (stream.paused) {
           stream.paused = false;
           stream.emit("resume");
         }
         drain();
         if (!stream.paused)
           stream.emit("drain");
         return stream;
       };
       return stream;
     }
   }
 });
 
 // node_modules/split/index.js
 var require_split = __commonJS({
   "node_modules/split/index.js"(exports, module2) {
     var through = require_through();
     var Decoder = require("string_decoder").StringDecoder;
     module2.exports = split;
     function split(matcher, mapper, options) {
       var decoder = new Decoder();
       var soFar = "";
       var maxLength = options && options.maxLength;
       var trailing = options && options.trailing === false ? false : true;
       if ("function" === typeof matcher)
         mapper = matcher, matcher = null;
       if (!matcher)
         matcher = /\r?\n/;
       function emit(stream, piece) {
         if (mapper) {
           try {
             piece = mapper(piece);
           } catch (err) {
             return stream.emit("error", err);
           }
           if ("undefined" !== typeof piece)
             stream.queue(piece);
         } else
           stream.queue(piece);
       }
       function next(stream, buffer) {
         var pieces = ((soFar != null ? soFar : "") + buffer).split(matcher);
         soFar = pieces.pop();
         if (maxLength && soFar.length > maxLength)
           return stream.emit("error", new Error("maximum buffer reached"));
         for (var i = 0; i < pieces.length; i++) {
           var piece = pieces[i];
           emit(stream, piece);
         }
       }
       return through(
         function(b) {
           next(this, decoder.write(b));
         },
         function() {
           if (decoder.end)
             next(this, decoder.end());
           if (trailing && soFar != null)
             emit(this, soFar);
           this.queue(null);
         }
       );
     }
   }
 });
 
 // node_modules/load-ip-set/index.js
 var require_load_ip_set = __commonJS({
   "node_modules/load-ip-set/index.js"(exports, module2) {
     var fs2 = require("fs");
     var get = require_simple_get();
     var IPSet = require_ip_set();
     var Netmask = require_netmask().Netmask;
     var once = require_once();
     var split = require_split();
     var zlib = require("zlib");
     var ipSetRegex = /^\s*(?:[^#].*?\s*:\s*)?([a-f0-9.:]+)(?:\s*-\s*([a-f0-9.:]+))?\s*$/;
     var cidrRegex = /^\s*(?:[^#].*?\s*:\s*)?([0-9.:]+)\/([0-9]{1,2})\s*$/;
     function loadIPSet(input, opts, cb) {
       if (typeof opts === "function")
         return loadIPSet(input, {}, opts);
       cb = once(cb);
       if (Array.isArray(input) || !input) {
         process.nextTick(() => {
           cb(null, new IPSet(input));
         });
       } else if (/^https?:\/\//.test(input)) {
         opts.url = input;
         get(opts, (err, res) => {
           if (err)
             return cb(err);
           onStream(res);
         });
       } else {
         let f = fs2.createReadStream(input).on("error", cb);
         if (/.gz$/.test(input))
           f = f.pipe(zlib.Gunzip());
         onStream(f);
       }
       function onStream(stream) {
         const blocklist = [];
         stream.on("error", cb).pipe(split()).on("data", (line) => {
           let match = ipSetRegex.exec(line);
           if (match) {
             blocklist.push({ start: match[1], end: match[2] });
           } else {
             match = cidrRegex.exec(line);
             if (match) {
               const range = new Netmask(`${match[1]}/${match[2]}`);
               blocklist.push({ start: range.first, end: range.broadcast || range.last });
             }
           }
         }).on("end", () => {
           cb(null, new IPSet(blocklist));
         });
       }
     }
     module2.exports = loadIPSet;
   }
 });
 
 // node_modules/blob-to-buffer/index.js
 var require_blob_to_buffer = __commonJS({
   "node_modules/blob-to-buffer/index.js"(exports, module2) {
     module2.exports = function blobToBuffer(blob, cb) {
       if (typeof Blob === "undefined" || !(blob instanceof Blob)) {
         throw new Error("first argument must be a Blob");
       }
       if (typeof cb !== "function") {
         throw new Error("second argument must be a function");
       }
       const reader = new FileReader();
       function onLoadEnd(e) {
         reader.removeEventListener("loadend", onLoadEnd, false);
         if (e.error)
           cb(e.error);
         else
           cb(null, Buffer.from(reader.result));
       }
       reader.addEventListener("loadend", onLoadEnd, false);
       reader.readAsArrayBuffer(blob);
     };
   }
 });
 
 // node_modules/thirty-two/lib/thirty-two/thirty-two.js
 var require_thirty_two = __commonJS({
   "node_modules/thirty-two/lib/thirty-two/thirty-two.js"(exports) {
     "use strict";
     var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
     var byteTable = [
       255,
       255,
       26,
       27,
       28,
       29,
       30,
       31,
       255,
       255,
       255,
       255,
       255,
       255,
       255,
       255,
       255,
       0,
       1,
       2,
       3,
       4,
       5,
       6,
       7,
       8,
       9,
       10,
       11,
       12,
       13,
       14,
       15,
       16,
       17,
       18,
       19,
       20,
       21,
       22,
       23,
       24,
       25,
       255,
       255,
       255,
       255,
       255,
       255,
       0,
       1,
       2,
       3,
       4,
       5,
       6,
       7,
       8,
       9,
       10,
       11,
       12,
       13,
       14,
       15,
       16,
       17,
       18,
       19,
       20,
       21,
       22,
       23,
       24,
       25,
       255,
       255,
       255,
       255,
       255
     ];
     function quintetCount(buff) {
       var quintets = Math.floor(buff.length / 5);
       return buff.length % 5 === 0 ? quintets : quintets + 1;
     }
     exports.encode = function(plain) {
       if (!Buffer.isBuffer(plain)) {
         plain = new Buffer(plain);
       }
       var i = 0;
       var j = 0;
       var shiftIndex = 0;
       var digit = 0;
       var encoded = new Buffer(quintetCount(plain) * 8);
       while (i < plain.length) {
         var current = plain[i];
         if (shiftIndex > 3) {
           digit = current & 255 >> shiftIndex;
           shiftIndex = (shiftIndex + 5) % 8;
           digit = digit << shiftIndex | (i + 1 < plain.length ? plain[i + 1] : 0) >> 8 - shiftIndex;
           i++;
         } else {
           digit = current >> 8 - (shiftIndex + 5) & 31;
           shiftIndex = (shiftIndex + 5) % 8;
           if (shiftIndex === 0)
             i++;
         }
         encoded[j] = charTable.charCodeAt(digit);
         j++;
       }
       for (i = j; i < encoded.length; i++) {
         encoded[i] = 61;
       }
       return encoded;
     };
     exports.decode = function(encoded) {
       var shiftIndex = 0;
       var plainDigit = 0;
       var plainChar;
       var plainPos = 0;
       if (!Buffer.isBuffer(encoded)) {
         encoded = new Buffer(encoded);
       }
       var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
       for (var i = 0; i < encoded.length; i++) {
         if (encoded[i] === 61) {
           break;
         }
         var encodedByte = encoded[i] - 48;
         if (encodedByte < byteTable.length) {
           plainDigit = byteTable[encodedByte];
           if (shiftIndex <= 3) {
             shiftIndex = (shiftIndex + 5) % 8;
             if (shiftIndex === 0) {
               plainChar |= plainDigit;
               decoded[plainPos] = plainChar;
               plainPos++;
               plainChar = 0;
             } else {
               plainChar |= 255 & plainDigit << 8 - shiftIndex;
             }
           } else {
             shiftIndex = (shiftIndex + 5) % 8;
             plainChar |= 255 & plainDigit >>> shiftIndex;
             decoded[plainPos] = plainChar;
             plainPos++;
             plainChar = 255 & plainDigit << 8 - shiftIndex;
           }
         } else {
           throw new Error("Invalid input - it is not base32 encoded string");
         }
       }
       return decoded.slice(0, plainPos);
     };
   }
 });
 
 // node_modules/thirty-two/lib/thirty-two/index.js
 var require_thirty_two2 = __commonJS({
   "node_modules/thirty-two/lib/thirty-two/index.js"(exports) {
     var base32 = require_thirty_two();
     exports.encode = base32.encode;
     exports.decode = base32.decode;
   }
 });
 
 // node_modules/bep53-range/index.js
 var require_bep53_range = __commonJS({
   "node_modules/bep53-range/index.js"(exports, module2) {
     module2.exports = parseRange;
     module2.exports.parse = parseRange;
     module2.exports.compose = composeRange;
     function composeRange(range) {
       return range.reduce((acc, cur, idx, arr) => {
         if (idx === 0 || cur !== arr[idx - 1] + 1)
           acc.push([]);
         acc[acc.length - 1].push(cur);
         return acc;
       }, []).map((cur) => {
         return cur.length > 1 ? `${cur[0]}-${cur[cur.length - 1]}` : `${cur[0]}`;
       });
     }
     function parseRange(range) {
       const generateRange = (start, end = start) => Array.from({ length: end - start + 1 }, (cur, idx) => idx + start);
       return range.reduce((acc, cur, idx, arr) => {
         const r = cur.split("-").map((cur2) => parseInt(cur2));
         return acc.concat(generateRange(...r));
       }, []);
     }
   }
 });
 
 // node_modules/magnet-uri/index.js
 var require_magnet_uri = __commonJS({
   "node_modules/magnet-uri/index.js"(exports, module2) {
     module2.exports = magnetURIDecode;
     module2.exports.decode = magnetURIDecode;
     module2.exports.encode = magnetURIEncode;
     var base32 = require_thirty_two2();
     var bep53Range = require_bep53_range();
     function magnetURIDecode(uri) {
       const result = {};
       const data = uri.split("magnet:?")[1];
       const params = data && data.length >= 0 ? data.split("&") : [];
       params.forEach((param) => {
         const keyval = param.split("=");
         if (keyval.length !== 2)
           return;
         const key = keyval[0];
         let val = keyval[1];
         if (key === "dn")
           val = decodeURIComponent(val).replace(/\+/g, " ");
         if (key === "tr" || key === "xs" || key === "as" || key === "ws") {
           val = decodeURIComponent(val);
         }
         if (key === "kt")
           val = decodeURIComponent(val).split("+");
         if (key === "ix")
           val = Number(val);
         if (key === "so")
           val = bep53Range.parse(decodeURIComponent(val).split(","));
         if (result[key]) {
           if (!Array.isArray(result[key])) {
             result[key] = [result[key]];
           }
           result[key].push(val);
         } else {
           result[key] = val;
         }
       });
       let m;
       if (result.xt) {
         const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
         xts.forEach((xt) => {
           if (m = xt.match(/^urn:btih:(.{40})/)) {
             result.infoHash = m[1].toLowerCase();
           } else if (m = xt.match(/^urn:btih:(.{32})/)) {
             const decodedStr = base32.decode(m[1]);
             result.infoHash = Buffer.from(decodedStr, "binary").toString("hex");
           } else if (m = xt.match(/^urn:btmh:1220(.{64})/)) {
             result.infoHashV2 = m[1].toLowerCase();
           }
         });
       }
       if (result.xs) {
         const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
         xss.forEach((xs) => {
           if (m = xs.match(/^urn:btpk:(.{64})/)) {
             result.publicKey = m[1].toLowerCase();
           }
         });
       }
       if (result.infoHash)
         result.infoHashBuffer = Buffer.from(result.infoHash, "hex");
       if (result.infoHashV2)
         result.infoHashV2Buffer = Buffer.from(result.infoHashV2, "hex");
       if (result.publicKey)
         result.publicKeyBuffer = Buffer.from(result.publicKey, "hex");
       if (result.dn)
         result.name = result.dn;
       if (result.kt)
         result.keywords = result.kt;
       result.announce = [];
       if (typeof result.tr === "string" || Array.isArray(result.tr)) {
         result.announce = result.announce.concat(result.tr);
       }
       result.urlList = [];
       if (typeof result.as === "string" || Array.isArray(result.as)) {
         result.urlList = result.urlList.concat(result.as);
       }
       if (typeof result.ws === "string" || Array.isArray(result.ws)) {
         result.urlList = result.urlList.concat(result.ws);
       }
       result.peerAddresses = [];
       if (typeof result["x.pe"] === "string" || Array.isArray(result["x.pe"])) {
         result.peerAddresses = result.peerAddresses.concat(result["x.pe"]);
       }
       result.announce = Array.from(new Set(result.announce));
       result.urlList = Array.from(new Set(result.urlList));
       result.peerAddresses = Array.from(new Set(result.peerAddresses));
       return result;
     }
     function magnetURIEncode(obj) {
       obj = Object.assign({}, obj);
       let xts = /* @__PURE__ */ new Set();
       if (obj.xt && typeof obj.xt === "string")
         xts.add(obj.xt);
       if (obj.xt && Array.isArray(obj.xt))
         xts = new Set(obj.xt);
       if (obj.infoHashBuffer)
         xts.add(`urn:btih:${obj.infoHashBuffer.toString("hex")}`);
       if (obj.infoHash)
         xts.add(`urn:btih:${obj.infoHash}`);
       if (obj.infoHashV2Buffer)
         xts.add(obj.xt = `urn:btmh:1220${obj.infoHashV2Buffer.toString("hex")}`);
       if (obj.infoHashV2)
         xts.add(`urn:btmh:1220${obj.infoHashV2}`);
       const xtsDeduped = Array.from(xts);
       if (xtsDeduped.length === 1)
         obj.xt = xtsDeduped[0];
       if (xtsDeduped.length > 1)
         obj.xt = xtsDeduped;
       if (obj.publicKeyBuffer)
         obj.xs = `urn:btpk:${obj.publicKeyBuffer.toString("hex")}`;
       if (obj.publicKey)
         obj.xs = `urn:btpk:${obj.publicKey}`;
       if (obj.name)
         obj.dn = obj.name;
       if (obj.keywords)
         obj.kt = obj.keywords;
       if (obj.announce)
         obj.tr = obj.announce;
       if (obj.urlList) {
         obj.ws = obj.urlList;
         delete obj.as;
       }
       if (obj.peerAddresses)
         obj["x.pe"] = obj.peerAddresses;
       let result = "magnet:?";
       Object.keys(obj).filter((key) => key.length === 2 || key === "x.pe").forEach((key, i) => {
         const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];
         values.forEach((val, j) => {
           if ((i > 0 || j > 0) && (key !== "kt" && key !== "so" || j === 0))
             result += "&";
           if (key === "dn")
             val = encodeURIComponent(val).replace(/%20/g, "+");
           if (key === "tr" || key === "as" || key === "ws") {
             val = encodeURIComponent(val);
           }
           if (key === "xs" && !val.startsWith("urn:btpk:")) {
             val = encodeURIComponent(val);
           }
           if (key === "kt")
             val = encodeURIComponent(val);
           if (key === "so")
             return;
           if (key === "kt" && j > 0)
             result += `+${val}`;
           else
             result += `${key}=${val}`;
         });
         if (key === "so")
           result += `${key}=${bep53Range.compose(values)}`;
       });
       return result;
     }
   }
 });
 
 // node_modules/parse-torrent/index.js
 var require_parse_torrent = __commonJS({
   "node_modules/parse-torrent/index.js"(exports, module2) {
     var bencode = require_lib();
     var blobToBuffer = require_blob_to_buffer();
     var fs2 = require("fs");
     var get = require_simple_get();
     var magnet = require_magnet_uri();
     var path2 = require("path");
     var sha1 = require_simple_sha1();
     var queueMicrotask3 = require_queue_microtask();
     module2.exports = parseTorrent;
     module2.exports.remote = parseTorrentRemote;
     module2.exports.toMagnetURI = magnet.encode;
     module2.exports.toTorrentFile = encodeTorrentFile;
     function parseTorrent(torrentId) {
       if (typeof torrentId === "string" && /^(stream-)?magnet:/.test(torrentId)) {
         const torrentObj = magnet(torrentId);
         if (!torrentObj.infoHash) {
           throw new Error("Invalid torrent identifier");
         }
         return torrentObj;
       } else if (typeof torrentId === "string" && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
         return magnet(`magnet:?xt=urn:btih:${torrentId}`);
       } else if (Buffer.isBuffer(torrentId) && torrentId.length === 20) {
         return magnet(`magnet:?xt=urn:btih:${torrentId.toString("hex")}`);
       } else if (Buffer.isBuffer(torrentId)) {
         return decodeTorrentFile(torrentId);
       } else if (torrentId && torrentId.infoHash) {
         torrentId.infoHash = torrentId.infoHash.toLowerCase();
         if (!torrentId.announce)
           torrentId.announce = [];
         if (typeof torrentId.announce === "string") {
           torrentId.announce = [torrentId.announce];
         }
         if (!torrentId.urlList)
           torrentId.urlList = [];
         return torrentId;
       } else {
         throw new Error("Invalid torrent identifier");
       }
     }
     function parseTorrentRemote(torrentId, opts, cb) {
       if (typeof opts === "function")
         return parseTorrentRemote(torrentId, {}, opts);
       if (typeof cb !== "function")
         throw new Error("second argument must be a Function");
       let parsedTorrent;
       try {
         parsedTorrent = parseTorrent(torrentId);
       } catch (err) {
       }
       if (parsedTorrent && parsedTorrent.infoHash) {
         queueMicrotask3(() => {
           cb(null, parsedTorrent);
         });
       } else if (isBlob(torrentId)) {
         blobToBuffer(torrentId, (err, torrentBuf) => {
           if (err)
             return cb(new Error(`Error converting Blob: ${err.message}`));
           parseOrThrow(torrentBuf);
         });
       } else if (typeof get === "function" && /^https?:/.test(torrentId)) {
         opts = Object.assign({
           url: torrentId,
           timeout: 30 * 1e3,
           headers: { "user-agent": "WebTorrent (https://webtorrent.io)" }
         }, opts);
         get.concat(opts, (err, res, torrentBuf) => {
           if (err)
             return cb(new Error(`Error downloading torrent: ${err.message}`));
           parseOrThrow(torrentBuf);
         });
       } else if (typeof fs2.readFile === "function" && typeof torrentId === "string") {
         fs2.readFile(torrentId, (err, torrentBuf) => {
           if (err)
             return cb(new Error("Invalid torrent identifier"));
           parseOrThrow(torrentBuf);
         });
       } else {
         queueMicrotask3(() => {
           cb(new Error("Invalid torrent identifier"));
         });
       }
       function parseOrThrow(torrentBuf) {
         try {
           parsedTorrent = parseTorrent(torrentBuf);
         } catch (err) {
           return cb(err);
         }
         if (parsedTorrent && parsedTorrent.infoHash)
           cb(null, parsedTorrent);
         else
           cb(new Error("Invalid torrent identifier"));
       }
     }
     function decodeTorrentFile(torrent) {
       if (Buffer.isBuffer(torrent)) {
         torrent = bencode.decode(torrent);
       }
       ensure(torrent.info, "info");
       ensure(torrent.info["name.utf-8"] || torrent.info.name, "info.name");
       ensure(torrent.info["piece length"], "info['piece length']");
       ensure(torrent.info.pieces, "info.pieces");
       if (torrent.info.files) {
         torrent.info.files.forEach((file) => {
           ensure(typeof file.length === "number", "info.files[0].length");
           ensure(file["path.utf-8"] || file.path, "info.files[0].path");
         });
       } else {
         ensure(typeof torrent.info.length === "number", "info.length");
       }
       const result = {
         info: torrent.info,
         infoBuffer: bencode.encode(torrent.info),
         name: (torrent.info["name.utf-8"] || torrent.info.name).toString(),
         announce: []
       };
       result.infoHash = sha1.sync(result.infoBuffer);
       result.infoHashBuffer = Buffer.from(result.infoHash, "hex");
       if (torrent.info.private !== void 0)
         result.private = !!torrent.info.private;
       if (torrent["creation date"])
         result.created = new Date(torrent["creation date"] * 1e3);
       if (torrent["created by"])
         result.createdBy = torrent["created by"].toString();
       if (Buffer.isBuffer(torrent.comment))
         result.comment = torrent.comment.toString();
       if (Array.isArray(torrent["announce-list"]) && torrent["announce-list"].length > 0) {
         torrent["announce-list"].forEach((urls) => {
           urls.forEach((url) => {
             result.announce.push(url.toString());
           });
         });
       } else if (torrent.announce) {
         result.announce.push(torrent.announce.toString());
       }
       if (Buffer.isBuffer(torrent["url-list"])) {
         torrent["url-list"] = torrent["url-list"].length > 0 ? [torrent["url-list"]] : [];
       }
       result.urlList = (torrent["url-list"] || []).map((url) => url.toString());
       result.announce = Array.from(new Set(result.announce));
       result.urlList = Array.from(new Set(result.urlList));
       const files = torrent.info.files || [torrent.info];
       result.files = files.map((file, i) => {
         const parts = [].concat(result.name, file["path.utf-8"] || file.path || []).map((p) => p.toString());
         return {
           path: path2.join.apply(null, [path2.sep].concat(parts)).slice(1),
           name: parts[parts.length - 1],
           length: file.length,
           offset: files.slice(0, i).reduce(sumLength, 0)
         };
       });
       result.length = files.reduce(sumLength, 0);
       const lastFile = result.files[result.files.length - 1];
       result.pieceLength = torrent.info["piece length"];
       result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength;
       result.pieces = splitPieces(torrent.info.pieces);
       return result;
     }
     function encodeTorrentFile(parsed) {
       const torrent = {
         info: parsed.info
       };
       torrent["announce-list"] = (parsed.announce || []).map((url) => {
         if (!torrent.announce)
           torrent.announce = url;
         url = Buffer.from(url, "utf8");
         return [url];
       });
       torrent["url-list"] = parsed.urlList || [];
       if (parsed.private !== void 0) {
         torrent.private = Number(parsed.private);
       }
       if (parsed.created) {
         torrent["creation date"] = parsed.created.getTime() / 1e3 | 0;
       }
       if (parsed.createdBy) {
         torrent["created by"] = parsed.createdBy;
       }
       if (parsed.comment) {
         torrent.comment = parsed.comment;
       }
       return bencode.encode(torrent);
     }
     function isBlob(obj) {
       return typeof Blob !== "undefined" && obj instanceof Blob;
     }
     function sumLength(sum, file) {
       return sum + file.length;
     }
     function splitPieces(buf) {
       const pieces = [];
       for (let i = 0; i < buf.length; i += 20) {
         pieces.push(buf.slice(i, i + 20).toString("hex"));
       }
       return pieces;
     }
     function ensure(bool, fieldName) {
       if (!bool)
         throw new Error(`Torrent is missing required field: ${fieldName}`);
     }
     (() => {
       Buffer.alloc(0);
     })();
   }
 });
 
 // node_modules/get-browser-rtc/index.js
 var require_get_browser_rtc = __commonJS({
   "node_modules/get-browser-rtc/index.js"(exports, module2) {
     module2.exports = function getBrowserRTC() {
       if (typeof globalThis === "undefined")
         return null;
       var wrtc = {
         RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
         RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
         RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
       };
       if (!wrtc.RTCPeerConnection)
         return null;
       return wrtc;
     };
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/stream.js
 var require_stream = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
     module2.exports = require("stream");
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/buffer_list.js
 var require_buffer_list = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
     "use strict";
     function ownKeys(object, enumerableOnly) {
       var keys = Object.keys(object);
       if (Object.getOwnPropertySymbols) {
         var symbols = Object.getOwnPropertySymbols(object);
         if (enumerableOnly)
           symbols = symbols.filter(function(sym) {
             return Object.getOwnPropertyDescriptor(object, sym).enumerable;
           });
         keys.push.apply(keys, symbols);
       }
       return keys;
     }
     function _objectSpread(target) {
       for (var i = 1; i < arguments.length; i++) {
         var source = arguments[i] != null ? arguments[i] : {};
         if (i % 2) {
           ownKeys(Object(source), true).forEach(function(key) {
             _defineProperty(target, key, source[key]);
           });
         } else if (Object.getOwnPropertyDescriptors) {
           Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
         } else {
           ownKeys(Object(source)).forEach(function(key) {
             Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
           });
         }
       }
       return target;
     }
     function _defineProperty(obj, key, value) {
       if (key in obj) {
         Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
       } else {
         obj[key] = value;
       }
       return obj;
     }
     function _classCallCheck(instance, Constructor) {
       if (!(instance instanceof Constructor)) {
         throw new TypeError("Cannot call a class as a function");
       }
     }
     function _defineProperties(target, props) {
       for (var i = 0; i < props.length; i++) {
         var descriptor = props[i];
         descriptor.enumerable = descriptor.enumerable || false;
         descriptor.configurable = true;
         if ("value" in descriptor)
           descriptor.writable = true;
         Object.defineProperty(target, descriptor.key, descriptor);
       }
     }
     function _createClass(Constructor, protoProps, staticProps) {
       if (protoProps)
         _defineProperties(Constructor.prototype, protoProps);
       if (staticProps)
         _defineProperties(Constructor, staticProps);
       return Constructor;
     }
     var _require = require("buffer");
     var Buffer2 = _require.Buffer;
     var _require2 = require("util");
     var inspect = _require2.inspect;
     var custom = inspect && inspect.custom || "inspect";
     function copyBuffer(src, target, offset) {
       Buffer2.prototype.copy.call(src, target, offset);
     }
     module2.exports = /* @__PURE__ */ function() {
       function BufferList() {
         _classCallCheck(this, BufferList);
         this.head = null;
         this.tail = null;
         this.length = 0;
       }
       _createClass(BufferList, [{
         key: "push",
         value: function push(v) {
           var entry = {
             data: v,
             next: null
           };
           if (this.length > 0)
             this.tail.next = entry;
           else
             this.head = entry;
           this.tail = entry;
           ++this.length;
         }
       }, {
         key: "unshift",
         value: function unshift(v) {
           var entry = {
             data: v,
             next: this.head
           };
           if (this.length === 0)
             this.tail = entry;
           this.head = entry;
           ++this.length;
         }
       }, {
         key: "shift",
         value: function shift() {
           if (this.length === 0)
             return;
           var ret = this.head.data;
           if (this.length === 1)
             this.head = this.tail = null;
           else
             this.head = this.head.next;
           --this.length;
           return ret;
         }
       }, {
         key: "clear",
         value: function clear() {
           this.head = this.tail = null;
           this.length = 0;
         }
       }, {
         key: "join",
         value: function join(s) {
           if (this.length === 0)
             return "";
           var p = this.head;
           var ret = "" + p.data;
           while (p = p.next) {
             ret += s + p.data;
           }
           return ret;
         }
       }, {
         key: "concat",
         value: function concat(n) {
           if (this.length === 0)
             return Buffer2.alloc(0);
           var ret = Buffer2.allocUnsafe(n >>> 0);
           var p = this.head;
           var i = 0;
           while (p) {
             copyBuffer(p.data, ret, i);
             i += p.data.length;
             p = p.next;
           }
           return ret;
         }
       }, {
         key: "consume",
         value: function consume(n, hasStrings) {
           var ret;
           if (n < this.head.data.length) {
             ret = this.head.data.slice(0, n);
             this.head.data = this.head.data.slice(n);
           } else if (n === this.head.data.length) {
             ret = this.shift();
           } else {
             ret = hasStrings ? this._getString(n) : this._getBuffer(n);
           }
           return ret;
         }
       }, {
         key: "first",
         value: function first() {
           return this.head.data;
         }
       }, {
         key: "_getString",
         value: function _getString(n) {
           var p = this.head;
           var c = 1;
           var ret = p.data;
           n -= ret.length;
           while (p = p.next) {
             var str = p.data;
             var nb = n > str.length ? str.length : n;
             if (nb === str.length)
               ret += str;
             else
               ret += str.slice(0, n);
             n -= nb;
             if (n === 0) {
               if (nb === str.length) {
                 ++c;
                 if (p.next)
                   this.head = p.next;
                 else
                   this.head = this.tail = null;
               } else {
                 this.head = p;
                 p.data = str.slice(nb);
               }
               break;
             }
             ++c;
           }
           this.length -= c;
           return ret;
         }
       }, {
         key: "_getBuffer",
         value: function _getBuffer(n) {
           var ret = Buffer2.allocUnsafe(n);
           var p = this.head;
           var c = 1;
           p.data.copy(ret);
           n -= p.data.length;
           while (p = p.next) {
             var buf = p.data;
             var nb = n > buf.length ? buf.length : n;
             buf.copy(ret, ret.length - n, 0, nb);
             n -= nb;
             if (n === 0) {
               if (nb === buf.length) {
                 ++c;
                 if (p.next)
                   this.head = p.next;
                 else
                   this.head = this.tail = null;
               } else {
                 this.head = p;
                 p.data = buf.slice(nb);
               }
               break;
             }
             ++c;
           }
           this.length -= c;
           return ret;
         }
       }, {
         key: custom,
         value: function value(_, options) {
           return inspect(this, _objectSpread({}, options, {
             depth: 0,
             customInspect: false
           }));
         }
       }]);
       return BufferList;
     }();
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/destroy.js
 var require_destroy = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
     "use strict";
     function destroy(err, cb) {
       var _this = this;
       var readableDestroyed = this._readableState && this._readableState.destroyed;
       var writableDestroyed = this._writableState && this._writableState.destroyed;
       if (readableDestroyed || writableDestroyed) {
         if (cb) {
           cb(err);
         } else if (err) {
           if (!this._writableState) {
             process.nextTick(emitErrorNT, this, err);
           } else if (!this._writableState.errorEmitted) {
             this._writableState.errorEmitted = true;
             process.nextTick(emitErrorNT, this, err);
           }
         }
         return this;
       }
       if (this._readableState) {
         this._readableState.destroyed = true;
       }
       if (this._writableState) {
         this._writableState.destroyed = true;
       }
       this._destroy(err || null, function(err2) {
         if (!cb && err2) {
           if (!_this._writableState) {
             process.nextTick(emitErrorAndCloseNT, _this, err2);
           } else if (!_this._writableState.errorEmitted) {
             _this._writableState.errorEmitted = true;
             process.nextTick(emitErrorAndCloseNT, _this, err2);
           } else {
             process.nextTick(emitCloseNT, _this);
           }
         } else if (cb) {
           process.nextTick(emitCloseNT, _this);
           cb(err2);
         } else {
           process.nextTick(emitCloseNT, _this);
         }
       });
       return this;
     }
     function emitErrorAndCloseNT(self, err) {
       emitErrorNT(self, err);
       emitCloseNT(self);
     }
     function emitCloseNT(self) {
       if (self._writableState && !self._writableState.emitClose)
         return;
       if (self._readableState && !self._readableState.emitClose)
         return;
       self.emit("close");
     }
     function undestroy() {
       if (this._readableState) {
         this._readableState.destroyed = false;
         this._readableState.reading = false;
         this._readableState.ended = false;
         this._readableState.endEmitted = false;
       }
       if (this._writableState) {
         this._writableState.destroyed = false;
         this._writableState.ended = false;
         this._writableState.ending = false;
         this._writableState.finalCalled = false;
         this._writableState.prefinished = false;
         this._writableState.finished = false;
         this._writableState.errorEmitted = false;
       }
     }
     function emitErrorNT(self, err) {
       self.emit("error", err);
     }
     function errorOrDestroy(stream, err) {
       var rState = stream._readableState;
       var wState = stream._writableState;
       if (rState && rState.autoDestroy || wState && wState.autoDestroy)
         stream.destroy(err);
       else
         stream.emit("error", err);
     }
     module2.exports = {
       destroy,
       undestroy,
       errorOrDestroy
     };
   }
 });
 
 // node_modules/readable-stream/errors.js
 var require_errors = __commonJS({
   "node_modules/readable-stream/errors.js"(exports, module2) {
     "use strict";
     var codes = {};
     function createErrorType(code, message, Base) {
       if (!Base) {
         Base = Error;
       }
       function getMessage(arg1, arg2, arg3) {
         if (typeof message === "string") {
           return message;
         } else {
           return message(arg1, arg2, arg3);
         }
       }
       class NodeError extends Base {
         constructor(arg1, arg2, arg3) {
           super(getMessage(arg1, arg2, arg3));
         }
       }
       NodeError.prototype.name = Base.name;
       NodeError.prototype.code = code;
       codes[code] = NodeError;
     }
     function oneOf(expected, thing) {
       if (Array.isArray(expected)) {
         const len = expected.length;
         expected = expected.map((i) => String(i));
         if (len > 2) {
           return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
         } else if (len === 2) {
           return `one of ${thing} ${expected[0]} or ${expected[1]}`;
         } else {
           return `of ${thing} ${expected[0]}`;
         }
       } else {
         return `of ${thing} ${String(expected)}`;
       }
     }
     function startsWith(str, search, pos) {
       return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
     }
     function endsWith(str, search, this_len) {
       if (this_len === void 0 || this_len > str.length) {
         this_len = str.length;
       }
       return str.substring(this_len - search.length, this_len) === search;
     }
     function includes(str, search, start) {
       if (typeof start !== "number") {
         start = 0;
       }
       if (start + search.length > str.length) {
         return false;
       } else {
         return str.indexOf(search, start) !== -1;
       }
     }
     createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
       return 'The value "' + value + '" is invalid for option "' + name + '"';
     }, TypeError);
     createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
       let determiner;
       if (typeof expected === "string" && startsWith(expected, "not ")) {
         determiner = "must not be";
         expected = expected.replace(/^not /, "");
       } else {
         determiner = "must be";
       }
       let msg;
       if (endsWith(name, " argument")) {
         msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
       } else {
         const type = includes(name, ".") ? "property" : "argument";
         msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
       }
       msg += `. Received type ${typeof actual}`;
       return msg;
     }, TypeError);
     createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
     createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
       return "The " + name + " method is not implemented";
     });
     createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
     createErrorType("ERR_STREAM_DESTROYED", function(name) {
       return "Cannot call " + name + " after a stream was destroyed";
     });
     createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
     createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
     createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
     createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
     createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
       return "Unknown encoding: " + arg;
     }, TypeError);
     createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
     module2.exports.codes = codes;
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/state.js
 var require_state = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
     "use strict";
     var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
     function highWaterMarkFrom(options, isDuplex, duplexKey) {
       return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
     }
     function getHighWaterMark(state, options, duplexKey, isDuplex) {
       var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
       if (hwm != null) {
         if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
           var name = isDuplex ? duplexKey : "highWaterMark";
           throw new ERR_INVALID_OPT_VALUE(name, hwm);
         }
         return Math.floor(hwm);
       }
       return state.objectMode ? 16 : 16 * 1024;
     }
     module2.exports = {
       getHighWaterMark
     };
   }
 });
 
 // node_modules/util-deprecate/node.js
 var require_node2 = __commonJS({
   "node_modules/util-deprecate/node.js"(exports, module2) {
     module2.exports = require("util").deprecate;
   }
 });
 
 // node_modules/readable-stream/lib/_stream_writable.js
 var require_stream_writable = __commonJS({
   "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
     "use strict";
     module2.exports = Writable;
     function CorkedRequest(state) {
       var _this = this;
       this.next = null;
       this.entry = null;
       this.finish = function() {
         onCorkedFinish(_this, state);
       };
     }
     var Duplex;
     Writable.WritableState = WritableState;
     var internalUtil = {
       deprecate: require_node2()
     };
     var Stream = require_stream();
     var Buffer2 = require("buffer").Buffer;
     var OurUint8Array = global.Uint8Array || function() {
     };
     function _uint8ArrayToBuffer(chunk) {
       return Buffer2.from(chunk);
     }
     function _isUint8Array(obj) {
       return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
     }
     var destroyImpl = require_destroy();
     var _require = require_state();
     var getHighWaterMark = _require.getHighWaterMark;
     var _require$codes = require_errors().codes;
     var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
     var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
     var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
     var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
     var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
     var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
     var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
     var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
     var errorOrDestroy = destroyImpl.errorOrDestroy;
     require_inherits()(Writable, Stream);
     function nop() {
     }
     function WritableState(options, stream, isDuplex) {
       Duplex = Duplex || require_stream_duplex();
       options = options || {};
       if (typeof isDuplex !== "boolean")
         isDuplex = stream instanceof Duplex;
       this.objectMode = !!options.objectMode;
       if (isDuplex)
         this.objectMode = this.objectMode || !!options.writableObjectMode;
       this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
       this.finalCalled = false;
       this.needDrain = false;
       this.ending = false;
       this.ended = false;
       this.finished = false;
       this.destroyed = false;
       var noDecode = options.decodeStrings === false;
       this.decodeStrings = !noDecode;
       this.defaultEncoding = options.defaultEncoding || "utf8";
       this.length = 0;
       this.writing = false;
       this.corked = 0;
       this.sync = true;
       this.bufferProcessing = false;
       this.onwrite = function(er) {
         onwrite(stream, er);
       };
       this.writecb = null;
       this.writelen = 0;
       this.bufferedRequest = null;
       this.lastBufferedRequest = null;
       this.pendingcb = 0;
       this.prefinished = false;
       this.errorEmitted = false;
       this.emitClose = options.emitClose !== false;
       this.autoDestroy = !!options.autoDestroy;
       this.bufferedRequestCount = 0;
       this.corkedRequestsFree = new CorkedRequest(this);
     }
     WritableState.prototype.getBuffer = function getBuffer() {
       var current = this.bufferedRequest;
       var out = [];
       while (current) {
         out.push(current);
         current = current.next;
       }
       return out;
     };
     (function() {
       try {
         Object.defineProperty(WritableState.prototype, "buffer", {
           get: internalUtil.deprecate(function writableStateBufferGetter() {
             return this.getBuffer();
           }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
         });
       } catch (_) {
       }
     })();
     var realHasInstance;
     if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
       realHasInstance = Function.prototype[Symbol.hasInstance];
       Object.defineProperty(Writable, Symbol.hasInstance, {
         value: function value(object) {
           if (realHasInstance.call(this, object))
             return true;
           if (this !== Writable)
             return false;
           return object && object._writableState instanceof WritableState;
         }
       });
     } else {
       realHasInstance = function realHasInstance2(object) {
         return object instanceof this;
       };
     }
     function Writable(options) {
       Duplex = Duplex || require_stream_duplex();
       var isDuplex = this instanceof Duplex;
       if (!isDuplex && !realHasInstance.call(Writable, this))
         return new Writable(options);
       this._writableState = new WritableState(options, this, isDuplex);
       this.writable = true;
       if (options) {
         if (typeof options.write === "function")
           this._write = options.write;
         if (typeof options.writev === "function")
           this._writev = options.writev;
         if (typeof options.destroy === "function")
           this._destroy = options.destroy;
         if (typeof options.final === "function")
           this._final = options.final;
       }
       Stream.call(this);
     }
     Writable.prototype.pipe = function() {
       errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
     };
     function writeAfterEnd(stream, cb) {
       var er = new ERR_STREAM_WRITE_AFTER_END();
       errorOrDestroy(stream, er);
       process.nextTick(cb, er);
     }
     function validChunk(stream, state, chunk, cb) {
       var er;
       if (chunk === null) {
         er = new ERR_STREAM_NULL_VALUES();
       } else if (typeof chunk !== "string" && !state.objectMode) {
         er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
       }
       if (er) {
         errorOrDestroy(stream, er);
         process.nextTick(cb, er);
         return false;
       }
       return true;
     }
     Writable.prototype.write = function(chunk, encoding, cb) {
       var state = this._writableState;
       var ret = false;
       var isBuf = !state.objectMode && _isUint8Array(chunk);
       if (isBuf && !Buffer2.isBuffer(chunk)) {
         chunk = _uint8ArrayToBuffer(chunk);
       }
       if (typeof encoding === "function") {
         cb = encoding;
         encoding = null;
       }
       if (isBuf)
         encoding = "buffer";
       else if (!encoding)
         encoding = state.defaultEncoding;
       if (typeof cb !== "function")
         cb = nop;
       if (state.ending)
         writeAfterEnd(this, cb);
       else if (isBuf || validChunk(this, state, chunk, cb)) {
         state.pendingcb++;
         ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
       }
       return ret;
     };
     Writable.prototype.cork = function() {
       this._writableState.corked++;
     };
     Writable.prototype.uncork = function() {
       var state = this._writableState;
       if (state.corked) {
         state.corked--;
         if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
           clearBuffer(this, state);
       }
     };
     Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
       if (typeof encoding === "string")
         encoding = encoding.toLowerCase();
       if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
         throw new ERR_UNKNOWN_ENCODING(encoding);
       this._writableState.defaultEncoding = encoding;
       return this;
     };
     Object.defineProperty(Writable.prototype, "writableBuffer", {
       enumerable: false,
       get: function get() {
         return this._writableState && this._writableState.getBuffer();
       }
     });
     function decodeChunk(state, chunk, encoding) {
       if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
         chunk = Buffer2.from(chunk, encoding);
       }
       return chunk;
     }
     Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
       enumerable: false,
       get: function get() {
         return this._writableState.highWaterMark;
       }
     });
     function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
       if (!isBuf) {
         var newChunk = decodeChunk(state, chunk, encoding);
         if (chunk !== newChunk) {
           isBuf = true;
           encoding = "buffer";
           chunk = newChunk;
         }
       }
       var len = state.objectMode ? 1 : chunk.length;
       state.length += len;
       var ret = state.length < state.highWaterMark;
       if (!ret)
         state.needDrain = true;
       if (state.writing || state.corked) {
         var last = state.lastBufferedRequest;
         state.lastBufferedRequest = {
           chunk,
           encoding,
           isBuf,
           callback: cb,
           next: null
         };
         if (last) {
           last.next = state.lastBufferedRequest;
         } else {
           state.bufferedRequest = state.lastBufferedRequest;
         }
         state.bufferedRequestCount += 1;
       } else {
         doWrite(stream, state, false, len, chunk, encoding, cb);
       }
       return ret;
     }
     function doWrite(stream, state, writev, len, chunk, encoding, cb) {
       state.writelen = len;
       state.writecb = cb;
       state.writing = true;
       state.sync = true;
       if (state.destroyed)
         state.onwrite(new ERR_STREAM_DESTROYED("write"));
       else if (writev)
         stream._writev(chunk, state.onwrite);
       else
         stream._write(chunk, encoding, state.onwrite);
       state.sync = false;
     }
     function onwriteError(stream, state, sync, er, cb) {
       --state.pendingcb;
       if (sync) {
         process.nextTick(cb, er);
         process.nextTick(finishMaybe, stream, state);
         stream._writableState.errorEmitted = true;
         errorOrDestroy(stream, er);
       } else {
         cb(er);
         stream._writableState.errorEmitted = true;
         errorOrDestroy(stream, er);
         finishMaybe(stream, state);
       }
     }
     function onwriteStateUpdate(state) {
       state.writing = false;
       state.writecb = null;
       state.length -= state.writelen;
       state.writelen = 0;
     }
     function onwrite(stream, er) {
       var state = stream._writableState;
       var sync = state.sync;
       var cb = state.writecb;
       if (typeof cb !== "function")
         throw new ERR_MULTIPLE_CALLBACK();
       onwriteStateUpdate(state);
       if (er)
         onwriteError(stream, state, sync, er, cb);
       else {
         var finished = needFinish(state) || stream.destroyed;
         if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
           clearBuffer(stream, state);
         }
         if (sync) {
           process.nextTick(afterWrite, stream, state, finished, cb);
         } else {
           afterWrite(stream, state, finished, cb);
         }
       }
     }
     function afterWrite(stream, state, finished, cb) {
       if (!finished)
         onwriteDrain(stream, state);
       state.pendingcb--;
       cb();
       finishMaybe(stream, state);
     }
     function onwriteDrain(stream, state) {
       if (state.length === 0 && state.needDrain) {
         state.needDrain = false;
         stream.emit("drain");
       }
     }
     function clearBuffer(stream, state) {
       state.bufferProcessing = true;
       var entry = state.bufferedRequest;
       if (stream._writev && entry && entry.next) {
         var l = state.bufferedRequestCount;
         var buffer = new Array(l);
         var holder = state.corkedRequestsFree;
         holder.entry = entry;
         var count = 0;
         var allBuffers = true;
         while (entry) {
           buffer[count] = entry;
           if (!entry.isBuf)
             allBuffers = false;
           entry = entry.next;
           count += 1;
         }
         buffer.allBuffers = allBuffers;
         doWrite(stream, state, true, state.length, buffer, "", holder.finish);
         state.pendingcb++;
         state.lastBufferedRequest = null;
         if (holder.next) {
           state.corkedRequestsFree = holder.next;
           holder.next = null;
         } else {
           state.corkedRequestsFree = new CorkedRequest(state);
         }
         state.bufferedRequestCount = 0;
       } else {
         while (entry) {
           var chunk = entry.chunk;
           var encoding = entry.encoding;
           var cb = entry.callback;
           var len = state.objectMode ? 1 : chunk.length;
           doWrite(stream, state, false, len, chunk, encoding, cb);
           entry = entry.next;
           state.bufferedRequestCount--;
           if (state.writing) {
             break;
           }
         }
         if (entry === null)
           state.lastBufferedRequest = null;
       }
       state.bufferedRequest = entry;
       state.bufferProcessing = false;
     }
     Writable.prototype._write = function(chunk, encoding, cb) {
       cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
     };
     Writable.prototype._writev = null;
     Writable.prototype.end = function(chunk, encoding, cb) {
       var state = this._writableState;
       if (typeof chunk === "function") {
         cb = chunk;
         chunk = null;
         encoding = null;
       } else if (typeof encoding === "function") {
         cb = encoding;
         encoding = null;
       }
       if (chunk !== null && chunk !== void 0)
         this.write(chunk, encoding);
       if (state.corked) {
         state.corked = 1;
         this.uncork();
       }
       if (!state.ending)
         endWritable(this, state, cb);
       return this;
     };
     Object.defineProperty(Writable.prototype, "writableLength", {
       enumerable: false,
       get: function get() {
         return this._writableState.length;
       }
     });
     function needFinish(state) {
       return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
     }
     function callFinal(stream, state) {
       stream._final(function(err) {
         state.pendingcb--;
         if (err) {
           errorOrDestroy(stream, err);
         }
         state.prefinished = true;
         stream.emit("prefinish");
         finishMaybe(stream, state);
       });
     }
     function prefinish(stream, state) {
       if (!state.prefinished && !state.finalCalled) {
         if (typeof stream._final === "function" && !state.destroyed) {
           state.pendingcb++;
           state.finalCalled = true;
           process.nextTick(callFinal, stream, state);
         } else {
           state.prefinished = true;
           stream.emit("prefinish");
         }
       }
     }
     function finishMaybe(stream, state) {
       var need = needFinish(state);
       if (need) {
         prefinish(stream, state);
         if (state.pendingcb === 0) {
           state.finished = true;
           stream.emit("finish");
           if (state.autoDestroy) {
             var rState = stream._readableState;
             if (!rState || rState.autoDestroy && rState.endEmitted) {
               stream.destroy();
             }
           }
         }
       }
       return need;
     }
     function endWritable(stream, state, cb) {
       state.ending = true;
       finishMaybe(stream, state);
       if (cb) {
         if (state.finished)
           process.nextTick(cb);
         else
           stream.once("finish", cb);
       }
       state.ended = true;
       stream.writable = false;
     }
     function onCorkedFinish(corkReq, state, err) {
       var entry = corkReq.entry;
       corkReq.entry = null;
       while (entry) {
         var cb = entry.callback;
         state.pendingcb--;
         cb(err);
         entry = entry.next;
       }
       state.corkedRequestsFree.next = corkReq;
     }
     Object.defineProperty(Writable.prototype, "destroyed", {
       enumerable: false,
       get: function get() {
         if (this._writableState === void 0) {
           return false;
         }
         return this._writableState.destroyed;
       },
       set: function set(value) {
         if (!this._writableState) {
           return;
         }
         this._writableState.destroyed = value;
       }
     });
     Writable.prototype.destroy = destroyImpl.destroy;
     Writable.prototype._undestroy = destroyImpl.undestroy;
     Writable.prototype._destroy = function(err, cb) {
       cb(err);
     };
   }
 });
 
 // node_modules/readable-stream/lib/_stream_duplex.js
 var require_stream_duplex = __commonJS({
   "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
     "use strict";
     var objectKeys = Object.keys || function(obj) {
       var keys2 = [];
       for (var key in obj) {
         keys2.push(key);
       }
       return keys2;
     };
     module2.exports = Duplex;
     var Readable = require_stream_readable();
     var Writable = require_stream_writable();
     require_inherits()(Duplex, Readable);
     {
       keys = objectKeys(Writable.prototype);
       for (v = 0; v < keys.length; v++) {
         method = keys[v];
         if (!Duplex.prototype[method])
           Duplex.prototype[method] = Writable.prototype[method];
       }
     }
     var keys;
     var method;
     var v;
     function Duplex(options) {
       if (!(this instanceof Duplex))
         return new Duplex(options);
       Readable.call(this, options);
       Writable.call(this, options);
       this.allowHalfOpen = true;
       if (options) {
         if (options.readable === false)
           this.readable = false;
         if (options.writable === false)
           this.writable = false;
         if (options.allowHalfOpen === false) {
           this.allowHalfOpen = false;
           this.once("end", onend);
         }
       }
     }
     Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
       enumerable: false,
       get: function get() {
         return this._writableState.highWaterMark;
       }
     });
     Object.defineProperty(Duplex.prototype, "writableBuffer", {
       enumerable: false,
       get: function get() {
         return this._writableState && this._writableState.getBuffer();
       }
     });
     Object.defineProperty(Duplex.prototype, "writableLength", {
       enumerable: false,
       get: function get() {
         return this._writableState.length;
       }
     });
     function onend() {
       if (this._writableState.ended)
         return;
       process.nextTick(onEndNT, this);
     }
     function onEndNT(self) {
       self.end();
     }
     Object.defineProperty(Duplex.prototype, "destroyed", {
       enumerable: false,
       get: function get() {
         if (this._readableState === void 0 || this._writableState === void 0) {
           return false;
         }
         return this._readableState.destroyed && this._writableState.destroyed;
       },
       set: function set(value) {
         if (this._readableState === void 0 || this._writableState === void 0) {
           return;
         }
         this._readableState.destroyed = value;
         this._writableState.destroyed = value;
       }
     });
   }
 });
 
 // node_modules/safe-buffer/index.js
 var require_safe_buffer = __commonJS({
   "node_modules/safe-buffer/index.js"(exports, module2) {
     var buffer = require("buffer");
     var Buffer2 = buffer.Buffer;
     function copyProps(src, dst) {
       for (var key in src) {
         dst[key] = src[key];
       }
     }
     if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
       module2.exports = buffer;
     } else {
       copyProps(buffer, exports);
       exports.Buffer = SafeBuffer;
     }
     function SafeBuffer(arg, encodingOrOffset, length) {
       return Buffer2(arg, encodingOrOffset, length);
     }
     SafeBuffer.prototype = Object.create(Buffer2.prototype);
     copyProps(Buffer2, SafeBuffer);
     SafeBuffer.from = function(arg, encodingOrOffset, length) {
       if (typeof arg === "number") {
         throw new TypeError("Argument must not be a number");
       }
       return Buffer2(arg, encodingOrOffset, length);
     };
     SafeBuffer.alloc = function(size, fill, encoding) {
       if (typeof size !== "number") {
         throw new TypeError("Argument must be a number");
       }
       var buf = Buffer2(size);
       if (fill !== void 0) {
         if (typeof encoding === "string") {
           buf.fill(fill, encoding);
         } else {
           buf.fill(fill);
         }
       } else {
         buf.fill(0);
       }
       return buf;
     };
     SafeBuffer.allocUnsafe = function(size) {
       if (typeof size !== "number") {
         throw new TypeError("Argument must be a number");
       }
       return Buffer2(size);
     };
     SafeBuffer.allocUnsafeSlow = function(size) {
       if (typeof size !== "number") {
         throw new TypeError("Argument must be a number");
       }
       return buffer.SlowBuffer(size);
     };
   }
 });
 
 // node_modules/string_decoder/lib/string_decoder.js
 var require_string_decoder = __commonJS({
   "node_modules/string_decoder/lib/string_decoder.js"(exports) {
     "use strict";
     var Buffer2 = require_safe_buffer().Buffer;
     var isEncoding = Buffer2.isEncoding || function(encoding) {
       encoding = "" + encoding;
       switch (encoding && encoding.toLowerCase()) {
         case "hex":
         case "utf8":
         case "utf-8":
         case "ascii":
         case "binary":
         case "base64":
         case "ucs2":
         case "ucs-2":
         case "utf16le":
         case "utf-16le":
         case "raw":
           return true;
         default:
           return false;
       }
     };
     function _normalizeEncoding(enc) {
       if (!enc)
         return "utf8";
       var retried;
       while (true) {
         switch (enc) {
           case "utf8":
           case "utf-8":
             return "utf8";
           case "ucs2":
           case "ucs-2":
           case "utf16le":
           case "utf-16le":
             return "utf16le";
           case "latin1":
           case "binary":
             return "latin1";
           case "base64":
           case "ascii":
           case "hex":
             return enc;
           default:
             if (retried)
               return;
             enc = ("" + enc).toLowerCase();
             retried = true;
         }
       }
     }
     function normalizeEncoding(enc) {
       var nenc = _normalizeEncoding(enc);
       if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
         throw new Error("Unknown encoding: " + enc);
       return nenc || enc;
     }
     exports.StringDecoder = StringDecoder;
     function StringDecoder(encoding) {
       this.encoding = normalizeEncoding(encoding);
       var nb;
       switch (this.encoding) {
         case "utf16le":
           this.text = utf16Text;
           this.end = utf16End;
           nb = 4;
           break;
         case "utf8":
           this.fillLast = utf8FillLast;
           nb = 4;
           break;
         case "base64":
           this.text = base64Text;
           this.end = base64End;
           nb = 3;
           break;
         default:
           this.write = simpleWrite;
           this.end = simpleEnd;
           return;
       }
       this.lastNeed = 0;
       this.lastTotal = 0;
       this.lastChar = Buffer2.allocUnsafe(nb);
     }
     StringDecoder.prototype.write = function(buf) {
       if (buf.length === 0)
         return "";
       var r;
       var i;
       if (this.lastNeed) {
         r = this.fillLast(buf);
         if (r === void 0)
           return "";
         i = this.lastNeed;
         this.lastNeed = 0;
       } else {
         i = 0;
       }
       if (i < buf.length)
         return r ? r + this.text(buf, i) : this.text(buf, i);
       return r || "";
     };
     StringDecoder.prototype.end = utf8End;
     StringDecoder.prototype.text = utf8Text;
     StringDecoder.prototype.fillLast = function(buf) {
       if (this.lastNeed <= buf.length) {
         buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
         return this.lastChar.toString(this.encoding, 0, this.lastTotal);
       }
       buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
       this.lastNeed -= buf.length;
     };
     function utf8CheckByte(byte) {
       if (byte <= 127)
         return 0;
       else if (byte >> 5 === 6)
         return 2;
       else if (byte >> 4 === 14)
         return 3;
       else if (byte >> 3 === 30)
         return 4;
       return byte >> 6 === 2 ? -1 : -2;
     }
     function utf8CheckIncomplete(self, buf, i) {
       var j = buf.length - 1;
       if (j < i)
         return 0;
       var nb = utf8CheckByte(buf[j]);
       if (nb >= 0) {
         if (nb > 0)
           self.lastNeed = nb - 1;
         return nb;
       }
       if (--j < i || nb === -2)
         return 0;
       nb = utf8CheckByte(buf[j]);
       if (nb >= 0) {
         if (nb > 0)
           self.lastNeed = nb - 2;
         return nb;
       }
       if (--j < i || nb === -2)
         return 0;
       nb = utf8CheckByte(buf[j]);
       if (nb >= 0) {
         if (nb > 0) {
           if (nb === 2)
             nb = 0;
           else
             self.lastNeed = nb - 3;
         }
         return nb;
       }
       return 0;
     }
     function utf8CheckExtraBytes(self, buf, p) {
       if ((buf[0] & 192) !== 128) {
         self.lastNeed = 0;
         return "\uFFFD";
       }
       if (self.lastNeed > 1 && buf.length > 1) {
         if ((buf[1] & 192) !== 128) {
           self.lastNeed = 1;
           return "\uFFFD";
         }
         if (self.lastNeed > 2 && buf.length > 2) {
           if ((buf[2] & 192) !== 128) {
             self.lastNeed = 2;
             return "\uFFFD";
           }
         }
       }
     }
     function utf8FillLast(buf) {
       var p = this.lastTotal - this.lastNeed;
       var r = utf8CheckExtraBytes(this, buf, p);
       if (r !== void 0)
         return r;
       if (this.lastNeed <= buf.length) {
         buf.copy(this.lastChar, p, 0, this.lastNeed);
         return this.lastChar.toString(this.encoding, 0, this.lastTotal);
       }
       buf.copy(this.lastChar, p, 0, buf.length);
       this.lastNeed -= buf.length;
     }
     function utf8Text(buf, i) {
       var total = utf8CheckIncomplete(this, buf, i);
       if (!this.lastNeed)
         return buf.toString("utf8", i);
       this.lastTotal = total;
       var end = buf.length - (total - this.lastNeed);
       buf.copy(this.lastChar, 0, end);
       return buf.toString("utf8", i, end);
     }
     function utf8End(buf) {
       var r = buf && buf.length ? this.write(buf) : "";
       if (this.lastNeed)
         return r + "\uFFFD";
       return r;
     }
     function utf16Text(buf, i) {
       if ((buf.length - i) % 2 === 0) {
         var r = buf.toString("utf16le", i);
         if (r) {
           var c = r.charCodeAt(r.length - 1);
           if (c >= 55296 && c <= 56319) {
             this.lastNeed = 2;
             this.lastTotal = 4;
             this.lastChar[0] = buf[buf.length - 2];
             this.lastChar[1] = buf[buf.length - 1];
             return r.slice(0, -1);
           }
         }
         return r;
       }
       this.lastNeed = 1;
       this.lastTotal = 2;
       this.lastChar[0] = buf[buf.length - 1];
       return buf.toString("utf16le", i, buf.length - 1);
     }
     function utf16End(buf) {
       var r = buf && buf.length ? this.write(buf) : "";
       if (this.lastNeed) {
         var end = this.lastTotal - this.lastNeed;
         return r + this.lastChar.toString("utf16le", 0, end);
       }
       return r;
     }
     function base64Text(buf, i) {
       var n = (buf.length - i) % 3;
       if (n === 0)
         return buf.toString("base64", i);
       this.lastNeed = 3 - n;
       this.lastTotal = 3;
       if (n === 1) {
         this.lastChar[0] = buf[buf.length - 1];
       } else {
         this.lastChar[0] = buf[buf.length - 2];
         this.lastChar[1] = buf[buf.length - 1];
       }
       return buf.toString("base64", i, buf.length - n);
     }
     function base64End(buf) {
       var r = buf && buf.length ? this.write(buf) : "";
       if (this.lastNeed)
         return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
       return r;
     }
     function simpleWrite(buf) {
       return buf.toString(this.encoding);
     }
     function simpleEnd(buf) {
       return buf && buf.length ? this.write(buf) : "";
     }
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/end-of-stream.js
 var require_end_of_stream = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
     "use strict";
     var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
     function once(callback) {
       var called = false;
       return function() {
         if (called)
           return;
         called = true;
         for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
           args[_key] = arguments[_key];
         }
         callback.apply(this, args);
       };
     }
     function noop2() {
     }
     function isRequest(stream) {
       return stream.setHeader && typeof stream.abort === "function";
     }
     function eos(stream, opts, callback) {
       if (typeof opts === "function")
         return eos(stream, null, opts);
       if (!opts)
         opts = {};
       callback = once(callback || noop2);
       var readable = opts.readable || opts.readable !== false && stream.readable;
       var writable = opts.writable || opts.writable !== false && stream.writable;
       var onlegacyfinish = function onlegacyfinish2() {
         if (!stream.writable)
           onfinish();
       };
       var writableEnded = stream._writableState && stream._writableState.finished;
       var onfinish = function onfinish2() {
         writable = false;
         writableEnded = true;
         if (!readable)
           callback.call(stream);
       };
       var readableEnded = stream._readableState && stream._readableState.endEmitted;
       var onend = function onend2() {
         readable = false;
         readableEnded = true;
         if (!writable)
           callback.call(stream);
       };
       var onerror = function onerror2(err) {
         callback.call(stream, err);
       };
       var onclose = function onclose2() {
         var err;
         if (readable && !readableEnded) {
           if (!stream._readableState || !stream._readableState.ended)
             err = new ERR_STREAM_PREMATURE_CLOSE();
           return callback.call(stream, err);
         }
         if (writable && !writableEnded) {
           if (!stream._writableState || !stream._writableState.ended)
             err = new ERR_STREAM_PREMATURE_CLOSE();
           return callback.call(stream, err);
         }
       };
       var onrequest = function onrequest2() {
         stream.req.on("finish", onfinish);
       };
       if (isRequest(stream)) {
         stream.on("complete", onfinish);
         stream.on("abort", onclose);
         if (stream.req)
           onrequest();
         else
           stream.on("request", onrequest);
       } else if (writable && !stream._writableState) {
         stream.on("end", onlegacyfinish);
         stream.on("close", onlegacyfinish);
       }
       stream.on("end", onend);
       stream.on("finish", onfinish);
       if (opts.error !== false)
         stream.on("error", onerror);
       stream.on("close", onclose);
       return function() {
         stream.removeListener("complete", onfinish);
         stream.removeListener("abort", onclose);
         stream.removeListener("request", onrequest);
         if (stream.req)
           stream.req.removeListener("finish", onfinish);
         stream.removeListener("end", onlegacyfinish);
         stream.removeListener("close", onlegacyfinish);
         stream.removeListener("finish", onfinish);
         stream.removeListener("end", onend);
         stream.removeListener("error", onerror);
         stream.removeListener("close", onclose);
       };
     }
     module2.exports = eos;
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/async_iterator.js
 var require_async_iterator = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
     "use strict";
     var _Object$setPrototypeO;
     function _defineProperty(obj, key, value) {
       if (key in obj) {
         Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
       } else {
         obj[key] = value;
       }
       return obj;
     }
     var finished = require_end_of_stream();
     var kLastResolve = Symbol("lastResolve");
     var kLastReject = Symbol("lastReject");
     var kError = Symbol("error");
     var kEnded = Symbol("ended");
     var kLastPromise = Symbol("lastPromise");
     var kHandlePromise = Symbol("handlePromise");
     var kStream = Symbol("stream");
     function createIterResult(value, done) {
       return {
         value,
         done
       };
     }
     function readAndResolve(iter) {
       var resolve = iter[kLastResolve];
       if (resolve !== null) {
         var data = iter[kStream].read();
         if (data !== null) {
           iter[kLastPromise] = null;
           iter[kLastResolve] = null;
           iter[kLastReject] = null;
           resolve(createIterResult(data, false));
         }
       }
     }
     function onReadable(iter) {
       process.nextTick(readAndResolve, iter);
     }
     function wrapForNext(lastPromise, iter) {
       return function(resolve, reject) {
         lastPromise.then(function() {
           if (iter[kEnded]) {
             resolve(createIterResult(void 0, true));
             return;
           }
           iter[kHandlePromise](resolve, reject);
         }, reject);
       };
     }
     var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
     });
     var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
       get stream() {
         return this[kStream];
       },
       next: function next() {
         var _this = this;
         var error = this[kError];
         if (error !== null) {
           return Promise.reject(error);
         }
         if (this[kEnded]) {
           return Promise.resolve(createIterResult(void 0, true));
         }
         if (this[kStream].destroyed) {
           return new Promise(function(resolve, reject) {
             process.nextTick(function() {
               if (_this[kError]) {
                 reject(_this[kError]);
               } else {
                 resolve(createIterResult(void 0, true));
               }
             });
           });
         }
         var lastPromise = this[kLastPromise];
         var promise;
         if (lastPromise) {
           promise = new Promise(wrapForNext(lastPromise, this));
         } else {
           var data = this[kStream].read();
           if (data !== null) {
             return Promise.resolve(createIterResult(data, false));
           }
           promise = new Promise(this[kHandlePromise]);
         }
         this[kLastPromise] = promise;
         return promise;
       }
     }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
       return this;
     }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
       var _this2 = this;
       return new Promise(function(resolve, reject) {
         _this2[kStream].destroy(null, function(err) {
           if (err) {
             reject(err);
             return;
           }
           resolve(createIterResult(void 0, true));
         });
       });
     }), _Object$setPrototypeO), AsyncIteratorPrototype);
     var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
       var _Object$create;
       var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
         value: stream,
         writable: true
       }), _defineProperty(_Object$create, kLastResolve, {
         value: null,
         writable: true
       }), _defineProperty(_Object$create, kLastReject, {
         value: null,
         writable: true
       }), _defineProperty(_Object$create, kError, {
         value: null,
         writable: true
       }), _defineProperty(_Object$create, kEnded, {
         value: stream._readableState.endEmitted,
         writable: true
       }), _defineProperty(_Object$create, kHandlePromise, {
         value: function value(resolve, reject) {
           var data = iterator[kStream].read();
           if (data) {
             iterator[kLastPromise] = null;
             iterator[kLastResolve] = null;
             iterator[kLastReject] = null;
             resolve(createIterResult(data, false));
           } else {
             iterator[kLastResolve] = resolve;
             iterator[kLastReject] = reject;
           }
         },
         writable: true
       }), _Object$create));
       iterator[kLastPromise] = null;
       finished(stream, function(err) {
         if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
           var reject = iterator[kLastReject];
           if (reject !== null) {
             iterator[kLastPromise] = null;
             iterator[kLastResolve] = null;
             iterator[kLastReject] = null;
             reject(err);
           }
           iterator[kError] = err;
           return;
         }
         var resolve = iterator[kLastResolve];
         if (resolve !== null) {
           iterator[kLastPromise] = null;
           iterator[kLastResolve] = null;
           iterator[kLastReject] = null;
           resolve(createIterResult(void 0, true));
         }
         iterator[kEnded] = true;
       });
       stream.on("readable", onReadable.bind(null, iterator));
       return iterator;
     };
     module2.exports = createReadableStreamAsyncIterator;
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/from.js
 var require_from = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
     "use strict";
     function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
       try {
         var info = gen[key](arg);
         var value = info.value;
       } catch (error) {
         reject(error);
         return;
       }
       if (info.done) {
         resolve(value);
       } else {
         Promise.resolve(value).then(_next, _throw);
       }
     }
     function _asyncToGenerator(fn) {
       return function() {
         var self = this, args = arguments;
         return new Promise(function(resolve, reject) {
           var gen = fn.apply(self, args);
           function _next(value) {
             asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
           }
           function _throw(err) {
             asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
           }
           _next(void 0);
         });
       };
     }
     function ownKeys(object, enumerableOnly) {
       var keys = Object.keys(object);
       if (Object.getOwnPropertySymbols) {
         var symbols = Object.getOwnPropertySymbols(object);
         if (enumerableOnly)
           symbols = symbols.filter(function(sym) {
             return Object.getOwnPropertyDescriptor(object, sym).enumerable;
           });
         keys.push.apply(keys, symbols);
       }
       return keys;
     }
     function _objectSpread(target) {
       for (var i = 1; i < arguments.length; i++) {
         var source = arguments[i] != null ? arguments[i] : {};
         if (i % 2) {
           ownKeys(Object(source), true).forEach(function(key) {
             _defineProperty(target, key, source[key]);
           });
         } else if (Object.getOwnPropertyDescriptors) {
           Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
         } else {
           ownKeys(Object(source)).forEach(function(key) {
             Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
           });
         }
       }
       return target;
     }
     function _defineProperty(obj, key, value) {
       if (key in obj) {
         Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
       } else {
         obj[key] = value;
       }
       return obj;
     }
     var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
     function from(Readable, iterable, opts) {
       var iterator;
       if (iterable && typeof iterable.next === "function") {
         iterator = iterable;
       } else if (iterable && iterable[Symbol.asyncIterator])
         iterator = iterable[Symbol.asyncIterator]();
       else if (iterable && iterable[Symbol.iterator])
         iterator = iterable[Symbol.iterator]();
       else
         throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
       var readable = new Readable(_objectSpread({
         objectMode: true
       }, opts));
       var reading = false;
       readable._read = function() {
         if (!reading) {
           reading = true;
           next();
         }
       };
       function next() {
         return _next2.apply(this, arguments);
       }
       function _next2() {
         _next2 = _asyncToGenerator(function* () {
           try {
             var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
             if (done) {
               readable.push(null);
             } else if (readable.push(yield value)) {
               next();
             } else {
               reading = false;
             }
           } catch (err) {
             readable.destroy(err);
           }
         });
         return _next2.apply(this, arguments);
       }
       return readable;
     }
     module2.exports = from;
   }
 });
 
 // node_modules/readable-stream/lib/_stream_readable.js
 var require_stream_readable = __commonJS({
   "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
     "use strict";
     module2.exports = Readable;
     var Duplex;
     Readable.ReadableState = ReadableState;
     var EE = require("events").EventEmitter;
     var EElistenerCount = function EElistenerCount2(emitter, type) {
       return emitter.listeners(type).length;
     };
     var Stream = require_stream();
     var Buffer2 = require("buffer").Buffer;
     var OurUint8Array = global.Uint8Array || function() {
     };
     function _uint8ArrayToBuffer(chunk) {
       return Buffer2.from(chunk);
     }
     function _isUint8Array(obj) {
       return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
     }
     var debugUtil = require("util");
     var debug;
     if (debugUtil && debugUtil.debuglog) {
       debug = debugUtil.debuglog("stream");
     } else {
       debug = function debug2() {
       };
     }
     var BufferList = require_buffer_list();
     var destroyImpl = require_destroy();
     var _require = require_state();
     var getHighWaterMark = _require.getHighWaterMark;
     var _require$codes = require_errors().codes;
     var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
     var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
     var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
     var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
     var StringDecoder;
     var createReadableStreamAsyncIterator;
     var from;
     require_inherits()(Readable, Stream);
     var errorOrDestroy = destroyImpl.errorOrDestroy;
     var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
     function prependListener(emitter, event, fn) {
       if (typeof emitter.prependListener === "function")
         return emitter.prependListener(event, fn);
       if (!emitter._events || !emitter._events[event])
         emitter.on(event, fn);
       else if (Array.isArray(emitter._events[event]))
         emitter._events[event].unshift(fn);
       else
         emitter._events[event] = [fn, emitter._events[event]];
     }
     function ReadableState(options, stream, isDuplex) {
       Duplex = Duplex || require_stream_duplex();
       options = options || {};
       if (typeof isDuplex !== "boolean")
         isDuplex = stream instanceof Duplex;
       this.objectMode = !!options.objectMode;
       if (isDuplex)
         this.objectMode = this.objectMode || !!options.readableObjectMode;
       this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
       this.buffer = new BufferList();
       this.length = 0;
       this.pipes = null;
       this.pipesCount = 0;
       this.flowing = null;
       this.ended = false;
       this.endEmitted = false;
       this.reading = false;
       this.sync = true;
       this.needReadable = false;
       this.emittedReadable = false;
       this.readableListening = false;
       this.resumeScheduled = false;
       this.paused = true;
       this.emitClose = options.emitClose !== false;
       this.autoDestroy = !!options.autoDestroy;
       this.destroyed = false;
       this.defaultEncoding = options.defaultEncoding || "utf8";
       this.awaitDrain = 0;
       this.readingMore = false;
       this.decoder = null;
       this.encoding = null;
       if (options.encoding) {
         if (!StringDecoder)
           StringDecoder = require_string_decoder().StringDecoder;
         this.decoder = new StringDecoder(options.encoding);
         this.encoding = options.encoding;
       }
     }
     function Readable(options) {
       Duplex = Duplex || require_stream_duplex();
       if (!(this instanceof Readable))
         return new Readable(options);
       var isDuplex = this instanceof Duplex;
       this._readableState = new ReadableState(options, this, isDuplex);
       this.readable = true;
       if (options) {
         if (typeof options.read === "function")
           this._read = options.read;
         if (typeof options.destroy === "function")
           this._destroy = options.destroy;
       }
       Stream.call(this);
     }
     Object.defineProperty(Readable.prototype, "destroyed", {
       enumerable: false,
       get: function get() {
         if (this._readableState === void 0) {
           return false;
         }
         return this._readableState.destroyed;
       },
       set: function set(value) {
         if (!this._readableState) {
           return;
         }
         this._readableState.destroyed = value;
       }
     });
     Readable.prototype.destroy = destroyImpl.destroy;
     Readable.prototype._undestroy = destroyImpl.undestroy;
     Readable.prototype._destroy = function(err, cb) {
       cb(err);
     };
     Readable.prototype.push = function(chunk, encoding) {
       var state = this._readableState;
       var skipChunkCheck;
       if (!state.objectMode) {
         if (typeof chunk === "string") {
           encoding = encoding || state.defaultEncoding;
           if (encoding !== state.encoding) {
             chunk = Buffer2.from(chunk, encoding);
             encoding = "";
           }
           skipChunkCheck = true;
         }
       } else {
         skipChunkCheck = true;
       }
       return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
     };
     Readable.prototype.unshift = function(chunk) {
       return readableAddChunk(this, chunk, null, true, false);
     };
     function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
       debug("readableAddChunk", chunk);
       var state = stream._readableState;
       if (chunk === null) {
         state.reading = false;
         onEofChunk(stream, state);
       } else {
         var er;
         if (!skipChunkCheck)
           er = chunkInvalid(state, chunk);
         if (er) {
           errorOrDestroy(stream, er);
         } else if (state.objectMode || chunk && chunk.length > 0) {
           if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
             chunk = _uint8ArrayToBuffer(chunk);
           }
           if (addToFront) {
             if (state.endEmitted)
               errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
             else
               addChunk(stream, state, chunk, true);
           } else if (state.ended) {
             errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
           } else if (state.destroyed) {
             return false;
           } else {
             state.reading = false;
             if (state.decoder && !encoding) {
               chunk = state.decoder.write(chunk);
               if (state.objectMode || chunk.length !== 0)
                 addChunk(stream, state, chunk, false);
               else
                 maybeReadMore(stream, state);
             } else {
               addChunk(stream, state, chunk, false);
             }
           }
         } else if (!addToFront) {
           state.reading = false;
           maybeReadMore(stream, state);
         }
       }
       return !state.ended && (state.length < state.highWaterMark || state.length === 0);
     }
     function addChunk(stream, state, chunk, addToFront) {
       if (state.flowing && state.length === 0 && !state.sync) {
         state.awaitDrain = 0;
         stream.emit("data", chunk);
       } else {
         state.length += state.objectMode ? 1 : chunk.length;
         if (addToFront)
           state.buffer.unshift(chunk);
         else
           state.buffer.push(chunk);
         if (state.needReadable)
           emitReadable(stream);
       }
       maybeReadMore(stream, state);
     }
     function chunkInvalid(state, chunk) {
       var er;
       if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
         er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
       }
       return er;
     }
     Readable.prototype.isPaused = function() {
       return this._readableState.flowing === false;
     };
     Readable.prototype.setEncoding = function(enc) {
       if (!StringDecoder)
         StringDecoder = require_string_decoder().StringDecoder;
       var decoder = new StringDecoder(enc);
       this._readableState.decoder = decoder;
       this._readableState.encoding = this._readableState.decoder.encoding;
       var p = this._readableState.buffer.head;
       var content = "";
       while (p !== null) {
         content += decoder.write(p.data);
         p = p.next;
       }
       this._readableState.buffer.clear();
       if (content !== "")
         this._readableState.buffer.push(content);
       this._readableState.length = content.length;
       return this;
     };
     var MAX_HWM = 1073741824;
     function computeNewHighWaterMark(n) {
       if (n >= MAX_HWM) {
         n = MAX_HWM;
       } else {
         n--;
         n |= n >>> 1;
         n |= n >>> 2;
         n |= n >>> 4;
         n |= n >>> 8;
         n |= n >>> 16;
         n++;
       }
       return n;
     }
     function howMuchToRead(n, state) {
       if (n <= 0 || state.length === 0 && state.ended)
         return 0;
       if (state.objectMode)
         return 1;
       if (n !== n) {
         if (state.flowing && state.length)
           return state.buffer.head.data.length;
         else
           return state.length;
       }
       if (n > state.highWaterMark)
         state.highWaterMark = computeNewHighWaterMark(n);
       if (n <= state.length)
         return n;
       if (!state.ended) {
         state.needReadable = true;
         return 0;
       }
       return state.length;
     }
     Readable.prototype.read = function(n) {
       debug("read", n);
       n = parseInt(n, 10);
       var state = this._readableState;
       var nOrig = n;
       if (n !== 0)
         state.emittedReadable = false;
       if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
         debug("read: emitReadable", state.length, state.ended);
         if (state.length === 0 && state.ended)
           endReadable(this);
         else
           emitReadable(this);
         return null;
       }
       n = howMuchToRead(n, state);
       if (n === 0 && state.ended) {
         if (state.length === 0)
           endReadable(this);
         return null;
       }
       var doRead = state.needReadable;
       debug("need readable", doRead);
       if (state.length === 0 || state.length - n < state.highWaterMark) {
         doRead = true;
         debug("length less than watermark", doRead);
       }
       if (state.ended || state.reading) {
         doRead = false;
         debug("reading or ended", doRead);
       } else if (doRead) {
         debug("do read");
         state.reading = true;
         state.sync = true;
         if (state.length === 0)
           state.needReadable = true;
         this._read(state.highWaterMark);
         state.sync = false;
         if (!state.reading)
           n = howMuchToRead(nOrig, state);
       }
       var ret;
       if (n > 0)
         ret = fromList(n, state);
       else
         ret = null;
       if (ret === null) {
         state.needReadable = state.length <= state.highWaterMark;
         n = 0;
       } else {
         state.length -= n;
         state.awaitDrain = 0;
       }
       if (state.length === 0) {
         if (!state.ended)
           state.needReadable = true;
         if (nOrig !== n && state.ended)
           endReadable(this);
       }
       if (ret !== null)
         this.emit("data", ret);
       return ret;
     };
     function onEofChunk(stream, state) {
       debug("onEofChunk");
       if (state.ended)
         return;
       if (state.decoder) {
         var chunk = state.decoder.end();
         if (chunk && chunk.length) {
           state.buffer.push(chunk);
           state.length += state.objectMode ? 1 : chunk.length;
         }
       }
       state.ended = true;
       if (state.sync) {
         emitReadable(stream);
       } else {
         state.needReadable = false;
         if (!state.emittedReadable) {
           state.emittedReadable = true;
           emitReadable_(stream);
         }
       }
     }
     function emitReadable(stream) {
       var state = stream._readableState;
       debug("emitReadable", state.needReadable, state.emittedReadable);
       state.needReadable = false;
       if (!state.emittedReadable) {
         debug("emitReadable", state.flowing);
         state.emittedReadable = true;
         process.nextTick(emitReadable_, stream);
       }
     }
     function emitReadable_(stream) {
       var state = stream._readableState;
       debug("emitReadable_", state.destroyed, state.length, state.ended);
       if (!state.destroyed && (state.length || state.ended)) {
         stream.emit("readable");
         state.emittedReadable = false;
       }
       state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
       flow(stream);
     }
     function maybeReadMore(stream, state) {
       if (!state.readingMore) {
         state.readingMore = true;
         process.nextTick(maybeReadMore_, stream, state);
       }
     }
     function maybeReadMore_(stream, state) {
       while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
         var len = state.length;
         debug("maybeReadMore read 0");
         stream.read(0);
         if (len === state.length)
           break;
       }
       state.readingMore = false;
     }
     Readable.prototype._read = function(n) {
       errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
     };
     Readable.prototype.pipe = function(dest, pipeOpts) {
       var src = this;
       var state = this._readableState;
       switch (state.pipesCount) {
         case 0:
           state.pipes = dest;
           break;
         case 1:
           state.pipes = [state.pipes, dest];
           break;
         default:
           state.pipes.push(dest);
           break;
       }
       state.pipesCount += 1;
       debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
       var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
       var endFn = doEnd ? onend : unpipe;
       if (state.endEmitted)
         process.nextTick(endFn);
       else
         src.once("end", endFn);
       dest.on("unpipe", onunpipe);
       function onunpipe(readable, unpipeInfo) {
         debug("onunpipe");
         if (readable === src) {
           if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
             unpipeInfo.hasUnpiped = true;
             cleanup();
           }
         }
       }
       function onend() {
         debug("onend");
         dest.end();
       }
       var ondrain = pipeOnDrain(src);
       dest.on("drain", ondrain);
       var cleanedUp = false;
       function cleanup() {
         debug("cleanup");
         dest.removeListener("close", onclose);
         dest.removeListener("finish", onfinish);
         dest.removeListener("drain", ondrain);
         dest.removeListener("error", onerror);
         dest.removeListener("unpipe", onunpipe);
         src.removeListener("end", onend);
         src.removeListener("end", unpipe);
         src.removeListener("data", ondata);
         cleanedUp = true;
         if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
           ondrain();
       }
       src.on("data", ondata);
       function ondata(chunk) {
         debug("ondata");
         var ret = dest.write(chunk);
         debug("dest.write", ret);
         if (ret === false) {
           if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
             debug("false write response, pause", state.awaitDrain);
             state.awaitDrain++;
           }
           src.pause();
         }
       }
       function onerror(er) {
         debug("onerror", er);
         unpipe();
         dest.removeListener("error", onerror);
         if (EElistenerCount(dest, "error") === 0)
           errorOrDestroy(dest, er);
       }
       prependListener(dest, "error", onerror);
       function onclose() {
         dest.removeListener("finish", onfinish);
         unpipe();
       }
       dest.once("close", onclose);
       function onfinish() {
         debug("onfinish");
         dest.removeListener("close", onclose);
         unpipe();
       }
       dest.once("finish", onfinish);
       function unpipe() {
         debug("unpipe");
         src.unpipe(dest);
       }
       dest.emit("pipe", src);
       if (!state.flowing) {
         debug("pipe resume");
         src.resume();
       }
       return dest;
     };
     function pipeOnDrain(src) {
       return function pipeOnDrainFunctionResult() {
         var state = src._readableState;
         debug("pipeOnDrain", state.awaitDrain);
         if (state.awaitDrain)
           state.awaitDrain--;
         if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
           state.flowing = true;
           flow(src);
         }
       };
     }
     Readable.prototype.unpipe = function(dest) {
       var state = this._readableState;
       var unpipeInfo = {
         hasUnpiped: false
       };
       if (state.pipesCount === 0)
         return this;
       if (state.pipesCount === 1) {
         if (dest && dest !== state.pipes)
           return this;
         if (!dest)
           dest = state.pipes;
         state.pipes = null;
         state.pipesCount = 0;
         state.flowing = false;
         if (dest)
           dest.emit("unpipe", this, unpipeInfo);
         return this;
       }
       if (!dest) {
         var dests = state.pipes;
         var len = state.pipesCount;
         state.pipes = null;
         state.pipesCount = 0;
         state.flowing = false;
         for (var i = 0; i < len; i++) {
           dests[i].emit("unpipe", this, {
             hasUnpiped: false
           });
         }
         return this;
       }
       var index = indexOf(state.pipes, dest);
       if (index === -1)
         return this;
       state.pipes.splice(index, 1);
       state.pipesCount -= 1;
       if (state.pipesCount === 1)
         state.pipes = state.pipes[0];
       dest.emit("unpipe", this, unpipeInfo);
       return this;
     };
     Readable.prototype.on = function(ev, fn) {
       var res = Stream.prototype.on.call(this, ev, fn);
       var state = this._readableState;
       if (ev === "data") {
         state.readableListening = this.listenerCount("readable") > 0;
         if (state.flowing !== false)
           this.resume();
       } else if (ev === "readable") {
         if (!state.endEmitted && !state.readableListening) {
           state.readableListening = state.needReadable = true;
           state.flowing = false;
           state.emittedReadable = false;
           debug("on readable", state.length, state.reading);
           if (state.length) {
             emitReadable(this);
           } else if (!state.reading) {
             process.nextTick(nReadingNextTick, this);
           }
         }
       }
       return res;
     };
     Readable.prototype.addListener = Readable.prototype.on;
     Readable.prototype.removeListener = function(ev, fn) {
       var res = Stream.prototype.removeListener.call(this, ev, fn);
       if (ev === "readable") {
         process.nextTick(updateReadableListening, this);
       }
       return res;
     };
     Readable.prototype.removeAllListeners = function(ev) {
       var res = Stream.prototype.removeAllListeners.apply(this, arguments);
       if (ev === "readable" || ev === void 0) {
         process.nextTick(updateReadableListening, this);
       }
       return res;
     };
     function updateReadableListening(self) {
       var state = self._readableState;
       state.readableListening = self.listenerCount("readable") > 0;
       if (state.resumeScheduled && !state.paused) {
         state.flowing = true;
       } else if (self.listenerCount("data") > 0) {
         self.resume();
       }
     }
     function nReadingNextTick(self) {
       debug("readable nexttick read 0");
       self.read(0);
     }
     Readable.prototype.resume = function() {
       var state = this._readableState;
       if (!state.flowing) {
         debug("resume");
         state.flowing = !state.readableListening;
         resume(this, state);
       }
       state.paused = false;
       return this;
     };
     function resume(stream, state) {
       if (!state.resumeScheduled) {
         state.resumeScheduled = true;
         process.nextTick(resume_, stream, state);
       }
     }
     function resume_(stream, state) {
       debug("resume", state.reading);
       if (!state.reading) {
         stream.read(0);
       }
       state.resumeScheduled = false;
       stream.emit("resume");
       flow(stream);
       if (state.flowing && !state.reading)
         stream.read(0);
     }
     Readable.prototype.pause = function() {
       debug("call pause flowing=%j", this._readableState.flowing);
       if (this._readableState.flowing !== false) {
         debug("pause");
         this._readableState.flowing = false;
         this.emit("pause");
       }
       this._readableState.paused = true;
       return this;
     };
     function flow(stream) {
       var state = stream._readableState;
       debug("flow", state.flowing);
       while (state.flowing && stream.read() !== null) {
         ;
       }
     }
     Readable.prototype.wrap = function(stream) {
       var _this = this;
       var state = this._readableState;
       var paused = false;
       stream.on("end", function() {
         debug("wrapped end");
         if (state.decoder && !state.ended) {
           var chunk = state.decoder.end();
           if (chunk && chunk.length)
             _this.push(chunk);
         }
         _this.push(null);
       });
       stream.on("data", function(chunk) {
         debug("wrapped data");
         if (state.decoder)
           chunk = state.decoder.write(chunk);
         if (state.objectMode && (chunk === null || chunk === void 0))
           return;
         else if (!state.objectMode && (!chunk || !chunk.length))
           return;
         var ret = _this.push(chunk);
         if (!ret) {
           paused = true;
           stream.pause();
         }
       });
       for (var i in stream) {
         if (this[i] === void 0 && typeof stream[i] === "function") {
           this[i] = function methodWrap(method) {
             return function methodWrapReturnFunction() {
               return stream[method].apply(stream, arguments);
             };
           }(i);
         }
       }
       for (var n = 0; n < kProxyEvents.length; n++) {
         stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
       }
       this._read = function(n2) {
         debug("wrapped _read", n2);
         if (paused) {
           paused = false;
           stream.resume();
         }
       };
       return this;
     };
     if (typeof Symbol === "function") {
       Readable.prototype[Symbol.asyncIterator] = function() {
         if (createReadableStreamAsyncIterator === void 0) {
           createReadableStreamAsyncIterator = require_async_iterator();
         }
         return createReadableStreamAsyncIterator(this);
       };
     }
     Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
       enumerable: false,
       get: function get() {
         return this._readableState.highWaterMark;
       }
     });
     Object.defineProperty(Readable.prototype, "readableBuffer", {
       enumerable: false,
       get: function get() {
         return this._readableState && this._readableState.buffer;
       }
     });
     Object.defineProperty(Readable.prototype, "readableFlowing", {
       enumerable: false,
       get: function get() {
         return this._readableState.flowing;
       },
       set: function set(state) {
         if (this._readableState) {
           this._readableState.flowing = state;
         }
       }
     });
     Readable._fromList = fromList;
     Object.defineProperty(Readable.prototype, "readableLength", {
       enumerable: false,
       get: function get() {
         return this._readableState.length;
       }
     });
     function fromList(n, state) {
       if (state.length === 0)
         return null;
       var ret;
       if (state.objectMode)
         ret = state.buffer.shift();
       else if (!n || n >= state.length) {
         if (state.decoder)
           ret = state.buffer.join("");
         else if (state.buffer.length === 1)
           ret = state.buffer.first();
         else
           ret = state.buffer.concat(state.length);
         state.buffer.clear();
       } else {
         ret = state.buffer.consume(n, state.decoder);
       }
       return ret;
     }
     function endReadable(stream) {
       var state = stream._readableState;
       debug("endReadable", state.endEmitted);
       if (!state.endEmitted) {
         state.ended = true;
         process.nextTick(endReadableNT, state, stream);
       }
     }
     function endReadableNT(state, stream) {
       debug("endReadableNT", state.endEmitted, state.length);
       if (!state.endEmitted && state.length === 0) {
         state.endEmitted = true;
         stream.readable = false;
         stream.emit("end");
         if (state.autoDestroy) {
           var wState = stream._writableState;
           if (!wState || wState.autoDestroy && wState.finished) {
             stream.destroy();
           }
         }
       }
     }
     if (typeof Symbol === "function") {
       Readable.from = function(iterable, opts) {
         if (from === void 0) {
           from = require_from();
         }
         return from(Readable, iterable, opts);
       };
     }
     function indexOf(xs, x) {
       for (var i = 0, l = xs.length; i < l; i++) {
         if (xs[i] === x)
           return i;
       }
       return -1;
     }
   }
 });
 
 // node_modules/readable-stream/lib/_stream_transform.js
 var require_stream_transform = __commonJS({
   "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
     "use strict";
     module2.exports = Transform;
     var _require$codes = require_errors().codes;
     var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
     var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
     var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
     var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
     var Duplex = require_stream_duplex();
     require_inherits()(Transform, Duplex);
     function afterTransform(er, data) {
       var ts = this._transformState;
       ts.transforming = false;
       var cb = ts.writecb;
       if (cb === null) {
         return this.emit("error", new ERR_MULTIPLE_CALLBACK());
       }
       ts.writechunk = null;
       ts.writecb = null;
       if (data != null)
         this.push(data);
       cb(er);
       var rs = this._readableState;
       rs.reading = false;
       if (rs.needReadable || rs.length < rs.highWaterMark) {
         this._read(rs.highWaterMark);
       }
     }
     function Transform(options) {
       if (!(this instanceof Transform))
         return new Transform(options);
       Duplex.call(this, options);
       this._transformState = {
         afterTransform: afterTransform.bind(this),
         needTransform: false,
         transforming: false,
         writecb: null,
         writechunk: null,
         writeencoding: null
       };
       this._readableState.needReadable = true;
       this._readableState.sync = false;
       if (options) {
         if (typeof options.transform === "function")
           this._transform = options.transform;
         if (typeof options.flush === "function")
           this._flush = options.flush;
       }
       this.on("prefinish", prefinish);
     }
     function prefinish() {
       var _this = this;
       if (typeof this._flush === "function" && !this._readableState.destroyed) {
         this._flush(function(er, data) {
           done(_this, er, data);
         });
       } else {
         done(this, null, null);
       }
     }
     Transform.prototype.push = function(chunk, encoding) {
       this._transformState.needTransform = false;
       return Duplex.prototype.push.call(this, chunk, encoding);
     };
     Transform.prototype._transform = function(chunk, encoding, cb) {
       cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
     };
     Transform.prototype._write = function(chunk, encoding, cb) {
       var ts = this._transformState;
       ts.writecb = cb;
       ts.writechunk = chunk;
       ts.writeencoding = encoding;
       if (!ts.transforming) {
         var rs = this._readableState;
         if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
           this._read(rs.highWaterMark);
       }
     };
     Transform.prototype._read = function(n) {
       var ts = this._transformState;
       if (ts.writechunk !== null && !ts.transforming) {
         ts.transforming = true;
         this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
       } else {
         ts.needTransform = true;
       }
     };
     Transform.prototype._destroy = function(err, cb) {
       Duplex.prototype._destroy.call(this, err, function(err2) {
         cb(err2);
       });
     };
     function done(stream, er, data) {
       if (er)
         return stream.emit("error", er);
       if (data != null)
         stream.push(data);
       if (stream._writableState.length)
         throw new ERR_TRANSFORM_WITH_LENGTH_0();
       if (stream._transformState.transforming)
         throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
       return stream.push(null);
     }
   }
 });
 
 // node_modules/readable-stream/lib/_stream_passthrough.js
 var require_stream_passthrough = __commonJS({
   "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
     "use strict";
     module2.exports = PassThrough;
     var Transform = require_stream_transform();
     require_inherits()(PassThrough, Transform);
     function PassThrough(options) {
       if (!(this instanceof PassThrough))
         return new PassThrough(options);
       Transform.call(this, options);
     }
     PassThrough.prototype._transform = function(chunk, encoding, cb) {
       cb(null, chunk);
     };
   }
 });
 
 // node_modules/readable-stream/lib/internal/streams/pipeline.js
 var require_pipeline = __commonJS({
   "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
     "use strict";
     var eos;
     function once(callback) {
       var called = false;
       return function() {
         if (called)
           return;
         called = true;
         callback.apply(void 0, arguments);
       };
     }
     var _require$codes = require_errors().codes;
     var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
     var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
     function noop2(err) {
       if (err)
         throw err;
     }
     function isRequest(stream) {
       return stream.setHeader && typeof stream.abort === "function";
     }
     function destroyer(stream, reading, writing, callback) {
       callback = once(callback);
       var closed = false;
       stream.on("close", function() {
         closed = true;
       });
       if (eos === void 0)
         eos = require_end_of_stream();
       eos(stream, {
         readable: reading,
         writable: writing
       }, function(err) {
         if (err)
           return callback(err);
         closed = true;
         callback();
       });
       var destroyed = false;
       return function(err) {
         if (closed)
           return;
         if (destroyed)
           return;
         destroyed = true;
         if (isRequest(stream))
           return stream.abort();
         if (typeof stream.destroy === "function")
           return stream.destroy();
         callback(err || new ERR_STREAM_DESTROYED("pipe"));
       };
     }
     function call(fn) {
       fn();
     }
     function pipe(from, to) {
       return from.pipe(to);
     }
     function popCallback(streams) {
       if (!streams.length)
         return noop2;
       if (typeof streams[streams.length - 1] !== "function")
         return noop2;
       return streams.pop();
     }
     function pipeline() {
       for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
         streams[_key] = arguments[_key];
       }
       var callback = popCallback(streams);
       if (Array.isArray(streams[0]))
         streams = streams[0];
       if (streams.length < 2) {
         throw new ERR_MISSING_ARGS("streams");
       }
       var error;
       var destroys = streams.map(function(stream, i) {
         var reading = i < streams.length - 1;
         var writing = i > 0;
         return destroyer(stream, reading, writing, function(err) {
           if (!error)
             error = err;
           if (err)
             destroys.forEach(call);
           if (reading)
             return;
           destroys.forEach(call);
           callback(error);
         });
       });
       return streams.reduce(pipe);
     }
     module2.exports = pipeline;
   }
 });
 
 // node_modules/readable-stream/readable.js
 var require_readable = __commonJS({
   "node_modules/readable-stream/readable.js"(exports, module2) {
     var Stream = require("stream");
     if (process.env.READABLE_STREAM === "disable" && Stream) {
       module2.exports = Stream.Readable;
       Object.assign(module2.exports, Stream);
       module2.exports.Stream = Stream;
     } else {
       exports = module2.exports = require_stream_readable();
       exports.Stream = Stream || exports;
       exports.Readable = exports;
       exports.Writable = require_stream_writable();
       exports.Duplex = require_stream_duplex();
       exports.Transform = require_stream_transform();
       exports.PassThrough = require_stream_passthrough();
       exports.finished = require_end_of_stream();
       exports.pipeline = require_pipeline();
     }
   }
 });
 
 // node_modules/err-code/index.js
 var require_err_code = __commonJS({
   "node_modules/err-code/index.js"(exports, module2) {
     "use strict";
     function assign(obj, props) {
       for (const key in props) {
         Object.defineProperty(obj, key, {
           value: props[key],
           enumerable: true,
           configurable: true
         });
       }
       return obj;
     }
     function createError(err, code, props) {
       if (!err || typeof err === "string") {
         throw new TypeError("Please pass an Error to err-code");
       }
       if (!props) {
         props = {};
       }
       if (typeof code === "object") {
         props = code;
         code = "";
       }
       if (code) {
         props.code = code;
       }
       try {
         return assign(err, props);
       } catch (_) {
         props.message = err.message;
         props.stack = err.stack;
         const ErrClass = function() {
         };
         ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
         const output = assign(new ErrClass(), props);
         return output;
       }
     }
     module2.exports = createError;
   }
 });
 
 // node_modules/simple-peer/index.js
 var require_simple_peer = __commonJS({
   "node_modules/simple-peer/index.js"(exports, module2) {
     var debug = require_src()("simple-peer");
     var getBrowserRTC = require_get_browser_rtc();
     var randombytes2 = require_randombytes();
     var stream = require_readable();
     var queueMicrotask3 = require_queue_microtask();
     var errCode = require_err_code();
     var { Buffer: Buffer2 } = require("buffer");
     var MAX_BUFFERED_AMOUNT = 64 * 1024;
     var ICECOMPLETE_TIMEOUT = 5 * 1e3;
     var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
     function filterTrickle(sdp) {
       return sdp.replace(/a=ice-options:trickle\s\n/g, "");
     }
     function warn(message) {
       console.warn(message);
     }
     var Peer = class extends stream.Duplex {
       constructor(opts) {
         opts = Object.assign({
           allowHalfOpen: false
         }, opts);
         super(opts);
         this._id = randombytes2(4).toString("hex").slice(0, 7);
         this._debug("new peer %o", opts);
         this.channelName = opts.initiator ? opts.channelName || randombytes2(20).toString("hex") : null;
         this.initiator = opts.initiator || false;
         this.channelConfig = opts.channelConfig || Peer.channelConfig;
         this.channelNegotiated = this.channelConfig.negotiated;
         this.config = Object.assign({}, Peer.config, opts.config);
         this.offerOptions = opts.offerOptions || {};
         this.answerOptions = opts.answerOptions || {};
         this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
         this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
         this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
         this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
         this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
         this.destroyed = false;
         this.destroying = false;
         this._connected = false;
         this.remoteAddress = void 0;
         this.remoteFamily = void 0;
         this.remotePort = void 0;
         this.localAddress = void 0;
         this.localFamily = void 0;
         this.localPort = void 0;
         this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
         if (!this._wrtc) {
           if (typeof window === "undefined") {
             throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
           } else {
             throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
           }
         }
         this._pcReady = false;
         this._channelReady = false;
         this._iceComplete = false;
         this._iceCompleteTimer = null;
         this._channel = null;
         this._pendingCandidates = [];
         this._isNegotiating = false;
         this._firstNegotiation = true;
         this._batchedNegotiation = false;
         this._queuedNegotiation = false;
         this._sendersAwaitingStable = [];
         this._senderMap = /* @__PURE__ */ new Map();
         this._closingInterval = null;
         this._remoteTracks = [];
         this._remoteStreams = [];
         this._chunk = null;
         this._cb = null;
         this._interval = null;
         try {
           this._pc = new this._wrtc.RTCPeerConnection(this.config);
         } catch (err) {
           this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
           return;
         }
         this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
         this._pc.oniceconnectionstatechange = () => {
           this._onIceStateChange();
         };
         this._pc.onicegatheringstatechange = () => {
           this._onIceStateChange();
         };
         this._pc.onconnectionstatechange = () => {
           this._onConnectionStateChange();
         };
         this._pc.onsignalingstatechange = () => {
           this._onSignalingStateChange();
         };
         this._pc.onicecandidate = (event) => {
           this._onIceCandidate(event);
         };
         if (typeof this._pc.peerIdentity === "object") {
           this._pc.peerIdentity.catch((err) => {
             this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
           });
         }
         if (this.initiator || this.channelNegotiated) {
           this._setupData({
             channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
           });
         } else {
           this._pc.ondatachannel = (event) => {
             this._setupData(event);
           };
         }
         if (this.streams) {
           this.streams.forEach((stream2) => {
             this.addStream(stream2);
           });
         }
         this._pc.ontrack = (event) => {
           this._onTrack(event);
         };
         this._debug("initial negotiation");
         this._needsNegotiation();
         this._onFinishBound = () => {
           this._onFinish();
         };
         this.once("finish", this._onFinishBound);
       }
       get bufferSize() {
         return this._channel && this._channel.bufferedAmount || 0;
       }
       get connected() {
         return this._connected && this._channel.readyState === "open";
       }
       address() {
         return { port: this.localPort, family: this.localFamily, address: this.localAddress };
       }
       signal(data) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
         if (typeof data === "string") {
           try {
             data = JSON.parse(data);
           } catch (err) {
             data = {};
           }
         }
         this._debug("signal()");
         if (data.renegotiate && this.initiator) {
           this._debug("got request to renegotiate");
           this._needsNegotiation();
         }
         if (data.transceiverRequest && this.initiator) {
           this._debug("got request for transceiver");
           this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
         }
         if (data.candidate) {
           if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
             this._addIceCandidate(data.candidate);
           } else {
             this._pendingCandidates.push(data.candidate);
           }
         }
         if (data.sdp) {
           this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
             if (this.destroyed)
               return;
             this._pendingCandidates.forEach((candidate) => {
               this._addIceCandidate(candidate);
             });
             this._pendingCandidates = [];
             if (this._pc.remoteDescription.type === "offer")
               this._createAnswer();
           }).catch((err) => {
             this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
           });
         }
         if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
           this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
         }
       }
       _addIceCandidate(candidate) {
         const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
         this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
           if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
             warn("Ignoring unsupported ICE candidate.");
           } else {
             this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
           }
         });
       }
       send(chunk) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
         this._channel.send(chunk);
       }
       addTransceiver(kind, init) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
         this._debug("addTransceiver()");
         if (this.initiator) {
           try {
             this._pc.addTransceiver(kind, init);
             this._needsNegotiation();
           } catch (err) {
             this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
           }
         } else {
           this.emit("signal", {
             type: "transceiverRequest",
             transceiverRequest: { kind, init }
           });
         }
       }
       addStream(stream2) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
         this._debug("addStream()");
         stream2.getTracks().forEach((track) => {
           this.addTrack(track, stream2);
         });
       }
       addTrack(track, stream2) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
         this._debug("addTrack()");
         const submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
         let sender = submap.get(stream2);
         if (!sender) {
           sender = this._pc.addTrack(track, stream2);
           submap.set(stream2, sender);
           this._senderMap.set(track, submap);
           this._needsNegotiation();
         } else if (sender.removed) {
           throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
         } else {
           throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
         }
       }
       replaceTrack(oldTrack, newTrack, stream2) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
         this._debug("replaceTrack()");
         const submap = this._senderMap.get(oldTrack);
         const sender = submap ? submap.get(stream2) : null;
         if (!sender) {
           throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
         }
         if (newTrack)
           this._senderMap.set(newTrack, submap);
         if (sender.replaceTrack != null) {
           sender.replaceTrack(newTrack);
         } else {
           this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
         }
       }
       removeTrack(track, stream2) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
         this._debug("removeSender()");
         const submap = this._senderMap.get(track);
         const sender = submap ? submap.get(stream2) : null;
         if (!sender) {
           throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
         }
         try {
           sender.removed = true;
           this._pc.removeTrack(sender);
         } catch (err) {
           if (err.name === "NS_ERROR_UNEXPECTED") {
             this._sendersAwaitingStable.push(sender);
           } else {
             this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
           }
         }
         this._needsNegotiation();
       }
       removeStream(stream2) {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
         this._debug("removeSenders()");
         stream2.getTracks().forEach((track) => {
           this.removeTrack(track, stream2);
         });
       }
       _needsNegotiation() {
         this._debug("_needsNegotiation");
         if (this._batchedNegotiation)
           return;
         this._batchedNegotiation = true;
         queueMicrotask3(() => {
           this._batchedNegotiation = false;
           if (this.initiator || !this._firstNegotiation) {
             this._debug("starting batched negotiation");
             this.negotiate();
           } else {
             this._debug("non-initiator initial negotiation request discarded");
           }
           this._firstNegotiation = false;
         });
       }
       negotiate() {
         if (this.destroying)
           return;
         if (this.destroyed)
           throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
         if (this.initiator) {
           if (this._isNegotiating) {
             this._queuedNegotiation = true;
             this._debug("already negotiating, queueing");
           } else {
             this._debug("start negotiation");
             setTimeout(() => {
               this._createOffer();
             }, 0);
           }
         } else {
           if (this._isNegotiating) {
             this._queuedNegotiation = true;
             this._debug("already negotiating, queueing");
           } else {
             this._debug("requesting negotiation from initiator");
             this.emit("signal", {
               type: "renegotiate",
               renegotiate: true
             });
           }
         }
         this._isNegotiating = true;
       }
       destroy(err) {
         this._destroy(err, () => {
         });
       }
       _destroy(err, cb) {
         if (this.destroyed || this.destroying)
           return;
         this.destroying = true;
         this._debug("destroying (error: %s)", err && (err.message || err));
         queueMicrotask3(() => {
           this.destroyed = true;
           this.destroying = false;
           this._debug("destroy (error: %s)", err && (err.message || err));
           this.readable = this.writable = false;
           if (!this._readableState.ended)
             this.push(null);
           if (!this._writableState.finished)
             this.end();
           this._connected = false;
           this._pcReady = false;
           this._channelReady = false;
           this._remoteTracks = null;
           this._remoteStreams = null;
           this._senderMap = null;
           clearInterval(this._closingInterval);
           this._closingInterval = null;
           clearInterval(this._interval);
           this._interval = null;
           this._chunk = null;
           this._cb = null;
           if (this._onFinishBound)
             this.removeListener("finish", this._onFinishBound);
           this._onFinishBound = null;
           if (this._channel) {
             try {
               this._channel.close();
             } catch (err2) {
             }
             this._channel.onmessage = null;
             this._channel.onopen = null;
             this._channel.onclose = null;
             this._channel.onerror = null;
           }
           if (this._pc) {
             try {
               this._pc.close();
             } catch (err2) {
             }
             this._pc.oniceconnectionstatechange = null;
             this._pc.onicegatheringstatechange = null;
             this._pc.onsignalingstatechange = null;
             this._pc.onicecandidate = null;
             this._pc.ontrack = null;
             this._pc.ondatachannel = null;
           }
           this._pc = null;
           this._channel = null;
           if (err)
             this.emit("error", err);
           this.emit("close");
           cb();
         });
       }
       _setupData(event) {
         if (!event.channel) {
           return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
         }
         this._channel = event.channel;
         this._channel.binaryType = "arraybuffer";
         if (typeof this._channel.bufferedAmountLowThreshold === "number") {
           this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
         }
         this.channelName = this._channel.label;
         this._channel.onmessage = (event2) => {
           this._onChannelMessage(event2);
         };
         this._channel.onbufferedamountlow = () => {
           this._onChannelBufferedAmountLow();
         };
         this._channel.onopen = () => {
           this._onChannelOpen();
         };
         this._channel.onclose = () => {
           this._onChannelClose();
         };
         this._channel.onerror = (event2) => {
           const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
           this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
         };
         let isClosing = false;
         this._closingInterval = setInterval(() => {
           if (this._channel && this._channel.readyState === "closing") {
             if (isClosing)
               this._onChannelClose();
             isClosing = true;
           } else {
             isClosing = false;
           }
         }, CHANNEL_CLOSING_TIMEOUT);
       }
       _read() {
       }
       _write(chunk, encoding, cb) {
         if (this.destroyed)
           return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
         if (this._connected) {
           try {
             this.send(chunk);
           } catch (err) {
             return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
           }
           if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
             this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
             this._cb = cb;
           } else {
             cb(null);
           }
         } else {
           this._debug("write before connect");
           this._chunk = chunk;
           this._cb = cb;
         }
       }
       _onFinish() {
         if (this.destroyed)
           return;
         const destroySoon = () => {
           setTimeout(() => this.destroy(), 1e3);
         };
         if (this._connected) {
           destroySoon();
         } else {
           this.once("connect", destroySoon);
         }
       }
       _startIceCompleteTimeout() {
         if (this.destroyed)
           return;
         if (this._iceCompleteTimer)
           return;
         this._debug("started iceComplete timeout");
         this._iceCompleteTimer = setTimeout(() => {
           if (!this._iceComplete) {
             this._iceComplete = true;
             this._debug("iceComplete timeout completed");
             this.emit("iceTimeout");
             this.emit("_iceComplete");
           }
         }, this.iceCompleteTimeout);
       }
       _createOffer() {
         if (this.destroyed)
           return;
         this._pc.createOffer(this.offerOptions).then((offer) => {
           if (this.destroyed)
             return;
           if (!this.trickle && !this.allowHalfTrickle)
             offer.sdp = filterTrickle(offer.sdp);
           offer.sdp = this.sdpTransform(offer.sdp);
           const sendOffer = () => {
             if (this.destroyed)
               return;
             const signal = this._pc.localDescription || offer;
             this._debug("signal");
             this.emit("signal", {
               type: signal.type,
               sdp: signal.sdp
             });
           };
           const onSuccess = () => {
             this._debug("createOffer success");
             if (this.destroyed)
               return;
             if (this.trickle || this._iceComplete)
               sendOffer();
             else
               this.once("_iceComplete", sendOffer);
           };
           const onError = (err) => {
             this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
           };
           this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
         }).catch((err) => {
           this.destroy(errCode(err, "ERR_CREATE_OFFER"));
         });
       }
       _requestMissingTransceivers() {
         if (this._pc.getTransceivers) {
           this._pc.getTransceivers().forEach((transceiver) => {
             if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
               transceiver.requested = true;
               this.addTransceiver(transceiver.sender.track.kind);
             }
           });
         }
       }
       _createAnswer() {
         if (this.destroyed)
           return;
         this._pc.createAnswer(this.answerOptions).then((answer) => {
           if (this.destroyed)
             return;
           if (!this.trickle && !this.allowHalfTrickle)
             answer.sdp = filterTrickle(answer.sdp);
           answer.sdp = this.sdpTransform(answer.sdp);
           const sendAnswer = () => {
             if (this.destroyed)
               return;
             const signal = this._pc.localDescription || answer;
             this._debug("signal");
             this.emit("signal", {
               type: signal.type,
               sdp: signal.sdp
             });
             if (!this.initiator)
               this._requestMissingTransceivers();
           };
           const onSuccess = () => {
             if (this.destroyed)
               return;
             if (this.trickle || this._iceComplete)
               sendAnswer();
             else
               this.once("_iceComplete", sendAnswer);
           };
           const onError = (err) => {
             this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
           };
           this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
         }).catch((err) => {
           this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
         });
       }
       _onConnectionStateChange() {
         if (this.destroyed)
           return;
         if (this._pc.connectionState === "failed") {
           this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
         }
       }
       _onIceStateChange() {
         if (this.destroyed)
           return;
         const iceConnectionState = this._pc.iceConnectionState;
         const iceGatheringState = this._pc.iceGatheringState;
         this._debug(
           "iceStateChange (connection: %s) (gathering: %s)",
           iceConnectionState,
           iceGatheringState
         );
         this.emit("iceStateChange", iceConnectionState, iceGatheringState);
         if (iceConnectionState === "connected" || iceConnectionState === "completed") {
           this._pcReady = true;
           this._maybeReady();
         }
         if (iceConnectionState === "failed") {
           this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
         }
         if (iceConnectionState === "closed") {
           this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
         }
       }
       getStats(cb) {
         const flattenValues = (report) => {
           if (Object.prototype.toString.call(report.values) === "[object Array]") {
             report.values.forEach((value) => {
               Object.assign(report, value);
             });
           }
           return report;
         };
         if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
           this._pc.getStats().then((res) => {
             const reports = [];
             res.forEach((report) => {
               reports.push(flattenValues(report));
             });
             cb(null, reports);
           }, (err) => cb(err));
         } else if (this._pc.getStats.length > 0) {
           this._pc.getStats((res) => {
             if (this.destroyed)
               return;
             const reports = [];
             res.result().forEach((result) => {
               const report = {};
               result.names().forEach((name) => {
                 report[name] = result.stat(name);
               });
               report.id = result.id;
               report.type = result.type;
               report.timestamp = result.timestamp;
               reports.push(flattenValues(report));
             });
             cb(null, reports);
           }, (err) => cb(err));
         } else {
           cb(null, []);
         }
       }
       _maybeReady() {
         this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
         if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
           return;
         this._connecting = true;
         const findCandidatePair = () => {
           if (this.destroyed)
             return;
           this.getStats((err, items) => {
             if (this.destroyed)
               return;
             if (err)
               items = [];
             const remoteCandidates = {};
             const localCandidates = {};
             const candidatePairs = {};
             let foundSelectedCandidatePair = false;
             items.forEach((item) => {
               if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                 remoteCandidates[item.id] = item;
               }
               if (item.type === "localcandidate" || item.type === "local-candidate") {
                 localCandidates[item.id] = item;
               }
               if (item.type === "candidatepair" || item.type === "candidate-pair") {
                 candidatePairs[item.id] = item;
               }
             });
             const setSelectedCandidatePair = (selectedCandidatePair) => {
               foundSelectedCandidatePair = true;
               let local = localCandidates[selectedCandidatePair.localCandidateId];
               if (local && (local.ip || local.address)) {
                 this.localAddress = local.ip || local.address;
                 this.localPort = Number(local.port);
               } else if (local && local.ipAddress) {
                 this.localAddress = local.ipAddress;
                 this.localPort = Number(local.portNumber);
               } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                 local = selectedCandidatePair.googLocalAddress.split(":");
                 this.localAddress = local[0];
                 this.localPort = Number(local[1]);
               }
               if (this.localAddress) {
                 this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
               }
               let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
               if (remote && (remote.ip || remote.address)) {
                 this.remoteAddress = remote.ip || remote.address;
                 this.remotePort = Number(remote.port);
               } else if (remote && remote.ipAddress) {
                 this.remoteAddress = remote.ipAddress;
                 this.remotePort = Number(remote.portNumber);
               } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                 remote = selectedCandidatePair.googRemoteAddress.split(":");
                 this.remoteAddress = remote[0];
                 this.remotePort = Number(remote[1]);
               }
               if (this.remoteAddress) {
                 this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
               }
               this._debug(
                 "connect local: %s:%s remote: %s:%s",
                 this.localAddress,
                 this.localPort,
                 this.remoteAddress,
                 this.remotePort
               );
             };
             items.forEach((item) => {
               if (item.type === "transport" && item.selectedCandidatePairId) {
                 setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
               }
               if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                 setSelectedCandidatePair(item);
               }
             });
             if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
               setTimeout(findCandidatePair, 100);
               return;
             } else {
               this._connecting = false;
               this._connected = true;
             }
             if (this._chunk) {
               try {
                 this.send(this._chunk);
               } catch (err2) {
                 return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
               }
               this._chunk = null;
               this._debug('sent chunk from "write before connect"');
               const cb = this._cb;
               this._cb = null;
               cb(null);
             }
             if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
               this._interval = setInterval(() => this._onInterval(), 150);
               if (this._interval.unref)
                 this._interval.unref();
             }
             this._debug("connect");
             this.emit("connect");
           });
         };
         findCandidatePair();
       }
       _onInterval() {
         if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
           return;
         }
         this._onChannelBufferedAmountLow();
       }
       _onSignalingStateChange() {
         if (this.destroyed)
           return;
         if (this._pc.signalingState === "stable") {
           this._isNegotiating = false;
           this._debug("flushing sender queue", this._sendersAwaitingStable);
           this._sendersAwaitingStable.forEach((sender) => {
             this._pc.removeTrack(sender);
             this._queuedNegotiation = true;
           });
           this._sendersAwaitingStable = [];
           if (this._queuedNegotiation) {
             this._debug("flushing negotiation queue");
             this._queuedNegotiation = false;
             this._needsNegotiation();
           } else {
             this._debug("negotiated");
             this.emit("negotiated");
           }
         }
         this._debug("signalingStateChange %s", this._pc.signalingState);
         this.emit("signalingStateChange", this._pc.signalingState);
       }
       _onIceCandidate(event) {
         if (this.destroyed)
           return;
         if (event.candidate && this.trickle) {
           this.emit("signal", {
             type: "candidate",
             candidate: {
               candidate: event.candidate.candidate,
               sdpMLineIndex: event.candidate.sdpMLineIndex,
               sdpMid: event.candidate.sdpMid
             }
           });
         } else if (!event.candidate && !this._iceComplete) {
           this._iceComplete = true;
           this.emit("_iceComplete");
         }
         if (event.candidate) {
           this._startIceCompleteTimeout();
         }
       }
       _onChannelMessage(event) {
         if (this.destroyed)
           return;
         let data = event.data;
         if (data instanceof ArrayBuffer)
           data = Buffer2.from(data);
         this.push(data);
       }
       _onChannelBufferedAmountLow() {
         if (this.destroyed || !this._cb)
           return;
         this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
         const cb = this._cb;
         this._cb = null;
         cb(null);
       }
       _onChannelOpen() {
         if (this._connected || this.destroyed)
           return;
         this._debug("on channel open");
         this._channelReady = true;
         this._maybeReady();
       }
       _onChannelClose() {
         if (this.destroyed)
           return;
         this._debug("on channel close");
         this.destroy();
       }
       _onTrack(event) {
         if (this.destroyed)
           return;
         event.streams.forEach((eventStream) => {
           this._debug("on track");
           this.emit("track", event.track, eventStream);
           this._remoteTracks.push({
             track: event.track,
             stream: eventStream
           });
           if (this._remoteStreams.some((remoteStream) => {
             return remoteStream.id === eventStream.id;
           }))
             return;
           this._remoteStreams.push(eventStream);
           queueMicrotask3(() => {
             this._debug("on stream");
             this.emit("stream", eventStream);
           });
         });
       }
       _debug() {
         const args = [].slice.call(arguments);
         args[0] = "[" + this._id + "] " + args[0];
         debug.apply(null, args);
       }
     };
     Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
     Peer.config = {
       iceServers: [
         {
           urls: [
             "stun:stun.l.google.com:19302",
             "stun:global.stun.twilio.com:3478"
           ]
         }
       ],
       sdpSemantics: "unified-plan"
     };
     Peer.channelConfig = {};
     module2.exports = Peer;
   }
 });
 
 // node_modules/throughput/index.js
 var require_throughput = __commonJS({
   "node_modules/throughput/index.js"(exports, module2) {
     var maxTick = 65535;
     var resolution = 10;
     var timeDiff = 1e3 / resolution;
     function getTick(start) {
       return (+Date.now() - start) / timeDiff & 65535;
     }
     module2.exports = function(seconds) {
       const start = +Date.now();
       const size = resolution * (seconds || 5);
       const buffer = [0];
       let pointer = 1;
       let last = getTick(start) - 1 & maxTick;
       return function(delta) {
         const tick = getTick(start);
         let dist = tick - last & maxTick;
         if (dist > size)
           dist = size;
         last = tick;
         while (dist--) {
           if (pointer === size)
             pointer = 0;
           buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
           pointer++;
         }
         if (delta)
           buffer[pointer - 1] += delta;
         const top = buffer[pointer - 1];
         const btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
         return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
       };
     };
   }
 });
 
 // node_modules/queue-tick/queue-microtask.js
 var require_queue_microtask2 = __commonJS({
   "node_modules/queue-tick/queue-microtask.js"(exports, module2) {
     module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
   }
 });
 
 // node_modules/queue-tick/process-next-tick.js
 var require_process_next_tick = __commonJS({
   "node_modules/queue-tick/process-next-tick.js"(exports, module2) {
     module2.exports = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : require_queue_microtask2();
   }
 });
 
 // node_modules/fast-fifo/fixed-size.js
 var require_fixed_size = __commonJS({
   "node_modules/fast-fifo/fixed-size.js"(exports, module2) {
     module2.exports = class FixedFIFO {
       constructor(hwm) {
         if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
           throw new Error("Max size for a FixedFIFO should be a power of two");
         this.buffer = new Array(hwm);
         this.mask = hwm - 1;
         this.top = 0;
         this.btm = 0;
         this.next = null;
       }
       push(data) {
         if (this.buffer[this.top] !== void 0)
           return false;
         this.buffer[this.top] = data;
         this.top = this.top + 1 & this.mask;
         return true;
       }
       shift() {
         const last = this.buffer[this.btm];
         if (last === void 0)
           return void 0;
         this.buffer[this.btm] = void 0;
         this.btm = this.btm + 1 & this.mask;
         return last;
       }
       peek() {
         return this.buffer[this.btm];
       }
       isEmpty() {
         return this.buffer[this.btm] === void 0;
       }
     };
   }
 });
 
 // node_modules/fast-fifo/index.js
 var require_fast_fifo = __commonJS({
   "node_modules/fast-fifo/index.js"(exports, module2) {
     var FixedFIFO = require_fixed_size();
     module2.exports = class FastFIFO {
       constructor(hwm) {
         this.hwm = hwm || 16;
         this.head = new FixedFIFO(this.hwm);
         this.tail = this.head;
       }
       push(val) {
         if (!this.head.push(val)) {
           const prev = this.head;
           this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
           this.head.push(val);
         }
       }
       shift() {
         const val = this.tail.shift();
         if (val === void 0 && this.tail.next) {
           const next = this.tail.next;
           this.tail.next = null;
           this.tail = next;
           return this.tail.shift();
         }
         return val;
       }
       peek() {
         return this.tail.peek();
       }
       isEmpty() {
         return this.head.isEmpty();
       }
     };
   }
 });
 
 // node_modules/streamx/index.js
 var require_streamx = __commonJS({
   "node_modules/streamx/index.js"(exports, module2) {
     var { EventEmitter } = require("events");
     var STREAM_DESTROYED = new Error("Stream was destroyed");
     var PREMATURE_CLOSE = new Error("Premature close");
     var queueTick = require_process_next_tick();
     var FIFO = require_fast_fifo();
     var MAX = (1 << 25) - 1;
     var OPENING = 1;
     var DESTROYING = 2;
     var DESTROYED = 4;
     var NOT_OPENING = MAX ^ OPENING;
     var READ_ACTIVE = 1 << 3;
     var READ_PRIMARY = 2 << 3;
     var READ_SYNC = 4 << 3;
     var READ_QUEUED = 8 << 3;
     var READ_RESUMED = 16 << 3;
     var READ_PIPE_DRAINED = 32 << 3;
     var READ_ENDING = 64 << 3;
     var READ_EMIT_DATA = 128 << 3;
     var READ_EMIT_READABLE = 256 << 3;
     var READ_EMITTED_READABLE = 512 << 3;
     var READ_DONE = 1024 << 3;
     var READ_NEXT_TICK = 2049 << 3;
     var READ_NEEDS_PUSH = 4096 << 3;
     var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
     var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
     var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
     var READ_NOT_SYNC = MAX ^ READ_SYNC;
     var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
     var READ_PAUSED = MAX ^ READ_RESUMED;
     var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
     var READ_NOT_ENDING = MAX ^ READ_ENDING;
     var READ_PIPE_NOT_DRAINED = MAX ^ (READ_RESUMED | READ_PIPE_DRAINED);
     var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
     var WRITE_ACTIVE = 1 << 16;
     var WRITE_PRIMARY = 2 << 16;
     var WRITE_SYNC = 4 << 16;
     var WRITE_QUEUED = 8 << 16;
     var WRITE_UNDRAINED = 16 << 16;
     var WRITE_DONE = 32 << 16;
     var WRITE_EMIT_DRAIN = 64 << 16;
     var WRITE_NEXT_TICK = 129 << 16;
     var WRITE_FINISHING = 256 << 16;
     var WRITE_NOT_ACTIVE = MAX ^ WRITE_ACTIVE;
     var WRITE_NOT_SYNC = MAX ^ WRITE_SYNC;
     var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
     var WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
     var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
     var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
     var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
     var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
     var NOT_ACTIVE = MAX ^ ACTIVE;
     var DONE = READ_DONE | WRITE_DONE;
     var DESTROY_STATUS = DESTROYING | DESTROYED;
     var OPEN_STATUS = DESTROY_STATUS | OPENING;
     var AUTO_DESTROY = DESTROY_STATUS | DONE;
     var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
     var TICKING = (WRITE_NEXT_TICK | READ_NEXT_TICK) & NOT_ACTIVE;
     var ACTIVE_OR_TICKING = ACTIVE | TICKING;
     var IS_OPENING = OPEN_STATUS | TICKING;
     var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
     var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
     var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
     var READ_ACTIVE_AND_SYNC = READ_ACTIVE | READ_SYNC;
     var READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH = READ_ACTIVE | READ_SYNC | READ_NEEDS_PUSH;
     var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
     var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
     var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
     var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
     var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH;
     var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
     var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
     var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
     var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
     var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
     var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;
     var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
     var WRITE_ACTIVE_AND_SYNC = WRITE_ACTIVE | WRITE_SYNC;
     var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
     var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
     var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
     var WritableState = class {
       constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
         this.stream = stream;
         this.queue = new FIFO();
         this.highWaterMark = highWaterMark;
         this.buffered = 0;
         this.error = null;
         this.pipeline = null;
         this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
         this.map = mapWritable || map;
         this.afterWrite = afterWrite.bind(this);
         this.afterUpdateNextTick = updateWriteNT.bind(this);
       }
       get ended() {
         return (this.stream._duplexState & WRITE_DONE) !== 0;
       }
       push(data) {
         if (this.map !== null)
           data = this.map(data);
         this.buffered += this.byteLength(data);
         this.queue.push(data);
         if (this.buffered < this.highWaterMark) {
           this.stream._duplexState |= WRITE_QUEUED;
           return true;
         }
         this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
         return false;
       }
       shift() {
         const data = this.queue.shift();
         const stream = this.stream;
         this.buffered -= this.byteLength(data);
         if (this.buffered === 0)
           stream._duplexState &= WRITE_NOT_QUEUED;
         return data;
       }
       end(data) {
         if (typeof data === "function")
           this.stream.once("finish", data);
         else if (data !== void 0 && data !== null)
           this.push(data);
         this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
       }
       autoBatch(data, cb) {
         const buffer = [];
         const stream = this.stream;
         buffer.push(data);
         while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
           buffer.push(stream._writableState.shift());
         }
         if ((stream._duplexState & OPEN_STATUS) !== 0)
           return cb(null);
         stream._writev(buffer, cb);
       }
       update() {
         const stream = this.stream;
         while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
           const data = this.shift();
           stream._duplexState |= WRITE_ACTIVE_AND_SYNC;
           stream._write(data, this.afterWrite);
           stream._duplexState &= WRITE_NOT_SYNC;
         }
         if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
           this.updateNonPrimary();
       }
       updateNonPrimary() {
         const stream = this.stream;
         if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
           stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;
           stream._final(afterFinal.bind(this));
           return;
         }
         if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
           if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
             stream._duplexState |= ACTIVE;
             stream._destroy(afterDestroy.bind(this));
           }
           return;
         }
         if ((stream._duplexState & IS_OPENING) === OPENING) {
           stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
           stream._open(afterOpen.bind(this));
         }
       }
       updateNextTick() {
         if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
           return;
         this.stream._duplexState |= WRITE_NEXT_TICK;
         queueTick(this.afterUpdateNextTick);
       }
     };
     var ReadableState = class {
       constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
         this.stream = stream;
         this.queue = new FIFO();
         this.highWaterMark = highWaterMark;
         this.buffered = 0;
         this.error = null;
         this.pipeline = null;
         this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
         this.map = mapReadable || map;
         this.pipeTo = null;
         this.afterRead = afterRead.bind(this);
         this.afterUpdateNextTick = updateReadNT.bind(this);
       }
       get ended() {
         return (this.stream._duplexState & READ_DONE) !== 0;
       }
       pipe(pipeTo, cb) {
         if (this.pipeTo !== null)
           throw new Error("Can only pipe to one destination");
         if (typeof cb !== "function")
           cb = null;
         this.stream._duplexState |= READ_PIPE_DRAINED;
         this.pipeTo = pipeTo;
         this.pipeline = new Pipeline(this.stream, pipeTo, cb);
         if (cb)
           this.stream.on("error", noop2);
         if (isStreamx(pipeTo)) {
           pipeTo._writableState.pipeline = this.pipeline;
           if (cb)
             pipeTo.on("error", noop2);
           pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
         } else {
           const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
           const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
           pipeTo.on("error", onerror);
           pipeTo.on("close", onclose);
           pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
         }
         pipeTo.on("drain", afterDrain.bind(this));
         this.stream.emit("piping", pipeTo);
         pipeTo.emit("pipe", this.stream);
       }
       push(data) {
         const stream = this.stream;
         if (data === null) {
           this.highWaterMark = 0;
           stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
           return false;
         }
         if (this.map !== null)
           data = this.map(data);
         this.buffered += this.byteLength(data);
         this.queue.push(data);
         stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
         return this.buffered < this.highWaterMark;
       }
       shift() {
         const data = this.queue.shift();
         this.buffered -= this.byteLength(data);
         if (this.buffered === 0)
           this.stream._duplexState &= READ_NOT_QUEUED;
         return data;
       }
       unshift(data) {
         let tail;
         const pending = [];
         while ((tail = this.queue.shift()) !== void 0) {
           pending.push(tail);
         }
         this.push(data);
         for (let i = 0; i < pending.length; i++) {
           this.queue.push(pending[i]);
         }
       }
       read() {
         const stream = this.stream;
         if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
           const data = this.shift();
           if (this.pipeTo !== null && this.pipeTo.write(data) === false)
             stream._duplexState &= READ_PIPE_NOT_DRAINED;
           if ((stream._duplexState & READ_EMIT_DATA) !== 0)
             stream.emit("data", data);
           return data;
         }
         return null;
       }
       drain() {
         const stream = this.stream;
         while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
           const data = this.shift();
           if (this.pipeTo !== null && this.pipeTo.write(data) === false)
             stream._duplexState &= READ_PIPE_NOT_DRAINED;
           if ((stream._duplexState & READ_EMIT_DATA) !== 0)
             stream.emit("data", data);
         }
       }
       update() {
         const stream = this.stream;
         this.drain();
         while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {
           stream._duplexState |= READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH;
           stream._read(this.afterRead);
           stream._duplexState &= READ_NOT_SYNC;
           if ((stream._duplexState & READ_ACTIVE) === 0)
             this.drain();
         }
         if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
           stream._duplexState |= READ_EMITTED_READABLE;
           stream.emit("readable");
         }
         if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
           this.updateNonPrimary();
       }
       updateNonPrimary() {
         const stream = this.stream;
         if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
           stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
           stream.emit("end");
           if ((stream._duplexState & AUTO_DESTROY) === DONE)
             stream._duplexState |= DESTROYING;
           if (this.pipeTo !== null)
             this.pipeTo.end();
         }
         if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
           if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
             stream._duplexState |= ACTIVE;
             stream._destroy(afterDestroy.bind(this));
           }
           return;
         }
         if ((stream._duplexState & IS_OPENING) === OPENING) {
           stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
           stream._open(afterOpen.bind(this));
         }
       }
       updateNextTick() {
         if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
           return;
         this.stream._duplexState |= READ_NEXT_TICK;
         queueTick(this.afterUpdateNextTick);
       }
     };
     var TransformState = class {
       constructor(stream) {
         this.data = null;
         this.afterTransform = afterTransform.bind(stream);
         this.afterFinal = null;
       }
     };
     var Pipeline = class {
       constructor(src, dst, cb) {
         this.from = src;
         this.to = dst;
         this.afterPipe = cb;
         this.error = null;
         this.pipeToFinished = false;
       }
       finished() {
         this.pipeToFinished = true;
       }
       done(stream, err) {
         if (err)
           this.error = err;
         if (stream === this.to) {
           this.to = null;
           if (this.from !== null) {
             if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
               this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
             }
             return;
           }
         }
         if (stream === this.from) {
           this.from = null;
           if (this.to !== null) {
             if ((stream._duplexState & READ_DONE) === 0) {
               this.to.destroy(this.error || new Error("Readable stream closed before ending"));
             }
             return;
           }
         }
         if (this.afterPipe !== null)
           this.afterPipe(this.error);
         this.to = this.from = this.afterPipe = null;
       }
     };
     function afterDrain() {
       this.stream._duplexState |= READ_PIPE_DRAINED;
       if ((this.stream._duplexState & READ_ACTIVE_AND_SYNC) === 0)
         this.updateNextTick();
       else
         this.drain();
     }
     function afterFinal(err) {
       const stream = this.stream;
       if (err)
         stream.destroy(err);
       if ((stream._duplexState & DESTROY_STATUS) === 0) {
         stream._duplexState |= WRITE_DONE;
         stream.emit("finish");
       }
       if ((stream._duplexState & AUTO_DESTROY) === DONE) {
         stream._duplexState |= DESTROYING;
       }
       stream._duplexState &= WRITE_NOT_ACTIVE;
       this.update();
     }
     function afterDestroy(err) {
       const stream = this.stream;
       if (!err && this.error !== STREAM_DESTROYED)
         err = this.error;
       if (err)
         stream.emit("error", err);
       stream._duplexState |= DESTROYED;
       stream.emit("close");
       const rs = stream._readableState;
       const ws = stream._writableState;
       if (rs !== null && rs.pipeline !== null)
         rs.pipeline.done(stream, err);
       if (ws !== null && ws.pipeline !== null)
         ws.pipeline.done(stream, err);
     }
     function afterWrite(err) {
       const stream = this.stream;
       if (err)
         stream.destroy(err);
       stream._duplexState &= WRITE_NOT_ACTIVE;
       if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
         stream._duplexState &= WRITE_DRAINED;
         if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
           stream.emit("drain");
         }
       }
       if ((stream._duplexState & WRITE_SYNC) === 0)
         this.update();
     }
     function afterRead(err) {
       if (err)
         this.stream.destroy(err);
       this.stream._duplexState &= READ_NOT_ACTIVE;
       if ((this.stream._duplexState & READ_SYNC) === 0)
         this.update();
     }
     function updateReadNT() {
       this.stream._duplexState &= READ_NOT_NEXT_TICK;
       this.update();
     }
     function updateWriteNT() {
       this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
       this.update();
     }
     function afterOpen(err) {
       const stream = this.stream;
       if (err)
         stream.destroy(err);
       if ((stream._duplexState & DESTROYING) === 0) {
         if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
           stream._duplexState |= READ_PRIMARY;
         if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
           stream._duplexState |= WRITE_PRIMARY;
         stream.emit("open");
       }
       stream._duplexState &= NOT_ACTIVE;
       if (stream._writableState !== null) {
         stream._writableState.update();
       }
       if (stream._readableState !== null) {
         stream._readableState.update();
       }
     }
     function afterTransform(err, data) {
       if (data !== void 0 && data !== null)
         this.push(data);
       this._writableState.afterWrite(err);
     }
     var Stream = class extends EventEmitter {
       constructor(opts) {
         super();
         this._duplexState = 0;
         this._readableState = null;
         this._writableState = null;
         if (opts) {
           if (opts.open)
             this._open = opts.open;
           if (opts.destroy)
             this._destroy = opts.destroy;
           if (opts.predestroy)
             this._predestroy = opts.predestroy;
           if (opts.signal) {
             opts.signal.addEventListener("abort", abort.bind(this));
           }
         }
       }
       _open(cb) {
         cb(null);
       }
       _destroy(cb) {
         cb(null);
       }
       _predestroy() {
       }
       get readable() {
         return this._readableState !== null ? true : void 0;
       }
       get writable() {
         return this._writableState !== null ? true : void 0;
       }
       get destroyed() {
         return (this._duplexState & DESTROYED) !== 0;
       }
       get destroying() {
         return (this._duplexState & DESTROY_STATUS) !== 0;
       }
       destroy(err) {
         if ((this._duplexState & DESTROY_STATUS) === 0) {
           if (!err)
             err = STREAM_DESTROYED;
           this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
           if (this._readableState !== null) {
             this._readableState.error = err;
             this._readableState.updateNextTick();
           }
           if (this._writableState !== null) {
             this._writableState.error = err;
             this._writableState.updateNextTick();
           }
           this._predestroy();
         }
       }
       on(name, fn) {
         if (this._readableState !== null) {
           if (name === "data") {
             this._duplexState |= READ_EMIT_DATA | READ_RESUMED;
             this._readableState.updateNextTick();
           }
           if (name === "readable") {
             this._duplexState |= READ_EMIT_READABLE;
             this._readableState.updateNextTick();
           }
         }
         if (this._writableState !== null) {
           if (name === "drain") {
             this._duplexState |= WRITE_EMIT_DRAIN;
             this._writableState.updateNextTick();
           }
         }
         return super.on(name, fn);
       }
     };
     var Readable = class extends Stream {
       constructor(opts) {
         super(opts);
         this._duplexState |= OPENING | WRITE_DONE;
         this._readableState = new ReadableState(this, opts);
         if (opts) {
           if (opts.read)
             this._read = opts.read;
           if (opts.eagerOpen)
             this.resume().pause();
         }
       }
       _read(cb) {
         cb(null);
       }
       pipe(dest, cb) {
         this._readableState.pipe(dest, cb);
         this._readableState.updateNextTick();
         return dest;
       }
       read() {
         this._readableState.updateNextTick();
         return this._readableState.read();
       }
       push(data) {
         this._readableState.updateNextTick();
         return this._readableState.push(data);
       }
       unshift(data) {
         this._readableState.updateNextTick();
         return this._readableState.unshift(data);
       }
       resume() {
         this._duplexState |= READ_RESUMED;
         this._readableState.updateNextTick();
         return this;
       }
       pause() {
         this._duplexState &= READ_PAUSED;
         return this;
       }
       static _fromAsyncIterator(ite, opts) {
         let destroy;
         const rs = new Readable({
           ...opts,
           read(cb) {
             ite.next().then(push).then(cb.bind(null, null)).catch(cb);
           },
           predestroy() {
             destroy = ite.return();
           },
           destroy(cb) {
             if (!destroy)
               return cb(null);
             destroy.then(cb.bind(null, null)).catch(cb);
           }
         });
         return rs;
         function push(data) {
           if (data.done)
             rs.push(null);
           else
             rs.push(data.value);
         }
       }
       static from(data, opts) {
         if (isReadStreamx(data))
           return data;
         if (data[asyncIterator])
           return this._fromAsyncIterator(data[asyncIterator](), opts);
         if (!Array.isArray(data))
           data = data === void 0 ? [] : [data];
         let i = 0;
         return new Readable({
           ...opts,
           read(cb) {
             this.push(i === data.length ? null : data[i++]);
             cb(null);
           }
         });
       }
       static isBackpressured(rs) {
         return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
       }
       static isPaused(rs) {
         return (rs._duplexState & READ_RESUMED) === 0;
       }
       [asyncIterator]() {
         const stream = this;
         let error = null;
         let promiseResolve = null;
         let promiseReject = null;
         this.on("error", (err) => {
           error = err;
         });
         this.on("readable", onreadable);
         this.on("close", onclose);
         return {
           [asyncIterator]() {
             return this;
           },
           next() {
             return new Promise(function(resolve, reject) {
               promiseResolve = resolve;
               promiseReject = reject;
               const data = stream.read();
               if (data !== null)
                 ondata(data);
               else if ((stream._duplexState & DESTROYED) !== 0)
                 ondata(null);
             });
           },
           return() {
             return destroy(null);
           },
           throw(err) {
             return destroy(err);
           }
         };
         function onreadable() {
           if (promiseResolve !== null)
             ondata(stream.read());
         }
         function onclose() {
           if (promiseResolve !== null)
             ondata(null);
         }
         function ondata(data) {
           if (promiseReject === null)
             return;
           if (error)
             promiseReject(error);
           else if (data === null && (stream._duplexState & READ_DONE) === 0)
             promiseReject(STREAM_DESTROYED);
           else
             promiseResolve({ value: data, done: data === null });
           promiseReject = promiseResolve = null;
         }
         function destroy(err) {
           stream.destroy(err);
           return new Promise((resolve, reject) => {
             if (stream._duplexState & DESTROYED)
               return resolve({ value: void 0, done: true });
             stream.once("close", function() {
               if (err)
                 reject(err);
               else
                 resolve({ value: void 0, done: true });
             });
           });
         }
       }
     };
     var Writable = class extends Stream {
       constructor(opts) {
         super(opts);
         this._duplexState |= OPENING | READ_DONE;
         this._writableState = new WritableState(this, opts);
         if (opts) {
           if (opts.writev)
             this._writev = opts.writev;
           if (opts.write)
             this._write = opts.write;
           if (opts.final)
             this._final = opts.final;
         }
       }
       _writev(batch, cb) {
         cb(null);
       }
       _write(data, cb) {
         this._writableState.autoBatch(data, cb);
       }
       _final(cb) {
         cb(null);
       }
       static isBackpressured(ws) {
         return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
       }
       write(data) {
         this._writableState.updateNextTick();
         return this._writableState.push(data);
       }
       end(data) {
         this._writableState.updateNextTick();
         this._writableState.end(data);
         return this;
       }
     };
     var Duplex = class extends Readable {
       constructor(opts) {
         super(opts);
         this._duplexState = OPENING;
         this._writableState = new WritableState(this, opts);
         if (opts) {
           if (opts.writev)
             this._writev = opts.writev;
           if (opts.write)
             this._write = opts.write;
           if (opts.final)
             this._final = opts.final;
         }
       }
       _writev(batch, cb) {
         cb(null);
       }
       _write(data, cb) {
         this._writableState.autoBatch(data, cb);
       }
       _final(cb) {
         cb(null);
       }
       write(data) {
         this._writableState.updateNextTick();
         return this._writableState.push(data);
       }
       end(data) {
         this._writableState.updateNextTick();
         this._writableState.end(data);
         return this;
       }
     };
     var Transform = class extends Duplex {
       constructor(opts) {
         super(opts);
         this._transformState = new TransformState(this);
         if (opts) {
           if (opts.transform)
             this._transform = opts.transform;
           if (opts.flush)
             this._flush = opts.flush;
         }
       }
       _write(data, cb) {
         if (this._readableState.buffered >= this._readableState.highWaterMark) {
           this._transformState.data = data;
         } else {
           this._transform(data, this._transformState.afterTransform);
         }
       }
       _read(cb) {
         if (this._transformState.data !== null) {
           const data = this._transformState.data;
           this._transformState.data = null;
           cb(null);
           this._transform(data, this._transformState.afterTransform);
         } else {
           cb(null);
         }
       }
       _transform(data, cb) {
         cb(null, data);
       }
       _flush(cb) {
         cb(null);
       }
       _final(cb) {
         this._transformState.afterFinal = cb;
         this._flush(transformAfterFlush.bind(this));
       }
     };
     var PassThrough = class extends Transform {
     };
     function transformAfterFlush(err, data) {
       const cb = this._transformState.afterFinal;
       if (err)
         return cb(err);
       if (data !== null && data !== void 0)
         this.push(data);
       this.push(null);
       cb(null);
     }
     function pipelinePromise(...streams) {
       return new Promise((resolve, reject) => {
         return pipeline(...streams, (err) => {
           if (err)
             return reject(err);
           resolve();
         });
       });
     }
     function pipeline(stream, ...streams) {
       const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
       const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
       if (all.length < 2)
         throw new Error("Pipeline requires at least 2 streams");
       let src = all[0];
       let dest = null;
       let error = null;
       for (let i = 1; i < all.length; i++) {
         dest = all[i];
         if (isStreamx(src)) {
           src.pipe(dest, onerror);
         } else {
           errorHandle(src, true, i > 1, onerror);
           src.pipe(dest);
         }
         src = dest;
       }
       if (done) {
         let fin = false;
         dest.on("finish", () => {
           fin = true;
         });
         dest.on("error", (err) => {
           error = error || err;
         });
         dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
       }
       return dest;
       function errorHandle(s, rd, wr, onerror2) {
         s.on("error", onerror2);
         s.on("close", onclose);
         function onclose() {
           if (rd && s._readableState && !s._readableState.ended)
             return onerror2(PREMATURE_CLOSE);
           if (wr && s._writableState && !s._writableState.ended)
             return onerror2(PREMATURE_CLOSE);
         }
       }
       function onerror(err) {
         if (!err || error)
           return;
         error = err;
         for (const s of all) {
           s.destroy(err);
         }
       }
     }
     function isStream(stream) {
       return !!stream._readableState || !!stream._writableState;
     }
     function isStreamx(stream) {
       return typeof stream._duplexState === "number" && isStream(stream);
     }
     function isReadStreamx(stream) {
       return isStreamx(stream) && stream.readable;
     }
     function isTypedArray(data) {
       return typeof data === "object" && data !== null && typeof data.byteLength === "number";
     }
     function defaultByteLength(data) {
       return isTypedArray(data) ? data.byteLength : 1024;
     }
     function noop2() {
     }
     function abort() {
       this.destroy(new Error("Stream aborted."));
     }
     module2.exports = {
       pipeline,
       pipelinePromise,
       isStream,
       isStreamx,
       Stream,
       Writable,
       Readable,
       Duplex,
       Transform,
       PassThrough
     };
   }
 });
 
 // node_modules/speed-limiter/lib/utils.js
 var require_utils = __commonJS({
   "node_modules/speed-limiter/lib/utils.js"(exports, module2) {
     function wait(time) {
       return new Promise((resolve) => setTimeout(resolve, time));
     }
     module2.exports = {
       wait
     };
   }
 });
 
 // node_modules/limiter/lib/tokenBucket.js
 var require_tokenBucket = __commonJS({
   "node_modules/limiter/lib/tokenBucket.js"(exports, module2) {
     var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
       this.bucketSize = bucketSize;
       this.tokensPerInterval = tokensPerInterval;
       if (typeof interval === "string") {
         switch (interval) {
           case "sec":
           case "second":
             this.interval = 1e3;
             break;
           case "min":
           case "minute":
             this.interval = 1e3 * 60;
             break;
           case "hr":
           case "hour":
             this.interval = 1e3 * 60 * 60;
             break;
           case "day":
             this.interval = 1e3 * 60 * 60 * 24;
             break;
           default:
             throw new Error("Invaid interval " + interval);
         }
       } else {
         this.interval = interval;
       }
       this.parentBucket = parentBucket;
       this.content = 0;
       this.lastDrip = +new Date();
     };
     TokenBucket.prototype = {
       bucketSize: 1,
       tokensPerInterval: 1,
       interval: 1e3,
       parentBucket: null,
       content: 0,
       lastDrip: 0,
       removeTokens: function(count, callback) {
         var self = this;
         if (!this.bucketSize) {
           process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
           return true;
         }
         if (count > this.bucketSize) {
           process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds bucket size " + this.bucketSize, null));
           return false;
         }
         this.drip();
         if (count > this.content)
           return comeBackLater();
         if (this.parentBucket) {
           return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
             if (err)
               return callback(err, null);
             if (count > self.content)
               return comeBackLater();
             self.content -= count;
             callback(null, Math.min(remainingTokens, self.content));
           });
         } else {
           this.content -= count;
           process.nextTick(callback.bind(null, null, this.content));
           return true;
         }
         function comeBackLater() {
           var waitInterval = Math.ceil(
             (count - self.content) * (self.interval / self.tokensPerInterval)
           );
           setTimeout(function() {
             self.removeTokens(count, callback);
           }, waitInterval);
           return false;
         }
       },
       tryRemoveTokens: function(count) {
         if (!this.bucketSize)
           return true;
         if (count > this.bucketSize)
           return false;
         this.drip();
         if (count > this.content)
           return false;
         if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
           return false;
         this.content -= count;
         return true;
       },
       drip: function() {
         if (!this.tokensPerInterval) {
           this.content = this.bucketSize;
           return;
         }
         var now = +new Date();
         var deltaMS = Math.max(now - this.lastDrip, 0);
         this.lastDrip = now;
         var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
         this.content = Math.min(this.content + dripAmount, this.bucketSize);
       }
     };
     module2.exports = TokenBucket;
   }
 });
 
 // node_modules/limiter/lib/clock.js
 var require_clock = __commonJS({
   "node_modules/limiter/lib/clock.js"(exports, module2) {
     var getMilliseconds = function() {
       if (typeof process !== "undefined" && process.hrtime) {
         var hrtime = process.hrtime();
         var seconds = hrtime[0];
         var nanoseconds = hrtime[1];
         return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
       }
       return new Date().getTime();
     };
     module2.exports = getMilliseconds;
   }
 });
 
 // node_modules/limiter/lib/rateLimiter.js
 var require_rateLimiter = __commonJS({
   "node_modules/limiter/lib/rateLimiter.js"(exports, module2) {
     var TokenBucket = require_tokenBucket();
     var getMilliseconds = require_clock();
     var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
       this.tokenBucket = new TokenBucket(
         tokensPerInterval,
         tokensPerInterval,
         interval,
         null
       );
       this.tokenBucket.content = tokensPerInterval;
       this.curIntervalStart = getMilliseconds();
       this.tokensThisInterval = 0;
       this.fireImmediately = fireImmediately;
     };
     RateLimiter.prototype = {
       tokenBucket: null,
       curIntervalStart: 0,
       tokensThisInterval: 0,
       fireImmediately: false,
       removeTokens: function(count, callback) {
         if (count > this.tokenBucket.bucketSize) {
           process.nextTick(callback.bind(
             null,
             "Requested tokens " + count + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
             null
           ));
           return false;
         }
         var self = this;
         var now = getMilliseconds();
         if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
           this.curIntervalStart = now;
           this.tokensThisInterval = 0;
         }
         if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
           if (this.fireImmediately) {
             process.nextTick(callback.bind(null, null, -1));
           } else {
             var waitInterval = Math.ceil(
               this.curIntervalStart + this.tokenBucket.interval - now
             );
             setTimeout(function() {
               self.tokenBucket.removeTokens(count, afterTokensRemoved);
             }, waitInterval);
           }
           return false;
         }
         return this.tokenBucket.removeTokens(count, afterTokensRemoved);
         function afterTokensRemoved(err, tokensRemaining) {
           if (err)
             return callback(err, null);
           self.tokensThisInterval += count;
           callback(null, tokensRemaining);
         }
       },
       tryRemoveTokens: function(count) {
         if (count > this.tokenBucket.bucketSize)
           return false;
         var now = getMilliseconds();
         if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
           this.curIntervalStart = now;
           this.tokensThisInterval = 0;
         }
         if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
           return false;
         var removed = this.tokenBucket.tryRemoveTokens(count);
         if (removed) {
           this.tokensThisInterval += count;
         }
         return removed;
       },
       getTokensRemaining: function() {
         this.tokenBucket.drip();
         return this.tokenBucket.content;
       }
     };
     module2.exports = RateLimiter;
   }
 });
 
 // node_modules/limiter/index.js
 var require_limiter = __commonJS({
   "node_modules/limiter/index.js"(exports) {
     exports.RateLimiter = require_rateLimiter();
     exports.TokenBucket = require_tokenBucket();
   }
 });
 
 // node_modules/speed-limiter/lib/throttle-group.js
 var require_throttle_group = __commonJS({
   "node_modules/speed-limiter/lib/throttle-group.js"(exports, module2) {
     var { TokenBucket } = require_limiter();
     var Throttle = require_throttle();
     var ThrottleGroup = class {
       constructor(opts = {}) {
         if (typeof opts !== "object")
           throw new Error("Options must be an object");
         this.throttles = [];
         this.setEnabled(opts.enabled);
         this.setRate(opts.rate, opts.chunksize);
       }
       getEnabled() {
         return this._enabled;
       }
       getRate() {
         return this.bucket.tokensPerInterval;
       }
       getChunksize() {
         return this.chunksize;
       }
       setEnabled(val = true) {
         if (typeof val !== "boolean")
           throw new Error("Enabled must be a boolean");
         this._enabled = val;
         for (const throttle of this.throttles) {
           throttle.setEnabled(val);
         }
       }
       setRate(rate, chunksize = null) {
         if (!Number.isInteger(rate) || rate < 0)
           throw new Error("Rate must be an integer bigger than zero");
         rate = parseInt(rate);
         if (chunksize && (typeof chunksize !== "number" || chunksize <= 0))
           throw new Error("Chunksize must be bigger than zero");
         chunksize = chunksize || Math.max(parseInt(rate / 10), 1);
         chunksize = parseInt(chunksize);
         if (rate > 0 && chunksize > rate)
           throw new Error("Chunk size must be smaller than rate");
         if (!this.bucket)
           this.bucket = new TokenBucket(rate, rate, "second", null);
         this.bucket.bucketSize = rate;
         this.bucket.tokensPerInterval = rate;
         this.chunksize = chunksize;
       }
       setChunksize(chunksize) {
         if (!Number.isInteger(chunksize) || chunksize <= 0)
           throw new Error("Chunk size must be an integer bigger than zero");
         const rate = this.getRate();
         chunksize = parseInt(chunksize);
         if (rate > 0 && chunksize > rate)
           throw new Error("Chunk size must be smaller than rate");
         this.chunksize = chunksize;
       }
       throttle(opts = {}) {
         if (typeof opts !== "object")
           throw new Error("Options must be an object");
         const newThrottle = new Throttle({
           ...opts,
           group: this
         });
         return newThrottle;
       }
       destroy() {
         for (const throttle of this.throttles) {
           throttle.destroy();
         }
         this.throttles = [];
       }
       _addThrottle(throttle) {
         if (!(throttle instanceof Throttle))
           throw new Error("Throttle must be an instance of Throttle");
         this.throttles.push(throttle);
       }
       _removeThrottle(throttle) {
         const index = this.throttles.indexOf(throttle);
         if (index > -1)
           this.throttles.splice(index, 1);
       }
     };
     module2.exports = ThrottleGroup;
   }
 });
 
 // node_modules/speed-limiter/lib/throttle.js
 var require_throttle = __commonJS({
   "node_modules/speed-limiter/lib/throttle.js"(exports, module2) {
     var { EventEmitter } = require("events");
     var { Transform } = require_streamx();
     var { wait } = require_utils();
     var Throttle = class extends Transform {
       constructor(opts = {}) {
         super();
         if (typeof opts !== "object")
           throw new Error("Options must be an object");
         const params = Object.assign({}, opts);
         if (params.group && !(params.group instanceof ThrottleGroup))
           throw new Error("Group must be an instanece of ThrottleGroup");
         else if (!params.group)
           params.group = new ThrottleGroup(params);
         this._setEnabled(params.enabled || params.group.enabled);
         this._group = params.group;
         this._emitter = new EventEmitter();
         this._destroyed = false;
         this._group._addThrottle(this);
       }
       getEnabled() {
         return this._enabled;
       }
       getGroup() {
         return this._group;
       }
       _setEnabled(val = true) {
         if (typeof val !== "boolean")
           throw new Error("Enabled must be a boolean");
         this._enabled = val;
       }
       setEnabled(val) {
         this._setEnabled(val);
         if (this._enabled)
           this._emitter.emit("enabled");
         else
           this._emitter.emit("disabled");
       }
       _transform(chunk, done) {
         this._processChunk(chunk, done);
       }
       async _waitForTokens(amount) {
         return new Promise((resolve, reject) => {
           let done = false;
           const self = this;
           function isDone(err) {
             self._emitter.removeListener("disabled", isDone);
             self._emitter.removeListener("destroyed", isDone);
             if (done)
               return;
             done = true;
             if (err)
               return reject(err);
             resolve();
           }
           this._emitter.once("disabled", isDone);
           this._emitter.once("destroyed", isDone);
           this._group.bucket.removeTokens(amount, isDone);
         });
       }
       _areBothEnabled() {
         return this._enabled && this._group.getEnabled();
       }
       async _processChunk(chunk, done) {
         if (!this._areBothEnabled())
           return done(null, chunk);
         let pos = 0;
         let chunksize = this._group.getChunksize();
         let slice = chunk.slice(pos, pos + chunksize);
         while (slice.length > 0) {
           if (this._areBothEnabled()) {
             try {
               while (this._group.getRate() === 0 && !this._destroyed && this._areBothEnabled()) {
                 await wait(1e3);
                 if (this._destroyed)
                   return;
               }
               if (this._areBothEnabled() && !this._group.bucket.tryRemoveTokens(slice.length)) {
                 await this._waitForTokens(slice.length);
                 if (this._destroyed)
                   return;
               }
             } catch (err) {
               return done(err);
             }
           }
           this.push(slice);
           pos += chunksize;
           chunksize = this._areBothEnabled() ? this._group.getChunksize() : chunk.length - pos;
           slice = chunk.slice(pos, pos + chunksize);
         }
         return done();
       }
       destroy(...args) {
         this._group._removeThrottle(this);
         this._destroyed = true;
         this._emitter.emit("destroyed");
         super.destroy(...args);
       }
     };
     module2.exports = Throttle;
     var ThrottleGroup = require_throttle_group();
   }
 });
 
 // node_modules/speed-limiter/index.js
 var require_speed_limiter = __commonJS({
   "node_modules/speed-limiter/index.js"(exports, module2) {
     var Throttle = require_throttle();
     var ThrottleGroup = require_throttle_group();
     module2.exports = {
       Throttle,
       ThrottleGroup
     };
   }
 });
 
 // node_modules/unordered-array-remove/index.js
 var require_unordered_array_remove = __commonJS({
   "node_modules/unordered-array-remove/index.js"(exports, module2) {
     module2.exports = remove;
     function remove(arr, i) {
       if (i >= arr.length || i < 0)
         return;
       var last = arr.pop();
       if (i < arr.length) {
         var tmp = arr[i];
         arr[i] = last;
         return tmp;
       }
       return last;
     }
   }
 });
 
 // node_modules/bitfield/lib/index.js
 var require_lib2 = __commonJS({
   "node_modules/bitfield/lib/index.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     function getByteSize(num) {
       var out = num >> 3;
       if (num % 8 !== 0)
         out++;
       return out;
     }
     var BitField = function() {
       function BitField2(data, opts) {
         if (data === void 0) {
           data = 0;
         }
         var grow = opts === null || opts === void 0 ? void 0 : opts.grow;
         this.grow = grow && isFinite(grow) && getByteSize(grow) || grow || 0;
         this.buffer = typeof data === "number" ? new Uint8Array(getByteSize(data)) : data;
       }
       BitField2.prototype.get = function(i) {
         var j = i >> 3;
         return j < this.buffer.length && !!(this.buffer[j] & 128 >> i % 8);
       };
       BitField2.prototype.set = function(i, value) {
         if (value === void 0) {
           value = true;
         }
         var j = i >> 3;
         if (value) {
           if (this.buffer.length < j + 1) {
             var length = Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow));
             if (length <= this.grow) {
               var newBuffer = new Uint8Array(length);
               newBuffer.set(this.buffer);
               this.buffer = newBuffer;
             }
           }
           this.buffer[j] |= 128 >> i % 8;
         } else if (j < this.buffer.length) {
           this.buffer[j] &= ~(128 >> i % 8);
         }
       };
       BitField2.prototype.forEach = function(fn, start, end) {
         if (start === void 0) {
           start = 0;
         }
         if (end === void 0) {
           end = this.buffer.length * 8;
         }
         for (var i = start, j = i >> 3, y = 128 >> i % 8, byte = this.buffer[j]; i < end; i++) {
           fn(!!(byte & y), i);
           y = y === 1 ? (byte = this.buffer[++j], 128) : y >> 1;
         }
       };
       return BitField2;
     }();
     exports.default = BitField;
   }
 });
 
 // node_modules/speedometer/index.js
 var require_speedometer = __commonJS({
   "node_modules/speedometer/index.js"(exports, module2) {
     var tick = 1;
     var maxTick = 65535;
     var resolution = 4;
     var timer;
     var inc = function() {
       tick = tick + 1 & maxTick;
     };
     module2.exports = function(seconds) {
       if (!timer) {
         timer = setInterval(inc, 1e3 / resolution | 0);
         if (timer.unref)
           timer.unref();
       }
       var size = resolution * (seconds || 5);
       var buffer = [0];
       var pointer = 1;
       var last = tick - 1 & maxTick;
       return function(delta) {
         var dist = tick - last & maxTick;
         if (dist > size)
           dist = size;
         last = tick;
         while (dist--) {
           if (pointer === size)
             pointer = 0;
           buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
           pointer++;
         }
         if (delta)
           buffer[pointer - 1] += delta;
         var top = buffer[pointer - 1];
         var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
         return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
       };
     };
   }
 });
 
 // node_modules/rc4/rc4.js
 var require_rc4 = __commonJS({
   "node_modules/rc4/rc4.js"(exports, module2) {
     "use strict";
     function isInteger(n) {
       return parseInt(n, 10) === n;
     }
     function createRC4(N) {
       function identityPermutation() {
         var s = new Array(N);
         for (var i = 0; i < N; i++) {
           s[i] = i;
         }
         return s;
       }
       function seed(key) {
         if (key === void 0) {
           key = new Array(N);
           for (var k = 0; k < N; k++) {
             key[k] = Math.floor(Math.random() * N);
           }
         } else if (typeof key === "string") {
           key = "" + key;
           key = key.split("").map(function(c) {
             return c.charCodeAt(0) % N;
           });
         } else if (Array.isArray(key)) {
           if (!key.every(function(v) {
             return typeof v === "number" && v === (v | 0);
           })) {
             throw new TypeError("invalid seed key specified: not array of integers");
           }
         } else {
           throw new TypeError("invalid seed key specified");
         }
         var keylen = key.length;
         var s = identityPermutation();
         var j = 0;
         for (var i = 0; i < N; i++) {
           j = (j + s[i] + key[i % keylen]) % N;
           var tmp = s[i];
           s[i] = s[j];
           s[j] = tmp;
         }
         return s;
       }
       function RC42(key) {
         this.s = seed(key);
         this.i = 0;
         this.j = 0;
       }
       RC42.prototype.randomNative = function() {
         this.i = (this.i + 1) % N;
         this.j = (this.j + this.s[this.i]) % N;
         var tmp = this.s[this.i];
         this.s[this.i] = this.s[this.j];
         this.s[this.j] = tmp;
         var k = this.s[(this.s[this.i] + this.s[this.j]) % N];
         return k;
       };
       RC42.prototype.randomUInt32 = function() {
         var a = this.randomByte();
         var b = this.randomByte();
         var c = this.randomByte();
         var d = this.randomByte();
         return ((a * 256 + b) * 256 + c) * 256 + d;
       };
       RC42.prototype.randomFloat = function() {
         return this.randomUInt32() / 4294967296;
       };
       RC42.prototype.random = function() {
         var a;
         var b;
         if (arguments.length === 1) {
           a = 0;
           b = arguments[0];
         } else if (arguments.length === 2) {
           a = arguments[0];
           b = arguments[1];
         } else {
           throw new TypeError("random takes one or two integer arguments");
         }
         if (!isInteger(a) || !isInteger(b)) {
           throw new TypeError("random takes one or two integer arguments");
         }
         return a + this.randomUInt32() % (b - a + 1);
       };
       RC42.prototype.currentState = function() {
         return {
           i: this.i,
           j: this.j,
           s: this.s.slice()
         };
       };
       RC42.prototype.setState = function(state) {
         var s = state.s;
         var i = state.i;
         var j = state.j;
         if (!(i === (i | 0) && 0 <= i && i < N)) {
           throw new Error("state.i should be integer [0, " + (N - 1) + "]");
         }
         if (!(j === (j | 0) && 0 <= j && j < N)) {
           throw new Error("state.j should be integer [0, " + (N - 1) + "]");
         }
         if (!Array.isArray(s) || s.length !== N) {
           throw new Error("state should be array of length " + N);
         }
         for (var k = 0; k < N; k++) {
           if (s.indexOf(k) === -1) {
             throw new Error("state should be permutation of 0.." + (N - 1) + ": " + k + " is missing");
           }
         }
         this.i = i;
         this.j = j;
         this.s = s.slice();
       };
       return RC42;
     }
     var RC4 = createRC4(256);
     RC4.prototype.randomByte = RC4.prototype.randomNative;
     var RC4small = createRC4(16);
     RC4small.prototype.randomByte = function() {
       var a = this.randomNative();
       var b = this.randomNative();
       return a * 16 + b;
     };
     var ordA = "a".charCodeAt(0);
     var ord0 = "0".charCodeAt(0);
     function toHex(n) {
       return n < 10 ? String.fromCharCode(ord0 + n) : String.fromCharCode(ordA + n - 10);
     }
     function fromHex(c) {
       return parseInt(c, 16);
     }
     RC4small.prototype.currentStateString = function() {
       var state = this.currentState();
       var i = toHex(state.i);
       var j = toHex(state.j);
       var res = i + j + state.s.map(toHex).join("");
       return res;
     };
     RC4small.prototype.setStateString = function(stateString) {
       if (!stateString.match(/^[0-9a-f]{18}$/)) {
         throw new TypeError("RC4small stateString should be 18 hex character string");
       }
       var i = fromHex(stateString[0]);
       var j = fromHex(stateString[1]);
       var s = stateString.split("").slice(2).map(fromHex);
       this.setState({
         i,
         j,
         s
       });
     };
     RC4.RC4small = RC4small;
     module2.exports = RC4;
   }
 });
 
 // node_modules/bittorrent-protocol/index.js
 var require_bittorrent_protocol = __commonJS({
   "node_modules/bittorrent-protocol/index.js"(exports, module2) {
     var arrayRemove = require_unordered_array_remove();
     var bencode = require_lib();
     var BitField = require_lib2().default;
     var crypto = require("crypto");
     var debug = require_src()("bittorrent-protocol");
     var randombytes2 = require_randombytes();
     var sha1 = require_simple_sha1();
     var speedometer = require_speedometer();
     var stream = require_readable();
     var RC4 = require_rc4();
     var BITFIELD_GROW = 4e5;
     var KEEP_ALIVE_TIMEOUT = 55e3;
     var ALLOWED_FAST_SET_MAX_LENGTH = 100;
     var MESSAGE_PROTOCOL = Buffer.from("BitTorrent protocol");
     var MESSAGE_KEEP_ALIVE = Buffer.from([0, 0, 0, 0]);
     var MESSAGE_CHOKE = Buffer.from([0, 0, 0, 1, 0]);
     var MESSAGE_UNCHOKE = Buffer.from([0, 0, 0, 1, 1]);
     var MESSAGE_INTERESTED = Buffer.from([0, 0, 0, 1, 2]);
     var MESSAGE_UNINTERESTED = Buffer.from([0, 0, 0, 1, 3]);
     var MESSAGE_RESERVED = [0, 0, 0, 0, 0, 0, 0, 0];
     var MESSAGE_PORT = [0, 0, 0, 3, 9, 0, 0];
     var MESSAGE_HAVE_ALL = Buffer.from([0, 0, 0, 1, 14]);
     var MESSAGE_HAVE_NONE = Buffer.from([0, 0, 0, 1, 15]);
     var DH_PRIME = "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a36210000000000090563";
     var DH_GENERATOR = 2;
     var VC = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);
     var CRYPTO_PROVIDE = Buffer.from([0, 0, 1, 2]);
     var CRYPTO_SELECT = Buffer.from([0, 0, 0, 2]);
     function xor(a, b) {
       for (let len = a.length; len--; )
         a[len] ^= b[len];
       return a;
     }
     var Request = class {
       constructor(piece, offset, length, callback) {
         this.piece = piece;
         this.offset = offset;
         this.length = length;
         this.callback = callback;
       }
     };
     var HaveAllBitField = class {
       constructor() {
         this.buffer = new Uint8Array();
       }
       get(index) {
         return true;
       }
       set(index) {
       }
     };
     var Wire = class extends stream.Duplex {
       constructor(type = null, retries = 0, peEnabled = false) {
         super();
         this._debugId = randombytes2(4).toString("hex");
         this._debug("new wire");
         this.peerId = null;
         this.peerIdBuffer = null;
         this.type = type;
         this.amChoking = true;
         this.amInterested = false;
         this.peerChoking = true;
         this.peerInterested = false;
         this.peerPieces = new BitField(0, { grow: BITFIELD_GROW });
         this.extensions = {};
         this.peerExtensions = {};
         this.requests = [];
         this.peerRequests = [];
         this.extendedMapping = {};
         this.peerExtendedMapping = {};
         this.extendedHandshake = {};
         this.peerExtendedHandshake = {};
         this.hasFast = false;
         this.allowedFastSet = [];
         this.peerAllowedFastSet = [];
         this._ext = {};
         this._nextExt = 1;
         this.uploaded = 0;
         this.downloaded = 0;
         this.uploadSpeed = speedometer();
         this.downloadSpeed = speedometer();
         this._keepAliveInterval = null;
         this._timeout = null;
         this._timeoutMs = 0;
         this._timeoutExpiresAt = null;
         this.destroyed = false;
         this._finished = false;
         this._parserSize = 0;
         this._parser = null;
         this._buffer = [];
         this._bufferSize = 0;
         this._peEnabled = peEnabled;
         if (peEnabled) {
           this._dh = crypto.createDiffieHellman(DH_PRIME, "hex", DH_GENERATOR);
           this._myPubKey = this._dh.generateKeys("hex");
         } else {
           this._myPubKey = null;
         }
         this._peerPubKey = null;
         this._sharedSecret = null;
         this._peerCryptoProvide = [];
         this._cryptoHandshakeDone = false;
         this._cryptoSyncPattern = null;
         this._waitMaxBytes = null;
         this._encryptionMethod = null;
         this._encryptGenerator = null;
         this._decryptGenerator = null;
         this._setGenerators = false;
         this.once("finish", () => this._onFinish());
         this.on("finish", this._onFinish);
         this._debug("type:", this.type);
         if (this.type === "tcpIncoming" && this._peEnabled) {
           this._determineHandshakeType();
         } else if (this.type === "tcpOutgoing" && this._peEnabled && retries === 0) {
           this._parsePe2();
         } else {
           this._parseHandshake(null);
         }
       }
       setKeepAlive(enable) {
         this._debug("setKeepAlive %s", enable);
         clearInterval(this._keepAliveInterval);
         if (enable === false)
           return;
         this._keepAliveInterval = setInterval(() => {
           this.keepAlive();
         }, KEEP_ALIVE_TIMEOUT);
       }
       setTimeout(ms, unref) {
         this._debug("setTimeout ms=%d unref=%s", ms, unref);
         this._timeoutMs = ms;
         this._timeoutUnref = !!unref;
         this._resetTimeout(true);
       }
       destroy() {
         if (this.destroyed)
           return;
         this.destroyed = true;
         this._debug("destroy");
         this.emit("close");
         this.end();
         return this;
       }
       end(...args) {
         this._debug("end");
         this._onUninterested();
         this._onChoke();
         return super.end(...args);
       }
       use(Extension) {
         const name = Extension.prototype.name;
         if (!name) {
           throw new Error('Extension class requires a "name" property on the prototype');
         }
         this._debug("use extension.name=%s", name);
         const ext = this._nextExt;
         const handler = new Extension(this);
         function noop2() {
         }
         if (typeof handler.onHandshake !== "function") {
           handler.onHandshake = noop2;
         }
         if (typeof handler.onExtendedHandshake !== "function") {
           handler.onExtendedHandshake = noop2;
         }
         if (typeof handler.onMessage !== "function") {
           handler.onMessage = noop2;
         }
         this.extendedMapping[ext] = name;
         this._ext[name] = handler;
         this[name] = handler;
         this._nextExt += 1;
       }
       keepAlive() {
         this._debug("keep-alive");
         this._push(MESSAGE_KEEP_ALIVE);
       }
       sendPe1() {
         if (this._peEnabled) {
           const padALen = Math.floor(Math.random() * 513);
           const padA = randombytes2(padALen);
           this._push(Buffer.concat([Buffer.from(this._myPubKey, "hex"), padA]));
         }
       }
       sendPe2() {
         const padBLen = Math.floor(Math.random() * 513);
         const padB = randombytes2(padBLen);
         this._push(Buffer.concat([Buffer.from(this._myPubKey, "hex"), padB]));
       }
       sendPe3(infoHash) {
         this.setEncrypt(this._sharedSecret, infoHash);
         const hash1Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex("req1") + this._sharedSecret, "hex")), "hex");
         const hash2Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex("req2") + infoHash, "hex")), "hex");
         const hash3Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex("req3") + this._sharedSecret, "hex")), "hex");
         const hashesXorBuffer = xor(hash2Buffer, hash3Buffer);
         const padCLen = randombytes2(2).readUInt16BE(0) % 512;
         const padCBuffer = randombytes2(padCLen);
         let vcAndProvideBuffer = Buffer.alloc(8 + 4 + 2 + padCLen + 2);
         VC.copy(vcAndProvideBuffer);
         CRYPTO_PROVIDE.copy(vcAndProvideBuffer, 8);
         vcAndProvideBuffer.writeInt16BE(padCLen, 12);
         padCBuffer.copy(vcAndProvideBuffer, 14);
         vcAndProvideBuffer.writeInt16BE(0, 14 + padCLen);
         vcAndProvideBuffer = this._encryptHandshake(vcAndProvideBuffer);
         this._push(Buffer.concat([hash1Buffer, hashesXorBuffer, vcAndProvideBuffer]));
       }
       sendPe4(infoHash) {
         this.setEncrypt(this._sharedSecret, infoHash);
         const padDLen = randombytes2(2).readUInt16BE(0) % 512;
         const padDBuffer = randombytes2(padDLen);
         let vcAndSelectBuffer = Buffer.alloc(8 + 4 + 2 + padDLen);
         VC.copy(vcAndSelectBuffer);
         CRYPTO_SELECT.copy(vcAndSelectBuffer, 8);
         vcAndSelectBuffer.writeInt16BE(padDLen, 12);
         padDBuffer.copy(vcAndSelectBuffer, 14);
         vcAndSelectBuffer = this._encryptHandshake(vcAndSelectBuffer);
         this._push(vcAndSelectBuffer);
         this._cryptoHandshakeDone = true;
         this._debug("completed crypto handshake");
       }
       handshake(infoHash, peerId, extensions) {
         let infoHashBuffer;
         let peerIdBuffer;
         if (typeof infoHash === "string") {
           infoHash = infoHash.toLowerCase();
           infoHashBuffer = Buffer.from(infoHash, "hex");
         } else {
           infoHashBuffer = infoHash;
           infoHash = infoHashBuffer.toString("hex");
         }
         if (typeof peerId === "string") {
           peerIdBuffer = Buffer.from(peerId, "hex");
         } else {
           peerIdBuffer = peerId;
           peerId = peerIdBuffer.toString("hex");
         }
         this._infoHash = infoHashBuffer;
         if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
           throw new Error("infoHash and peerId MUST have length 20");
         }
         this._debug("handshake i=%s p=%s exts=%o", infoHash, peerId, extensions);
         const reserved = Buffer.from(MESSAGE_RESERVED);
         this.extensions = {
           extended: true,
           dht: !!(extensions && extensions.dht),
           fast: !!(extensions && extensions.fast)
         };
         reserved[5] |= 16;
         if (this.extensions.dht)
           reserved[7] |= 1;
         if (this.extensions.fast)
           reserved[7] |= 4;
         if (this.extensions.fast && this.peerExtensions.fast) {
           this._debug("fast extension is enabled");
           this.hasFast = true;
         }
         this._push(Buffer.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]));
         this._handshakeSent = true;
         if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
           this._sendExtendedHandshake();
         }
       }
       _sendExtendedHandshake() {
         const msg = Object.assign({}, this.extendedHandshake);
         msg.m = {};
         for (const ext in this.extendedMapping) {
           const name = this.extendedMapping[ext];
           msg.m[name] = Number(ext);
         }
         this.extended(0, bencode.encode(msg));
         this._extendedHandshakeSent = true;
       }
       choke() {
         if (this.amChoking)
           return;
         this.amChoking = true;
         this._debug("choke");
         this._push(MESSAGE_CHOKE);
         if (this.hasFast) {
           let allowedCount = 0;
           while (this.peerRequests.length > allowedCount) {
             const request = this.peerRequests[allowedCount];
             if (this.allowedFastSet.includes(request.piece)) {
               ++allowedCount;
             } else {
               this.reject(request.piece, request.offset, request.length);
             }
           }
         } else {
           while (this.peerRequests.length) {
             this.peerRequests.pop();
           }
         }
       }
       unchoke() {
         if (!this.amChoking)
           return;
         this.amChoking = false;
         this._debug("unchoke");
         this._push(MESSAGE_UNCHOKE);
       }
       interested() {
         if (this.amInterested)
           return;
         this.amInterested = true;
         this._debug("interested");
         this._push(MESSAGE_INTERESTED);
       }
       uninterested() {
         if (!this.amInterested)
           return;
         this.amInterested = false;
         this._debug("uninterested");
         this._push(MESSAGE_UNINTERESTED);
       }
       have(index) {
         this._debug("have %d", index);
         this._message(4, [index], null);
       }
       bitfield(bitfield) {
         this._debug("bitfield");
         if (!Buffer.isBuffer(bitfield))
           bitfield = bitfield.buffer;
         this._message(5, [], bitfield);
       }
       request(index, offset, length, cb) {
         if (!cb)
           cb = () => {
           };
         if (this._finished)
           return cb(new Error("wire is closed"));
         if (this.peerChoking && !(this.hasFast && this.peerAllowedFastSet.includes(index))) {
           return cb(new Error("peer is choking"));
         }
         this._debug("request index=%d offset=%d length=%d", index, offset, length);
         this.requests.push(new Request(index, offset, length, cb));
         if (!this._timeout) {
           this._resetTimeout(true);
         }
         this._message(6, [index, offset, length], null);
       }
       piece(index, offset, buffer) {
         this._debug("piece index=%d offset=%d", index, offset);
         this._message(7, [index, offset], buffer);
         this.uploaded += buffer.length;
         this.uploadSpeed(buffer.length);
         this.emit("upload", buffer.length);
       }
       cancel(index, offset, length) {
         this._debug("cancel index=%d offset=%d length=%d", index, offset, length);
         this._callback(
           this._pull(this.requests, index, offset, length),
           new Error("request was cancelled"),
           null
         );
         this._message(8, [index, offset, length], null);
       }
       port(port) {
         this._debug("port %d", port);
         const message = Buffer.from(MESSAGE_PORT);
         message.writeUInt16BE(port, 5);
         this._push(message);
       }
       suggest(index) {
         if (!this.hasFast)
           throw Error("fast extension is disabled");
         this._debug("suggest %d", index);
         this._message(13, [index], null);
       }
       haveAll() {
         if (!this.hasFast)
           throw Error("fast extension is disabled");
         this._debug("have-all");
         this._push(MESSAGE_HAVE_ALL);
       }
       haveNone() {
         if (!this.hasFast)
           throw Error("fast extension is disabled");
         this._debug("have-none");
         this._push(MESSAGE_HAVE_NONE);
       }
       reject(index, offset, length) {
         if (!this.hasFast)
           throw Error("fast extension is disabled");
         this._debug("reject index=%d offset=%d length=%d", index, offset, length);
         this._pull(this.peerRequests, index, offset, length);
         this._message(16, [index, offset, length], null);
       }
       allowedFast(index) {
         if (!this.hasFast)
           throw Error("fast extension is disabled");
         this._debug("allowed-fast %d", index);
         if (!this.allowedFastSet.includes(index))
           this.allowedFastSet.push(index);
         this._message(17, [index], null);
       }
       extended(ext, obj) {
         this._debug("extended ext=%s", ext);
         if (typeof ext === "string" && this.peerExtendedMapping[ext]) {
           ext = this.peerExtendedMapping[ext];
         }
         if (typeof ext === "number") {
           const extId = Buffer.from([ext]);
           const buf = Buffer.isBuffer(obj) ? obj : bencode.encode(obj);
           this._message(20, [], Buffer.concat([extId, buf]));
         } else {
           throw new Error(`Unrecognized extension: ${ext}`);
         }
       }
       setEncrypt(sharedSecret, infoHash) {
         let encryptKey;
         let decryptKey;
         let encryptKeyBuf;
         let encryptKeyIntArray;
         let decryptKeyBuf;
         let decryptKeyIntArray;
         switch (this.type) {
           case "tcpIncoming":
             encryptKey = sha1.sync(Buffer.from(this._utfToHex("keyB") + sharedSecret + infoHash, "hex"));
             decryptKey = sha1.sync(Buffer.from(this._utfToHex("keyA") + sharedSecret + infoHash, "hex"));
             encryptKeyBuf = Buffer.from(encryptKey, "hex");
             encryptKeyIntArray = [];
             for (const value of encryptKeyBuf.values()) {
               encryptKeyIntArray.push(value);
             }
             decryptKeyBuf = Buffer.from(decryptKey, "hex");
             decryptKeyIntArray = [];
             for (const value of decryptKeyBuf.values()) {
               decryptKeyIntArray.push(value);
             }
             this._encryptGenerator = new RC4(encryptKeyIntArray);
             this._decryptGenerator = new RC4(decryptKeyIntArray);
             break;
           case "tcpOutgoing":
             encryptKey = sha1.sync(Buffer.from(this._utfToHex("keyA") + sharedSecret + infoHash, "hex"));
             decryptKey = sha1.sync(Buffer.from(this._utfToHex("keyB") + sharedSecret + infoHash, "hex"));
             encryptKeyBuf = Buffer.from(encryptKey, "hex");
             encryptKeyIntArray = [];
             for (const value of encryptKeyBuf.values()) {
               encryptKeyIntArray.push(value);
             }
             decryptKeyBuf = Buffer.from(decryptKey, "hex");
             decryptKeyIntArray = [];
             for (const value of decryptKeyBuf.values()) {
               decryptKeyIntArray.push(value);
             }
             this._encryptGenerator = new RC4(encryptKeyIntArray);
             this._decryptGenerator = new RC4(decryptKeyIntArray);
             break;
           default:
             return false;
         }
         for (let i = 0; i < 1024; i++) {
           this._encryptGenerator.randomByte();
           this._decryptGenerator.randomByte();
         }
         this._setGenerators = true;
         return true;
       }
       _read() {
       }
       _message(id, numbers, data) {
         const dataLength = data ? data.length : 0;
         const buffer = Buffer.allocUnsafe(5 + 4 * numbers.length);
         buffer.writeUInt32BE(buffer.length + dataLength - 4, 0);
         buffer[4] = id;
         for (let i = 0; i < numbers.length; i++) {
           buffer.writeUInt32BE(numbers[i], 5 + 4 * i);
         }
         this._push(buffer);
         if (data)
           this._push(data);
       }
       _push(data) {
         if (this._finished)
           return;
         if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
           data = this._encrypt(data);
         }
         return this.push(data);
       }
       _onKeepAlive() {
         this._debug("got keep-alive");
         this.emit("keep-alive");
       }
       _onPe1(pubKeyBuffer) {
         this._peerPubKey = pubKeyBuffer.toString("hex");
         this._sharedSecret = this._dh.computeSecret(this._peerPubKey, "hex", "hex");
         this.emit("pe1");
       }
       _onPe2(pubKeyBuffer) {
         this._peerPubKey = pubKeyBuffer.toString("hex");
         this._sharedSecret = this._dh.computeSecret(this._peerPubKey, "hex", "hex");
         this.emit("pe2");
       }
       _onPe3(hashesXorBuffer) {
         const hash3 = sha1.sync(Buffer.from(this._utfToHex("req3") + this._sharedSecret, "hex"));
         const sKeyHash = xor(Buffer.from(hash3, "hex"), hashesXorBuffer).toString("hex");
         this.emit("pe3", sKeyHash);
       }
       _onPe3Encrypted(vcBuffer, peerProvideBuffer) {
         if (!vcBuffer.equals(VC)) {
           this._debug("Error: verification constant did not match");
           this.destroy();
           return;
         }
         for (const provideByte of peerProvideBuffer.values()) {
           if (provideByte !== 0) {
             this._peerCryptoProvide.push(provideByte);
           }
         }
         if (this._peerCryptoProvide.includes(2)) {
           this._encryptionMethod = 2;
         } else {
           this._debug("Error: RC4 encryption method not provided by peer");
           this.destroy();
         }
       }
       _onPe4(peerSelectBuffer) {
         this._encryptionMethod = peerSelectBuffer.readUInt8(3);
         if (!CRYPTO_PROVIDE.includes(this._encryptionMethod)) {
           this._debug("Error: peer selected invalid crypto method");
           this.destroy();
         }
         this._cryptoHandshakeDone = true;
         this._debug("crypto handshake done");
         this.emit("pe4");
       }
       _onHandshake(infoHashBuffer, peerIdBuffer, extensions) {
         const infoHash = infoHashBuffer.toString("hex");
         const peerId = peerIdBuffer.toString("hex");
         this._debug("got handshake i=%s p=%s exts=%o", infoHash, peerId, extensions);
         this.peerId = peerId;
         this.peerIdBuffer = peerIdBuffer;
         this.peerExtensions = extensions;
         if (this.extensions.fast && this.peerExtensions.fast) {
           this._debug("fast extension is enabled");
           this.hasFast = true;
         }
         this.emit("handshake", infoHash, peerId, extensions);
         for (const name in this._ext) {
           this._ext[name].onHandshake(infoHash, peerId, extensions);
         }
         if (extensions.extended && this._handshakeSent && !this._extendedHandshakeSent) {
           this._sendExtendedHandshake();
         }
       }
       _onChoke() {
         this.peerChoking = true;
         this._debug("got choke");
         this.emit("choke");
         if (!this.hasFast) {
           while (this.requests.length) {
             this._callback(this.requests.pop(), new Error("peer is choking"), null);
           }
         }
       }
       _onUnchoke() {
         this.peerChoking = false;
         this._debug("got unchoke");
         this.emit("unchoke");
       }
       _onInterested() {
         this.peerInterested = true;
         this._debug("got interested");
         this.emit("interested");
       }
       _onUninterested() {
         this.peerInterested = false;
         this._debug("got uninterested");
         this.emit("uninterested");
       }
       _onHave(index) {
         if (this.peerPieces.get(index))
           return;
         this._debug("got have %d", index);
         this.peerPieces.set(index, true);
         this.emit("have", index);
       }
       _onBitField(buffer) {
         this.peerPieces = new BitField(buffer);
         this._debug("got bitfield");
         this.emit("bitfield", this.peerPieces);
       }
       _onRequest(index, offset, length) {
         if (this.amChoking && !(this.hasFast && this.allowedFastSet.includes(index))) {
           if (this.hasFast)
             this.reject(index, offset, length);
           return;
         }
         this._debug("got request index=%d offset=%d length=%d", index, offset, length);
         const respond = (err, buffer) => {
           if (request !== this._pull(this.peerRequests, index, offset, length))
             return;
           if (err) {
             this._debug("error satisfying request index=%d offset=%d length=%d (%s)", index, offset, length, err.message);
             if (this.hasFast)
               this.reject(index, offset, length);
             return;
           }
           this.piece(index, offset, buffer);
         };
         const request = new Request(index, offset, length, respond);
         this.peerRequests.push(request);
         this.emit("request", index, offset, length, respond);
       }
       _onPiece(index, offset, buffer) {
         this._debug("got piece index=%d offset=%d", index, offset);
         this._callback(this._pull(this.requests, index, offset, buffer.length), null, buffer);
         this.downloaded += buffer.length;
         this.downloadSpeed(buffer.length);
         this.emit("download", buffer.length);
         this.emit("piece", index, offset, buffer);
       }
       _onCancel(index, offset, length) {
         this._debug("got cancel index=%d offset=%d length=%d", index, offset, length);
         this._pull(this.peerRequests, index, offset, length);
         this.emit("cancel", index, offset, length);
       }
       _onPort(port) {
         this._debug("got port %d", port);
         this.emit("port", port);
       }
       _onSuggest(index) {
         if (!this.hasFast) {
           this._debug("Error: got suggest whereas fast extension is disabled");
           this.destroy();
           return;
         }
         this._debug("got suggest %d", index);
         this.emit("suggest", index);
       }
       _onHaveAll() {
         if (!this.hasFast) {
           this._debug("Error: got have-all whereas fast extension is disabled");
           this.destroy();
           return;
         }
         this._debug("got have-all");
         this.peerPieces = new HaveAllBitField();
         this.emit("have-all");
       }
       _onHaveNone() {
         if (!this.hasFast) {
           this._debug("Error: got have-none whereas fast extension is disabled");
           this.destroy();
           return;
         }
         this._debug("got have-none");
         this.emit("have-none");
       }
       _onReject(index, offset, length) {
         if (!this.hasFast) {
           this._debug("Error: got reject whereas fast extension is disabled");
           this.destroy();
           return;
         }
         this._debug("got reject index=%d offset=%d length=%d", index, offset, length);
         this._callback(
           this._pull(this.requests, index, offset, length),
           new Error("request was rejected"),
           null
         );
         this.emit("reject", index, offset, length);
       }
       _onAllowedFast(index) {
         if (!this.hasFast) {
           this._debug("Error: got allowed-fast whereas fast extension is disabled");
           this.destroy();
           return;
         }
         this._debug("got allowed-fast %d", index);
         if (!this.peerAllowedFastSet.includes(index))
           this.peerAllowedFastSet.push(index);
         if (this.peerAllowedFastSet.length > ALLOWED_FAST_SET_MAX_LENGTH)
           this.peerAllowedFastSet.shift();
         this.emit("allowed-fast", index);
       }
       _onExtended(ext, buf) {
         if (ext === 0) {
           let info;
           try {
             info = bencode.decode(buf);
           } catch (err) {
             this._debug("ignoring invalid extended handshake: %s", err.message || err);
           }
           if (!info)
             return;
           this.peerExtendedHandshake = info;
           if (typeof info.m === "object") {
             for (const name in info.m) {
               this.peerExtendedMapping[name] = Number(info.m[name].toString());
             }
           }
           for (const name in this._ext) {
             if (this.peerExtendedMapping[name]) {
               this._ext[name].onExtendedHandshake(this.peerExtendedHandshake);
             }
           }
           this._debug("got extended handshake");
           this.emit("extended", "handshake", this.peerExtendedHandshake);
         } else {
           if (this.extendedMapping[ext]) {
             ext = this.extendedMapping[ext];
             if (this._ext[ext]) {
               this._ext[ext].onMessage(buf);
             }
           }
           this._debug("got extended message ext=%s", ext);
           this.emit("extended", ext, buf);
         }
       }
       _onTimeout() {
         this._debug("request timed out");
         this._callback(this.requests.shift(), new Error("request has timed out"), null);
         this.emit("timeout");
       }
       _write(data, encoding, cb) {
         if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
           data = this._decrypt(data);
         }
         this._bufferSize += data.length;
         this._buffer.push(data);
         if (this._buffer.length > 1) {
           this._buffer = [Buffer.concat(this._buffer, this._bufferSize)];
         }
         if (this._cryptoSyncPattern) {
           const index = this._buffer[0].indexOf(this._cryptoSyncPattern);
           if (index !== -1) {
             this._buffer[0] = this._buffer[0].slice(index + this._cryptoSyncPattern.length);
             this._bufferSize -= index + this._cryptoSyncPattern.length;
             this._cryptoSyncPattern = null;
           } else if (this._bufferSize + data.length > this._waitMaxBytes + this._cryptoSyncPattern.length) {
             this._debug("Error: could not resynchronize");
             this.destroy();
             return;
           }
         }
         while (this._bufferSize >= this._parserSize && !this._cryptoSyncPattern) {
           if (this._parserSize === 0) {
             this._parser(Buffer.from([]));
           } else {
             const buffer = this._buffer[0];
             this._bufferSize -= this._parserSize;
             this._buffer = this._bufferSize ? [buffer.slice(this._parserSize)] : [];
             this._parser(buffer.slice(0, this._parserSize));
           }
         }
         cb(null);
       }
       _callback(request, err, buffer) {
         if (!request)
           return;
         this._resetTimeout(!this.peerChoking && !this._finished);
         request.callback(err, buffer);
       }
       _resetTimeout(setAgain) {
         if (!setAgain || !this._timeoutMs || !this.requests.length) {
           clearTimeout(this._timeout);
           this._timeout = null;
           this._timeoutExpiresAt = null;
           return;
         }
         const timeoutExpiresAt = Date.now() + this._timeoutMs;
         if (this._timeout) {
           if (timeoutExpiresAt - this._timeoutExpiresAt < this._timeoutMs * 0.05) {
             return;
           }
           clearTimeout(this._timeout);
         }
         this._timeoutExpiresAt = timeoutExpiresAt;
         this._timeout = setTimeout(() => this._onTimeout(), this._timeoutMs);
         if (this._timeoutUnref && this._timeout.unref)
           this._timeout.unref();
       }
       _parse(size, parser) {
         this._parserSize = size;
         this._parser = parser;
       }
       _parseUntil(pattern, maxBytes) {
         this._cryptoSyncPattern = pattern;
         this._waitMaxBytes = maxBytes;
       }
       _onMessageLength(buffer) {
         const length = buffer.readUInt32BE(0);
         if (length > 0) {
           this._parse(length, this._onMessage);
         } else {
           this._onKeepAlive();
           this._parse(4, this._onMessageLength);
         }
       }
       _onMessage(buffer) {
         this._parse(4, this._onMessageLength);
         switch (buffer[0]) {
           case 0:
             return this._onChoke();
           case 1:
             return this._onUnchoke();
           case 2:
             return this._onInterested();
           case 3:
             return this._onUninterested();
           case 4:
             return this._onHave(buffer.readUInt32BE(1));
           case 5:
             return this._onBitField(buffer.slice(1));
           case 6:
             return this._onRequest(
               buffer.readUInt32BE(1),
               buffer.readUInt32BE(5),
               buffer.readUInt32BE(9)
             );
           case 7:
             return this._onPiece(
               buffer.readUInt32BE(1),
               buffer.readUInt32BE(5),
               buffer.slice(9)
             );
           case 8:
             return this._onCancel(
               buffer.readUInt32BE(1),
               buffer.readUInt32BE(5),
               buffer.readUInt32BE(9)
             );
           case 9:
             return this._onPort(buffer.readUInt16BE(1));
           case 13:
             return this._onSuggest(buffer.readUInt32BE(1));
           case 14:
             return this._onHaveAll();
           case 15:
             return this._onHaveNone();
           case 16:
             return this._onReject(
               buffer.readUInt32BE(1),
               buffer.readUInt32BE(5),
               buffer.readUInt32BE(9)
             );
           case 17:
             return this._onAllowedFast(buffer.readUInt32BE(1));
           case 20:
             return this._onExtended(buffer.readUInt8(1), buffer.slice(2));
           default:
             this._debug("got unknown message");
             return this.emit("unknownmessage", buffer);
         }
       }
       _determineHandshakeType() {
         this._parse(1, (pstrLenBuffer) => {
           const pstrlen = pstrLenBuffer.readUInt8(0);
           if (pstrlen === 19) {
             this._parse(pstrlen + 48, this._onHandshakeBuffer);
           } else {
             this._parsePe1(pstrLenBuffer);
           }
         });
       }
       _parsePe1(pubKeyPrefix) {
         this._parse(95, (pubKeySuffix) => {
           this._onPe1(Buffer.concat([pubKeyPrefix, pubKeySuffix]));
           this._parsePe3();
         });
       }
       _parsePe2() {
         this._parse(96, (pubKey) => {
           this._onPe2(pubKey);
           while (!this._setGenerators) {
           }
           this._parsePe4();
         });
       }
       _parsePe3() {
         const hash1Buffer = Buffer.from(sha1.sync(Buffer.from(this._utfToHex("req1") + this._sharedSecret, "hex")), "hex");
         this._parseUntil(hash1Buffer, 512);
         this._parse(20, (buffer) => {
           this._onPe3(buffer);
           while (!this._setGenerators) {
           }
           this._parsePe3Encrypted();
         });
       }
       _parsePe3Encrypted() {
         this._parse(14, (buffer) => {
           const vcBuffer = this._decryptHandshake(buffer.slice(0, 8));
           const peerProvideBuffer = this._decryptHandshake(buffer.slice(8, 12));
           const padCLen = this._decryptHandshake(buffer.slice(12, 14)).readUInt16BE(0);
           this._parse(padCLen, (padCBuffer) => {
             padCBuffer = this._decryptHandshake(padCBuffer);
             this._parse(2, (iaLenBuf) => {
               const iaLen = this._decryptHandshake(iaLenBuf).readUInt16BE(0);
               this._parse(iaLen, (iaBuffer) => {
                 iaBuffer = this._decryptHandshake(iaBuffer);
                 this._onPe3Encrypted(vcBuffer, peerProvideBuffer, padCBuffer, iaBuffer);
                 const pstrlen = iaLen ? iaBuffer.readUInt8(0) : null;
                 const protocol = iaLen ? iaBuffer.slice(1, 20) : null;
                 if (pstrlen === 19 && protocol.toString() === "BitTorrent protocol") {
                   this._onHandshakeBuffer(iaBuffer.slice(1));
                 } else {
                   this._parseHandshake();
                 }
               });
             });
           });
         });
       }
       _parsePe4() {
         const vcBufferEncrypted = this._decryptHandshake(VC);
         this._parseUntil(vcBufferEncrypted, 512);
         this._parse(6, (buffer) => {
           const peerSelectBuffer = this._decryptHandshake(buffer.slice(0, 4));
           const padDLen = this._decryptHandshake(buffer.slice(4, 6)).readUInt16BE(0);
           this._parse(padDLen, (padDBuf) => {
             this._decryptHandshake(padDBuf);
             this._onPe4(peerSelectBuffer);
             this._parseHandshake(null);
           });
         });
       }
       _parseHandshake() {
         this._parse(1, (buffer) => {
           const pstrlen = buffer.readUInt8(0);
           if (pstrlen !== 19) {
             this._debug("Error: wire not speaking BitTorrent protocol (%s)", pstrlen.toString());
             this.end();
             return;
           }
           this._parse(pstrlen + 48, this._onHandshakeBuffer);
         });
       }
       _onHandshakeBuffer(handshake) {
         const protocol = handshake.slice(0, 19);
         if (protocol.toString() !== "BitTorrent protocol") {
           this._debug("Error: wire not speaking BitTorrent protocol (%s)", protocol.toString());
           this.end();
           return;
         }
         handshake = handshake.slice(19);
         this._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
           dht: !!(handshake[7] & 1),
           fast: !!(handshake[7] & 4),
           extended: !!(handshake[5] & 16)
         });
         this._parse(4, this._onMessageLength);
       }
       _onFinish() {
         this._finished = true;
         this.push(null);
         while (this.read()) {
         }
         clearInterval(this._keepAliveInterval);
         this._parse(Number.MAX_VALUE, () => {
         });
         while (this.peerRequests.length) {
           this.peerRequests.pop();
         }
         while (this.requests.length) {
           this._callback(this.requests.pop(), new Error("wire was closed"), null);
         }
       }
       _debug(...args) {
         args[0] = `[${this._debugId}] ${args[0]}`;
         debug(...args);
       }
       _pull(requests, piece, offset, length) {
         for (let i = 0; i < requests.length; i++) {
           const req = requests[i];
           if (req.piece === piece && req.offset === offset && req.length === length) {
             arrayRemove(requests, i);
             return req;
           }
         }
         return null;
       }
       _encryptHandshake(buf) {
         const crypt = Buffer.from(buf);
         if (!this._encryptGenerator) {
           this._debug("Warning: Encrypting without any generator");
           return crypt;
         }
         for (let i = 0; i < buf.length; i++) {
           const keystream = this._encryptGenerator.randomByte();
           crypt[i] = crypt[i] ^ keystream;
         }
         return crypt;
       }
       _encrypt(buf) {
         const crypt = Buffer.from(buf);
         if (!this._encryptGenerator || this._encryptionMethod !== 2) {
           return crypt;
         }
         for (let i = 0; i < buf.length; i++) {
           const keystream = this._encryptGenerator.randomByte();
           crypt[i] = crypt[i] ^ keystream;
         }
         return crypt;
       }
       _decryptHandshake(buf) {
         const decrypt = Buffer.from(buf);
         if (!this._decryptGenerator) {
           this._debug("Warning: Decrypting without any generator");
           return decrypt;
         }
         for (let i = 0; i < buf.length; i++) {
           const keystream = this._decryptGenerator.randomByte();
           decrypt[i] = decrypt[i] ^ keystream;
         }
         return decrypt;
       }
       _decrypt(buf) {
         const decrypt = Buffer.from(buf);
         if (!this._decryptGenerator || this._encryptionMethod !== 2) {
           return decrypt;
         }
         for (let i = 0; i < buf.length; i++) {
           const keystream = this._decryptGenerator.randomByte();
           decrypt[i] = decrypt[i] ^ keystream;
         }
         return decrypt;
       }
       _utfToHex(str) {
         return Buffer.from(str, "utf8").toString("hex");
       }
     };
     module2.exports = Wire;
   }
 });
 
 // node_modules/webtorrent/lib/peer.js
 var require_peer = __commonJS({
   "node_modules/webtorrent/lib/peer.js"(exports) {
     var EventEmitter = require("events");
     var { Transform } = require("stream");
     var arrayRemove = require_unordered_array_remove();
     var debugFactory = require_src();
     var Wire = require_bittorrent_protocol();
     var CONNECT_TIMEOUT_TCP = 5e3;
     var CONNECT_TIMEOUT_UTP = 5e3;
     var CONNECT_TIMEOUT_WEBRTC = 25e3;
     var HANDSHAKE_TIMEOUT = 25e3;
     var debug = debugFactory("webtorrent:peer");
     var secure = false;
     exports.enableSecure = () => {
       secure = true;
     };
     exports.createWebRTCPeer = (conn, swarm, throttleGroups) => {
       const peer = new Peer(conn.id, "webrtc");
       peer.conn = conn;
       peer.swarm = swarm;
       peer.throttleGroups = throttleGroups;
       if (peer.conn.connected) {
         peer.onConnect();
       } else {
         const cleanup = () => {
           peer.conn.removeListener("connect", onConnect);
           peer.conn.removeListener("error", onError);
         };
         const onConnect = () => {
           cleanup();
           peer.onConnect();
         };
         const onError = (err) => {
           cleanup();
           peer.destroy(err);
         };
         peer.conn.once("connect", onConnect);
         peer.conn.once("error", onError);
         peer.startConnectTimeout();
       }
       return peer;
     };
     exports.createTCPIncomingPeer = (conn, throttleGroups) => {
       return _createIncomingPeer(conn, "tcpIncoming", throttleGroups);
     };
     exports.createUTPIncomingPeer = (conn, throttleGroups) => {
       return _createIncomingPeer(conn, "utpIncoming", throttleGroups);
     };
     exports.createTCPOutgoingPeer = (addr, swarm, throttleGroups) => {
       return _createOutgoingPeer(addr, swarm, "tcpOutgoing", throttleGroups);
     };
     exports.createUTPOutgoingPeer = (addr, swarm, throttleGroups) => {
       return _createOutgoingPeer(addr, swarm, "utpOutgoing", throttleGroups);
     };
     var _createIncomingPeer = (conn, type, throttleGroups) => {
       const addr = `${conn.remoteAddress}:${conn.remotePort}`;
       const peer = new Peer(addr, type);
       peer.conn = conn;
       peer.addr = addr;
       peer.throttleGroups = throttleGroups;
       peer.onConnect();
       return peer;
     };
     var _createOutgoingPeer = (addr, swarm, type, throttleGroups) => {
       const peer = new Peer(addr, type);
       peer.addr = addr;
       peer.swarm = swarm;
       peer.throttleGroups = throttleGroups;
       return peer;
     };
     exports.createWebSeedPeer = (conn, id, swarm, throttleGroups) => {
       const peer = new Peer(id, "webSeed");
       peer.swarm = swarm;
       peer.conn = conn;
       peer.throttleGroups = throttleGroups;
       peer.onConnect();
       return peer;
     };
     var Peer = class extends EventEmitter {
       constructor(id, type) {
         super();
         this.id = id;
         this.type = type;
         debug("new %s Peer %s", type, id);
         this.addr = null;
         this.conn = null;
         this.swarm = null;
         this.wire = null;
         this.connected = false;
         this.destroyed = false;
         this.timeout = null;
         this.retries = 0;
         this.sentPe1 = false;
         this.sentPe2 = false;
         this.sentPe3 = false;
         this.sentPe4 = false;
         this.sentHandshake = false;
       }
       onConnect() {
         if (this.destroyed)
           return;
         this.connected = true;
         debug("Peer %s connected", this.id);
         clearTimeout(this.connectTimeout);
         const conn = this.conn;
         conn.once("end", () => {
           this.destroy();
         });
         conn.once("close", () => {
           this.destroy();
         });
         conn.once("finish", () => {
           this.destroy();
         });
         conn.once("error", (err) => {
           this.destroy(err);
         });
         const wire = this.wire = new Wire(this.type, this.retries, secure);
         wire.once("end", () => {
           this.destroy();
         });
         wire.once("close", () => {
           this.destroy();
         });
         wire.once("finish", () => {
           this.destroy();
         });
         wire.once("error", (err) => {
           this.destroy(err);
         });
         wire.once("pe1", () => {
           this.onPe1();
         });
         wire.once("pe2", () => {
           this.onPe2();
         });
         wire.once("pe3", () => {
           this.onPe3();
         });
         wire.once("pe4", () => {
           this.onPe4();
         });
         wire.once("handshake", (infoHash, peerId) => {
           this.onHandshake(infoHash, peerId);
         });
         this.startHandshakeTimeout();
         this.setThrottlePipes();
         if (this.swarm) {
           if (this.type === "tcpOutgoing") {
             if (secure && this.retries === 0 && !this.sentPe1)
               this.sendPe1();
             else if (!this.sentHandshake)
               this.handshake();
           } else if (this.type !== "tcpIncoming" && !this.sentHandshake)
             this.handshake();
         }
       }
       sendPe1() {
         this.wire.sendPe1();
         this.sentPe1 = true;
       }
       onPe1() {
         this.sendPe2();
       }
       sendPe2() {
         this.wire.sendPe2();
         this.sentPe2 = true;
       }
       onPe2() {
         this.sendPe3();
       }
       sendPe3() {
         this.wire.sendPe3(this.swarm.infoHash);
         this.sentPe3 = true;
       }
       onPe3(infoHashHash) {
         if (this.swarm) {
           if (this.swarm.infoHashHash !== infoHashHash) {
             this.destroy(new Error("unexpected crypto handshake info hash for this swarm"));
           }
           this.sendPe4();
         }
       }
       sendPe4() {
         this.wire.sendPe4(this.swarm.infoHash);
         this.sentPe4 = true;
       }
       onPe4() {
         if (!this.sentHandshake)
           this.handshake();
       }
       clearPipes() {
         this.conn.unpipe();
         this.wire.unpipe();
       }
       setThrottlePipes() {
         const self = this;
         this.conn.pipe(this.throttleGroups.down.throttle()).pipe(new Transform({
           transform(chunk, _, callback) {
             self.emit("download", chunk.length);
             if (self.destroyed)
               return;
             callback(null, chunk);
           }
         })).pipe(this.wire).pipe(this.throttleGroups.up.throttle()).pipe(new Transform({
           transform(chunk, _, callback) {
             self.emit("upload", chunk.length);
             if (self.destroyed)
               return;
             callback(null, chunk);
           }
         })).pipe(this.conn);
       }
       onHandshake(infoHash, peerId) {
         if (!this.swarm)
           return;
         if (this.destroyed)
           return;
         if (this.swarm.destroyed) {
           return this.destroy(new Error("swarm already destroyed"));
         }
         if (infoHash !== this.swarm.infoHash) {
           return this.destroy(new Error("unexpected handshake info hash for this swarm"));
         }
         if (peerId === this.swarm.peerId) {
           return this.destroy(new Error("refusing to connect to ourselves"));
         }
         debug("Peer %s got handshake %s", this.id, infoHash);
         clearTimeout(this.handshakeTimeout);
         this.retries = 0;
         let addr = this.addr;
         if (!addr && this.conn.remoteAddress && this.conn.remotePort) {
           addr = `${this.conn.remoteAddress}:${this.conn.remotePort}`;
         }
         this.swarm._onWire(this.wire, addr);
         if (!this.swarm || this.swarm.destroyed)
           return;
         if (!this.sentHandshake)
           this.handshake();
       }
       handshake() {
         const opts = {
           dht: this.swarm.private ? false : !!this.swarm.client.dht,
           fast: true
         };
         this.wire.handshake(this.swarm.infoHash, this.swarm.client.peerId, opts);
         this.sentHandshake = true;
       }
       startConnectTimeout() {
         clearTimeout(this.connectTimeout);
         const connectTimeoutValues = {
           webrtc: CONNECT_TIMEOUT_WEBRTC,
           tcpOutgoing: CONNECT_TIMEOUT_TCP,
           utpOutgoing: CONNECT_TIMEOUT_UTP
         };
         this.connectTimeout = setTimeout(() => {
           this.destroy(new Error("connect timeout"));
         }, connectTimeoutValues[this.type]);
         if (this.connectTimeout.unref)
           this.connectTimeout.unref();
       }
       startHandshakeTimeout() {
         clearTimeout(this.handshakeTimeout);
         this.handshakeTimeout = setTimeout(() => {
           this.destroy(new Error("handshake timeout"));
         }, HANDSHAKE_TIMEOUT);
         if (this.handshakeTimeout.unref)
           this.handshakeTimeout.unref();
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         this.connected = false;
         debug("destroy %s %s (error: %s)", this.type, this.id, err && (err.message || err));
         clearTimeout(this.connectTimeout);
         clearTimeout(this.handshakeTimeout);
         const swarm = this.swarm;
         const conn = this.conn;
         const wire = this.wire;
         this.swarm = null;
         this.conn = null;
         this.wire = null;
         if (swarm && wire) {
           arrayRemove(swarm.wires, swarm.wires.indexOf(wire));
         }
         if (conn) {
           conn.on("error", () => {
           });
           conn.destroy();
         }
         if (wire)
           wire.destroy();
         if (swarm)
           swarm.removePeer(this.id);
       }
     };
   }
 });
 
 // node_modules/node-gyp-build/index.js
 var require_node_gyp_build = __commonJS({
   "node_modules/node-gyp-build/index.js"(exports, module2) {
     var fs2 = require("fs");
     var path2 = require("path");
     var os2 = require("os");
     var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
     var vars = process.config && process.config.variables || {};
     var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
     var abi = process.versions.modules;
     var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
     var arch = process.env.npm_config_arch || os2.arch();
     var platform = process.env.npm_config_platform || os2.platform();
     var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
     var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
     var uv = (process.versions.uv || "").split(".")[0];
     module2.exports = load;
     function load(dir) {
       return runtimeRequire(load.path(dir));
     }
     load.path = function(dir) {
       dir = path2.resolve(dir || ".");
       try {
         var name = runtimeRequire(path2.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
         if (process.env[name + "_PREBUILD"])
           dir = process.env[name + "_PREBUILD"];
       } catch (err) {
       }
       if (!prebuildsOnly) {
         var release = getFirst(path2.join(dir, "build/Release"), matchBuild);
         if (release)
           return release;
         var debug = getFirst(path2.join(dir, "build/Debug"), matchBuild);
         if (debug)
           return debug;
       }
       var prebuild = resolve(dir);
       if (prebuild)
         return prebuild;
       var nearby = resolve(path2.dirname(process.execPath));
       if (nearby)
         return nearby;
       var target = [
         "platform=" + platform,
         "arch=" + arch,
         "runtime=" + runtime,
         "abi=" + abi,
         "uv=" + uv,
         armv ? "armv=" + armv : "",
         "libc=" + libc,
         "node=" + process.versions.node,
         process.versions.electron ? "electron=" + process.versions.electron : "",
         typeof __webpack_require__ === "function" ? "webpack=true" : ""
       ].filter(Boolean).join(" ");
       throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
       function resolve(dir2) {
         var tuples = readdirSync(path2.join(dir2, "prebuilds")).map(parseTuple);
         var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
         if (!tuple)
           return;
         var prebuilds = path2.join(dir2, "prebuilds", tuple.name);
         var parsed = readdirSync(prebuilds).map(parseTags);
         var candidates = parsed.filter(matchTags(runtime, abi));
         var winner = candidates.sort(compareTags(runtime))[0];
         if (winner)
           return path2.join(prebuilds, winner.file);
       }
     };
     function readdirSync(dir) {
       try {
         return fs2.readdirSync(dir);
       } catch (err) {
         return [];
       }
     }
     function getFirst(dir, filter) {
       var files = readdirSync(dir).filter(filter);
       return files[0] && path2.join(dir, files[0]);
     }
     function matchBuild(name) {
       return /\.node$/.test(name);
     }
     function parseTuple(name) {
       var arr = name.split("-");
       if (arr.length !== 2)
         return;
       var platform2 = arr[0];
       var architectures = arr[1].split("+");
       if (!platform2)
         return;
       if (!architectures.length)
         return;
       if (!architectures.every(Boolean))
         return;
       return { name, platform: platform2, architectures };
     }
     function matchTuple(platform2, arch2) {
       return function(tuple) {
         if (tuple == null)
           return false;
         if (tuple.platform !== platform2)
           return false;
         return tuple.architectures.includes(arch2);
       };
     }
     function compareTuples(a, b) {
       return a.architectures.length - b.architectures.length;
     }
     function parseTags(file) {
       var arr = file.split(".");
       var extension = arr.pop();
       var tags = { file, specificity: 0 };
       if (extension !== "node")
         return;
       for (var i = 0; i < arr.length; i++) {
         var tag = arr[i];
         if (tag === "node" || tag === "electron" || tag === "node-webkit") {
           tags.runtime = tag;
         } else if (tag === "napi") {
           tags.napi = true;
         } else if (tag.slice(0, 3) === "abi") {
           tags.abi = tag.slice(3);
         } else if (tag.slice(0, 2) === "uv") {
           tags.uv = tag.slice(2);
         } else if (tag.slice(0, 4) === "armv") {
           tags.armv = tag.slice(4);
         } else if (tag === "glibc" || tag === "musl") {
           tags.libc = tag;
         } else {
           continue;
         }
         tags.specificity++;
       }
       return tags;
     }
     function matchTags(runtime2, abi2) {
       return function(tags) {
         if (tags == null)
           return false;
         if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
           return false;
         if (tags.abi !== abi2 && !tags.napi)
           return false;
         if (tags.uv && tags.uv !== uv)
           return false;
         if (tags.armv && tags.armv !== armv)
           return false;
         if (tags.libc && tags.libc !== libc)
           return false;
         return true;
       };
     }
     function runtimeAgnostic(tags) {
       return tags.runtime === "node" && tags.napi;
     }
     function compareTags(runtime2) {
       return function(a, b) {
         if (a.runtime !== b.runtime) {
           return a.runtime === runtime2 ? -1 : 1;
         } else if (a.abi !== b.abi) {
           return a.abi ? -1 : 1;
         } else if (a.specificity !== b.specificity) {
           return a.specificity > b.specificity ? -1 : 1;
         } else {
           return 0;
         }
       };
     }
     function isNwjs() {
       return !!(process.versions && process.versions.nw);
     }
     function isElectron() {
       if (process.versions && process.versions.electron)
         return true;
       if (process.env.ELECTRON_RUN_AS_NODE)
         return true;
       return typeof window !== "undefined" && window.process && window.process.type === "renderer";
     }
     function isAlpine(platform2) {
       return platform2 === "linux" && fs2.existsSync("/etc/alpine-release");
     }
     load.parseTags = parseTags;
     load.matchTags = matchTags;
     load.compareTags = compareTags;
     load.parseTuple = parseTuple;
     load.matchTuple = matchTuple;
     load.compareTuples = compareTuples;
   }
 });
 
 // node_modules/utp-native/lib/binding.js
 var require_binding = __commonJS({
   "node_modules/utp-native/lib/binding.js"(exports, module2) {
     var path2 = require("path");
     module2.exports = require_node_gyp_build()(path2.join(__dirname, ".."));
   }
 });
 
 // node_modules/unordered-set/index.js
 var require_unordered_set = __commonJS({
   "node_modules/unordered-set/index.js"(exports) {
     exports.add = add;
     exports.has = has;
     exports.remove = remove;
     exports.swap = swap;
     function add(list, item) {
       if (has(list, item))
         return item;
       item._index = list.length;
       list.push(item);
       return item;
     }
     function has(list, item) {
       return item._index < list.length && list[item._index] === item;
     }
     function remove(list, item) {
       if (!has(list, item))
         return null;
       var last = list.pop();
       if (last !== item) {
         list[item._index] = last;
         last._index = item._index;
       }
       return item;
     }
     function swap(list, a, b) {
       if (!has(list, a) || !has(list, b))
         return;
       var tmp = a._index;
       a._index = b._index;
       list[a._index] = a;
       b._index = tmp;
       list[b._index] = b;
     }
   }
 });
 
 // node_modules/timeout-refresh/refresh.js
 var require_refresh = __commonJS({
   "node_modules/timeout-refresh/refresh.js"(exports, module2) {
     module2.exports = Timer;
     function Timer(ms, fn, ctx) {
       if (!(this instanceof Timer))
         return new Timer(ms, fn, ctx);
       this.ms = ms;
       this.ontimeout = fn;
       this.context = ctx || null;
       this.called = false;
       this._timeout = setTimeout(call, ms, this);
       this._timeout.unref();
     }
     Timer.prototype.refresh = function() {
       if (this.called || this.ontimeout === null)
         return;
       this._timeout.refresh();
     };
     Timer.prototype.destroy = function() {
       this.ontimeout = null;
       clearTimeout(this._timeout);
     };
     function call(self) {
       self.called = true;
       self.ontimeout.call(self.context);
     }
   }
 });
 
 // node_modules/timeout-refresh/browser.js
 var require_browser2 = __commonJS({
   "node_modules/timeout-refresh/browser.js"(exports, module2) {
     module2.exports = Timeout;
     function Timeout(ms, fn, ctx) {
       if (!(this instanceof Timeout))
         return new Timeout(ms, fn, ctx);
       this.ms = ms;
       this.ontimeout = fn;
       this.context = ctx || null;
       this.called = false;
       this._timeout = setTimeout(call, ms, this);
     }
     Timeout.prototype.refresh = function() {
       if (this.called || this.ontimeout === null)
         return;
       clearTimeout(this._timeout);
       this._timeout = setTimeout(call, this.ms, this);
     };
     Timeout.prototype.destroy = function() {
       this.ontimeout = null;
       clearTimeout(this._timeout);
     };
     function call(self) {
       self.called = true;
       self.ontimeout.call(self.context);
     }
   }
 });
 
 // node_modules/timeout-refresh/timers.js
 var require_timers = __commonJS({
   "node_modules/timeout-refresh/timers.js"(exports, module2) {
     var timers = require("timers");
     var enroll = timers.enroll || noop2;
     var active = timers._unrefActive || timers.active || noop2;
     var unenroll = timers.unenroll || noop2;
     module2.exports = Timeout;
     function Timeout(ms, fn, ctx) {
       if (!(this instanceof Timeout))
         return new Timeout(ms, fn, ctx);
       this.ms = ms;
       this.ontimeout = fn;
       this.context = ctx || null;
       this.called = false;
       enroll(this, ms);
       active(this);
     }
     Timeout.prototype._onTimeout = function() {
       this.called = true;
       this.ontimeout.call(this.context);
     };
     Timeout.prototype.refresh = function() {
       if (this.called || this.ontimeout === null)
         return;
       active(this);
     };
     Timeout.prototype.destroy = function() {
       this.ontimeout = null;
       unenroll(this);
     };
     function noop2() {
     }
   }
 });
 
 // node_modules/timeout-refresh/index.js
 var require_timeout_refresh = __commonJS({
   "node_modules/timeout-refresh/index.js"(exports, module2) {
     var to = setTimeout(function() {
     }, 1e3);
     clearTimeout(to);
     module2.exports = to.refresh ? require_refresh() : process.versions.electron ? require_browser2() : require_timers();
   }
 });
 
 // node_modules/utp-native/lib/connection.js
 var require_connection = __commonJS({
   "node_modules/utp-native/lib/connection.js"(exports, module2) {
     var binding = require_binding();
     var stream = require_readable();
     var util = require("util");
     var unordered = require_unordered_set();
     var dns = require("dns");
     var timeout = require_timeout_refresh();
     var EMPTY = Buffer.alloc(0);
     var UTP_ERRORS = [
       "UTP_ECONNREFUSED",
       "UTP_ECONNRESET",
       "UTP_ETIMEDOUT",
       "UTP_UNKNOWN"
     ];
     module2.exports = Connection;
     function Connection(utp, port, address, handle, halfOpen) {
       stream.Duplex.call(this);
       this.remoteAddress = address;
       this.remoteFamily = "IPv4";
       this.remotePort = port;
       this.destroyed = false;
       this._index = -1;
       this._utp = utp;
       this._handle = handle || Buffer.alloc(binding.sizeof_utp_napi_connection_t);
       this._buffer = Buffer.allocUnsafe(65536 * 2);
       this._offset = 0;
       this._view = new Uint32Array(this._handle.buffer, this._handle.byteOffset, 2);
       this._callback = null;
       this._writing = null;
       this._error = null;
       this._connected = false;
       this._needsConnect = !handle;
       this._timeout = null;
       this._contentSize = 0;
       this._allowOpen = halfOpen ? 2 : 1;
       this.on("finish", this._shutdown);
       binding.utp_napi_connection_init(
         this._handle,
         this,
         this._buffer,
         this._onread,
         this._ondrain,
         this._onend,
         this._onerror,
         this._onclose,
         this._onconnect,
         this._realloc
       );
       unordered.add(utp.connections, this);
       if (utp.maxConnections && utp.connections.length >= utp.maxConnections) {
         utp.firewall(true);
       }
     }
     util.inherits(Connection, stream.Duplex);
     Connection.prototype.setTimeout = function(ms, ontimeout) {
       if (ontimeout)
         this.once("timeout", ontimeout);
       if (this._timeout)
         this._timeout.destroy();
       this._timeout = timeout(ms, this._ontimeout, this);
     };
     Connection.prototype._ontimeout = function() {
       this.emit("timeout");
     };
     Connection.prototype.setInteractive = function(interactive) {
       this.setPacketSize(this.interactive ? 0 : 65536);
     };
     Connection.prototype.setContentSize = function(size) {
       this._view[0] = size < 65536 ? size >= 0 ? size : 0 : 65536;
       this._contentSize = size;
     };
     Connection.prototype.setPacketSize = function(size) {
       if (size > 65536)
         size = 65536;
       this._view[0] = size;
       this._contentSize = 0;
     };
     Connection.prototype.address = function() {
       if (this.destroyed)
         return null;
       return this._utp.address();
     };
     Connection.prototype._read = function() {
     };
     Connection.prototype._write = function(data, enc, cb) {
       if (this.destroyed)
         return;
       if (!this._connected || !binding.utp_napi_connection_write(this._handle, data)) {
         this._callback = cb;
         this._writing = new Array(1);
         this._writing[0] = data;
         return;
       }
       cb(null);
     };
     Connection.prototype._writev = function(datas, cb) {
       if (this.destroyed)
         return;
       const bufs = new Array(datas.length);
       for (var i = 0; i < datas.length; i++)
         bufs[i] = datas[i].chunk;
       if (bufs.length > 256)
         return this._write(Buffer.concat(bufs), null, cb);
       if (!binding.utp_napi_connection_writev(this._handle, bufs)) {
         this._callback = cb;
         this._writing = bufs;
         return;
       }
       cb(null);
     };
     Connection.prototype._realloc = function() {
       this._buffer = Buffer.allocUnsafe(this._buffer.length);
       this._offset = 0;
       return this._buffer;
     };
     Connection.prototype._onread = function(size) {
       if (!this._connected)
         this._onconnect();
       if (this._timeout)
         this._timeout.refresh();
       const buf = this._buffer.slice(this._offset, this._offset += size);
       if (this._contentSize) {
         if (size > this._contentSize)
           size = this._contentSize;
         this._contentSize -= size;
         if (this._contentSize < 65536)
           this._view[0] = this._contentSize;
       }
       this.push(buf);
       if (this._buffer.length - this._offset <= 69632) {
         this._buffer = Buffer.allocUnsafe(this._buffer.length);
         this._offset = 0;
         return this._buffer;
       }
       return EMPTY;
     };
     Connection.prototype._ondrain = function() {
       this._writing = null;
       const cb = this._callback;
       this._callback = null;
       cb(null);
     };
     Connection.prototype._onclose = function() {
       unordered.remove(this._utp.connections, this);
       if (!this._utp.maxConnections || this._utp.connections.length < this._utp.maxConnections) {
         this._utp.firewall(false);
       }
       this._handle = null;
       if (this._error)
         this.emit("error", this._error);
       this.emit("close");
       this._utp._closeMaybe();
     };
     Connection.prototype._onerror = function(status) {
       this.destroy(createUTPError(status));
     };
     Connection.prototype._onend = function() {
       if (this._timeout)
         this._timeout.destroy();
       this.push(null);
       this._destroyMaybe();
     };
     Connection.prototype._resolveAndConnect = function(port, host) {
       const self = this;
       dns.lookup(host, function(err, ip) {
         if (err)
           return self.destroy(err);
         if (!ip)
           return self.destroy(new Error("Could not resolve " + host));
         self._connect(port, ip);
       });
     };
     Connection.prototype._connect = function(port, ip) {
       if (this.destroyed)
         return;
       this._needsConnect = false;
       this.remoteAddress = ip;
       binding.utp_napi_connect(this._utp._handle, this._handle, port, ip);
     };
     Connection.prototype._onconnect = function() {
       if (this._timeout)
         this._timeout.refresh();
       this._connected = true;
       if (this._writing) {
         const cb = this._callback;
         const data = this._writing[0];
         this._callback = null;
         this._writing = null;
         this._write(data, null, cb);
       }
       this.emit("connect");
     };
     Connection.prototype.destroy = function(err) {
       if (this.destroyed)
         return;
       this.destroyed = true;
       if (err)
         this._error = err;
       if (this._needsConnect)
         return process.nextTick(onbindingclose, this);
       binding.utp_napi_connection_close(this._handle);
     };
     Connection.prototype._destroyMaybe = function() {
       if (this._allowOpen && !--this._allowOpen)
         this.destroy();
     };
     Connection.prototype._shutdown = function() {
       if (this.destroyed)
         return;
       binding.utp_napi_connection_shutdown(this._handle);
       this._destroyMaybe();
     };
     function onbindingclose(self) {
       binding.utp_napi_connection_on_close(self._handle);
     }
     function createUTPError(code) {
       const str = UTP_ERRORS[code < 0 ? 3 : code];
       const err = new Error(str);
       err.code = str;
       err.errno = code;
       return err;
     }
   }
 });
 
 // node_modules/utp-native/index.js
 var require_utp_native = __commonJS({
   "node_modules/utp-native/index.js"(exports, module2) {
     var binding = require_binding();
     var Connection = require_connection();
     var util = require("util");
     var events = require("events");
     var dns = require("dns");
     var set = require_unordered_set();
     var EMPTY = Buffer.alloc(0);
     var IPv4Pattern = /^((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/;
     module2.exports = UTP;
     function UTP(opts) {
       if (!(this instanceof UTP))
         return new UTP(opts);
       events.EventEmitter.call(this);
       this.connections = [];
       this._sending = [];
       this._sent = [];
       this._offset = 0;
       this._buffer = Buffer.allocUnsafe(2 * 65536);
       this._handle = Buffer.alloc(binding.sizeof_utp_napi_t);
       this._nextConnection = Buffer.alloc(binding.sizeof_utp_napi_connection_t);
       this._address = null;
       this._inited = false;
       this._refed = true;
       this._closing = false;
       this._closed = false;
       this._allowHalfOpen = !opts || opts.allowHalfOpen !== false;
       this._acceptConnections = new Uint32Array(this._handle.buffer, this._handle.byteOffset + binding.offsetof_utp_napi_t_accept_connections, 1);
       this.maxConnections = 0;
     }
     util.inherits(UTP, events.EventEmitter);
     UTP.createServer = function(opts, onconnection) {
       if (typeof opts === "function")
         return UTP.createServer(null, opts);
       const server = new UTP(opts);
       if (onconnection)
         server.on("connection", onconnection);
       return server;
     };
     UTP.connect = function(port, host, opts) {
       const udp = new UTP(opts);
       return udp.connect(port, host).on("close", ononeoffclose);
     };
     UTP.prototype._init = function() {
       this._inited = true;
       binding.utp_napi_init(
         this._handle,
         this,
         this._nextConnection,
         this._buffer,
         this._onmessage,
         this._onsend,
         this._onconnection,
         this._onclose,
         this._realloc
       );
       if (!this._refed)
         this.unref();
     };
     UTP.prototype.firewall = function(yes) {
       this._acceptConnections[0] = yes ? 0 : 1;
     };
     UTP.prototype.ref = function() {
       if (this._inited)
         binding.utp_napi_ref(this._handle);
       this._refed = true;
     };
     UTP.prototype.unref = function() {
       if (this._inited)
         binding.utp_napi_unref(this._handle);
       this._refed = false;
     };
     UTP.prototype.address = function() {
       if (!this._address || this._closing)
         throw new Error("Socket not bound");
       return {
         address: this._address,
         family: "IPv4",
         port: binding.utp_napi_local_port(this._handle)
       };
     };
     UTP.prototype.getRecvBufferSize = function() {
       if (!this._inited)
         throw new Error("getRecvBufferSize EBADF");
       if (this._closing)
         return 0;
       return binding.utp_napi_recv_buffer(this._handle, 0);
     };
     UTP.prototype.setRecvBufferSize = function(n) {
       if (!this._inited)
         throw new Error("setRecvBufferSize EBADF");
       if (this._closing)
         return 0;
       return binding.utp_napi_recv_buffer(this._handle, n);
     };
     UTP.prototype.getSendBufferSize = function() {
       if (!this._inited)
         throw new Error("getSendBufferSize EBADF");
       if (this._closing)
         return 0;
       return binding.utp_napi_send_buffer(this._handle, 0);
     };
     UTP.prototype.setSendBufferSize = function(n) {
       if (!this._inited)
         throw new Error("setSendBufferSize EBADF");
       if (this._closing)
         return 0;
       return binding.utp_napi_send_buffer(this._handle, n);
     };
     UTP.prototype.setTTL = function(ttl) {
       if (!this._inited)
         throw new Error("setTTL EBADF");
       if (this._closing)
         return;
       binding.utp_napi_set_ttl(this._handle, ttl);
     };
     UTP.prototype.send = function(buf, offset, len, port, host, cb) {
       if (!cb)
         cb = noop2;
       if (!isIP(host))
         return this._resolveAndSend(buf, offset, len, port, host, cb);
       if (this._closing)
         return process.nextTick(cb, new Error("Socket is closed"));
       if (!this._address)
         this.bind(0);
       var send = this._sent.pop();
       if (!send) {
         send = new SendRequest();
         binding.utp_napi_send_request_init(send._handle, send);
       }
       send._index = this._sending.push(send) - 1;
       send._buffer = buf;
       send._callback = cb;
       binding.utp_napi_send(this._handle, send._handle, send._buffer, offset, len, port, host);
     };
     UTP.prototype._resolveAndSend = function(buf, offset, len, port, host, cb) {
       const self = this;
       dns.lookup(host, onlookup);
       function onlookup(err, ip) {
         if (err)
           return cb(err);
         if (!ip)
           return cb(new Error("Could not resolve " + host));
         self.send(buf, offset, len, port, ip, cb);
       }
     };
     UTP.prototype.close = function(onclose) {
       if (this._closed)
         return process.nextTick(callOnClose, this, onclose);
       if (onclose)
         this.once("close", onclose);
       if (this._closing)
         return;
       this._closing = true;
       this._closeMaybe();
     };
     UTP.prototype._closeMaybe = function() {
       if (this._closing && !this.connections.length && !this._sending.length && this._inited && !this._closed) {
         this._closed = true;
         binding.utp_napi_close(this._handle);
       }
     };
     UTP.prototype.connect = function(port, ip) {
       if (!this._inited)
         this.bind();
       if (!ip)
         ip = "127.0.0.1";
       const conn = new Connection(this, port, ip, null, this._allowHalfOpen);
       if (!isIP(ip))
         conn._resolveAndConnect(port, ip);
       else
         conn._connect(port, ip || "127.0.0.1");
       return conn;
     };
     UTP.prototype.listen = function(port, ip, onlistening) {
       if (!this._address)
         this.bind(port, ip, onlistening);
       this.firewall(false);
     };
     UTP.prototype.bind = function(port, ip, onlistening) {
       if (typeof port === "function")
         return this.bind(0, null, port);
       if (typeof ip === "function")
         return this.bind(port, null, ip);
       if (!port)
         port = 0;
       if (!ip)
         ip = "0.0.0.0";
       if (!this._inited)
         this._init();
       if (this._closing)
         return;
       if (this._address) {
         this.emit("error", new Error("Socket already bound"));
         return;
       }
       if (onlistening)
         this.once("listening", onlistening);
       if (!isIP(ip))
         return this._resolveAndBind(port, ip);
       this._address = ip;
       try {
         binding.utp_napi_bind(this._handle, port, ip);
       } catch (err) {
         this._address = null;
         process.nextTick(emitError, this, err);
         return;
       }
       process.nextTick(emitListening, this);
     };
     UTP.prototype._resolveAndBind = function(port, host) {
       const self = this;
       dns.lookup(host, function(err, ip) {
         if (err)
           return self.emit("error", err);
         self.bind(port, ip);
       });
     };
     UTP.prototype._realloc = function() {
       this._buffer = Buffer.allocUnsafe(this._buffer.length);
       this._offset = 0;
       return this._buffer;
     };
     UTP.prototype._onmessage = function(size, port, address) {
       if (size < 0) {
         this.emit("error", new Error("Read failed (status: " + size + ")"));
         return EMPTY;
       }
       const message = this._buffer.slice(this._offset, this._offset += size);
       this.emit("message", message, { address, family: "IPv4", port });
       if (this._buffer.length - this._offset <= 65536) {
         this._buffer = Buffer.allocUnsafe(this._buffer.length);
         this._offset = 0;
         return this._buffer;
       }
       return EMPTY;
     };
     UTP.prototype._onsend = function(send, status) {
       const cb = send._callback;
       send._callback = send._buffer = null;
       set.remove(this._sending, send);
       this._sent.push(send);
       if (this._closing)
         this._closeMaybe();
       cb(status < 0 ? new Error("Send failed (status: " + status + ")") : null);
     };
     UTP.prototype._onconnection = function(port, addr) {
       const conn = new Connection(this, port, addr, this._nextConnection, this._allowHalfOpen);
       process.nextTick(emitConnection, this, conn);
       this._nextConnection = Buffer.alloc(binding.sizeof_utp_napi_connection_t);
       return this._nextConnection;
     };
     UTP.prototype._onclose = function() {
       binding.utp_napi_destroy(this._handle, this._sent.map(toHandle));
       this._handle = null;
       this.emit("close");
     };
     function SendRequest() {
       this._handle = Buffer.alloc(binding.sizeof_utp_napi_send_request_t);
       this._buffer = null;
       this._callback = null;
       this._index = null;
     }
     function noop2() {
     }
     function isIP(ip) {
       return IPv4Pattern.test(ip);
     }
     function toHandle(obj) {
       return obj._handle;
     }
     function callOnClose(self, onclose) {
       if (onclose)
         onclose.call(self);
     }
     function emitListening(self) {
       self.emit("listening");
     }
     function emitConnection(self, connection) {
       self.emit("connection", connection);
     }
     function emitError(self, err) {
       self.emit("error", err);
     }
     function ononeoffclose() {
       this._utp.close();
     }
   }
 });
 
 // node_modules/webtorrent/lib/utp.js
 var require_utp = __commonJS({
   "node_modules/webtorrent/lib/utp.js"(exports, module2) {
     module2.exports = (() => {
       try {
         return require_utp_native();
       } catch (err) {
         console.warn("WebTorrent: uTP not supported", err);
         return {};
       }
     })();
   }
 });
 
 // node_modules/webtorrent/lib/conn-pool.js
 var require_conn_pool = __commonJS({
   "node_modules/webtorrent/lib/conn-pool.js"(exports, module2) {
     var net = require("net");
     var debugFactory = require_src();
     var queueMicrotask3 = require_queue_microtask();
     var Peer = require_peer();
     var utp = require_utp();
     var debug = debugFactory("webtorrent:conn-pool");
     var ConnPool = class {
       constructor(client) {
         debug("create pool (port %s)", client.torrentPort);
         this._client = client;
         this._pendingConns = /* @__PURE__ */ new Set();
         this._onTCPConnectionBound = (conn) => {
           this._onConnection(conn, "tcp");
         };
         this._onUTPConnectionBound = (conn) => {
           this._onConnection(conn, "utp");
         };
         this._onListening = () => {
           this._client._onListening();
         };
         this._onTCPError = (err) => {
           this._client._destroy(err);
         };
         this._onUTPError = () => {
           this._client.utp = false;
         };
         this.tcpServer = net.createServer();
         this.tcpServer.on("connection", this._onTCPConnectionBound);
         this.tcpServer.on("error", this._onTCPError);
         this.tcpServer.listen(client.torrentPort, () => {
           debug("creating tcpServer in port %s", this.tcpServer.address().port);
           if (this._client.utp) {
             this.utpServer = utp.createServer();
             this.utpServer.on("connection", this._onUTPConnectionBound);
             this.utpServer.on("listening", this._onListening);
             this.utpServer.on("error", this._onUTPError);
             debug("creating utpServer in port %s", this.tcpServer.address().port);
             this.utpServer.listen(this.tcpServer.address().port);
           } else {
             this._onListening();
           }
         });
       }
       destroy(cb) {
         debug("destroy conn pool");
         if (this.utpServer) {
           this.utpServer.removeListener("connection", this._onUTPConnectionBound);
           this.utpServer.removeListener("listening", this._onListening);
           this.utpServer.removeListener("error", this._onUTPError);
         }
         this.tcpServer.removeListener("connection", this._onTCPConnectionBound);
         this.tcpServer.removeListener("error", this._onTCPError);
         this._pendingConns.forEach((conn) => {
           conn.on("error", noop2);
           conn.destroy();
         });
         if (this.utpServer) {
           try {
             this.utpServer.close(cb);
           } catch (err) {
             if (cb)
               queueMicrotask3(cb);
           }
         }
         try {
           this.tcpServer.close(cb);
         } catch (err) {
           if (cb)
             queueMicrotask3(cb);
         }
         this.tcpServer = null;
         this.utpServer = null;
         this._client = null;
         this._pendingConns = null;
       }
       _onConnection(conn, type) {
         const self = this;
         if (!conn.remoteAddress) {
           conn.on("error", noop2);
           conn.destroy();
           return;
         }
         self._pendingConns.add(conn);
         conn.once("close", cleanupPending);
         const peer = type === "utp" ? Peer.createUTPIncomingPeer(conn, this._client.throttleGroups) : Peer.createTCPIncomingPeer(conn, this._client.throttleGroups);
         const wire = peer.wire;
         wire.once("pe3", onPe3);
         wire.once("handshake", onHandshake);
         function onPe3(infoHashHash) {
           const torrent = self._client._getByHash(infoHashHash);
           if (torrent) {
             peer.swarm = torrent;
             torrent._addIncomingPeer(peer);
             peer.onPe3(infoHashHash);
           } else {
             peer.destroy(new Error(`Unexpected info hash hash ${infoHashHash} from incoming peer ${peer.id}`));
           }
         }
         function onHandshake(infoHash, peerId) {
           cleanupPending();
           const torrent = self._client.get(infoHash);
           if (torrent) {
             if (!peer.swarm) {
               peer.swarm = torrent;
               torrent._addIncomingPeer(peer);
             }
             peer.onHandshake(infoHash, peerId);
           } else {
             const err = new Error(
               `Unexpected info hash ${infoHash} from incoming peer ${peer.id}`
             );
             peer.destroy(err);
           }
         }
         function cleanupPending() {
           conn.removeListener("close", cleanupPending);
           wire.removeListener("handshake", onHandshake);
           if (self._pendingConns) {
             self._pendingConns.delete(conn);
           }
         }
       }
     };
     ConnPool.UTP_SUPPORT = Object.keys(utp).length > 0;
     function noop2() {
     }
     module2.exports = ConnPool;
   }
 });
 
 // node_modules/addr-to-ip-port/index.js
 var require_addr_to_ip_port = __commonJS({
   "node_modules/addr-to-ip-port/index.js"(exports, module2) {
     var ADDR_RE = /^\[?([^\]]+)]?:(\d+)$/;
     var cache = /* @__PURE__ */ new Map();
     module2.exports = function addrToIPPort(addr) {
       if (cache.size === 1e5)
         cache.clear();
       if (!cache.has(addr)) {
         const m = ADDR_RE.exec(addr);
         if (!m)
           throw new Error(`invalid addr: ${addr}`);
         cache.set(addr, [m[1], Number(m[2])]);
       }
       return cache.get(addr);
     };
   }
 });
 
 // node_modules/cache-chunk-store/index.js
 var require_cache_chunk_store = __commonJS({
   "node_modules/cache-chunk-store/index.js"(exports, module2) {
     var LRU = require_lru();
     var queueMicrotask3 = require_queue_microtask();
     var CacheStore = class {
       constructor(store, opts) {
         this.store = store;
         this.chunkLength = store.chunkLength;
         this.inProgressGets = /* @__PURE__ */ new Map();
         if (!this.store || !this.store.get || !this.store.put) {
           throw new Error("First argument must be abstract-chunk-store compliant");
         }
         this.cache = new LRU(opts);
       }
       put(index, buf, cb = () => {
       }) {
         if (!this.cache) {
           return queueMicrotask3(() => cb(new Error("CacheStore closed")));
         }
         this.cache.remove(index);
         this.store.put(index, buf, cb);
       }
       get(index, opts, cb = () => {
       }) {
         if (typeof opts === "function")
           return this.get(index, null, opts);
         if (!this.cache) {
           return queueMicrotask3(() => cb(new Error("CacheStore closed")));
         }
         if (!opts)
           opts = {};
         let buf = this.cache.get(index);
         if (buf) {
           const offset = opts.offset || 0;
           const len = opts.length || buf.length - offset;
           if (offset !== 0 || len !== buf.length) {
             buf = buf.slice(offset, len + offset);
           }
           return queueMicrotask3(() => cb(null, buf));
         }
         let waiters = this.inProgressGets.get(index);
         const getAlreadyStarted = !!waiters;
         if (!waiters) {
           waiters = [];
           this.inProgressGets.set(index, waiters);
         }
         waiters.push({
           opts,
           cb
         });
         if (!getAlreadyStarted) {
           this.store.get(index, (err, buf2) => {
             if (!err && this.cache != null)
               this.cache.set(index, buf2);
             const inProgressEntry = this.inProgressGets.get(index);
             this.inProgressGets.delete(index);
             for (const { opts: opts2, cb: cb2 } of inProgressEntry) {
               if (err) {
                 cb2(err);
               } else {
                 const offset = opts2.offset || 0;
                 const len = opts2.length || buf2.length - offset;
                 let slicedBuf = buf2;
                 if (offset !== 0 || len !== buf2.length) {
                   slicedBuf = buf2.slice(offset, len + offset);
                 }
                 cb2(null, slicedBuf);
               }
             }
           });
         }
       }
       close(cb = () => {
       }) {
         if (!this.cache) {
           return queueMicrotask3(() => cb(new Error("CacheStore closed")));
         }
         this.cache = null;
         this.store.close(cb);
       }
       destroy(cb = () => {
       }) {
         if (!this.cache) {
           return queueMicrotask3(() => cb(new Error("CacheStore closed")));
         }
         this.cache = null;
         this.store.destroy(cb);
       }
     };
     module2.exports = CacheStore;
   }
 });
 
 // node_modules/block-stream2/index.js
 var require_block_stream2 = __commonJS({
   "node_modules/block-stream2/index.js"(exports, module2) {
     var { Transform } = require_readable();
     var Block = class extends Transform {
       constructor(size, opts = {}) {
         super(opts);
         if (typeof size === "object") {
           opts = size;
           size = opts.size;
         }
         this.size = size || 512;
         const { nopad, zeroPadding = true } = opts;
         if (nopad)
           this._zeroPadding = false;
         else
           this._zeroPadding = !!zeroPadding;
         this._buffered = [];
         this._bufferedBytes = 0;
       }
       _transform(buf, enc, next) {
         this._bufferedBytes += buf.length;
         this._buffered.push(buf);
         while (this._bufferedBytes >= this.size) {
           this._bufferedBytes -= this.size;
           const blockBufs = [];
           let blockBufsBytes = 0;
           while (blockBufsBytes < this.size) {
             const b = this._buffered.shift();
             if (blockBufsBytes + b.length <= this.size) {
               blockBufs.push(b);
               blockBufsBytes += b.length;
             } else {
               const neededSize = this.size - blockBufsBytes;
               blockBufs.push(b.slice(0, neededSize));
               blockBufsBytes += neededSize;
               this._buffered.unshift(b.slice(neededSize));
             }
           }
           this.push(Buffer.concat(blockBufs, this.size));
         }
         next();
       }
       _flush() {
         if (this._bufferedBytes && this._zeroPadding) {
           const zeroes = Buffer.alloc(this.size - this._bufferedBytes);
           this._buffered.push(zeroes);
           this.push(Buffer.concat(this._buffered));
           this._buffered = null;
         } else if (this._bufferedBytes) {
           this.push(Buffer.concat(this._buffered));
           this._buffered = null;
         }
         this.push(null);
       }
     };
     module2.exports = Block;
   }
 });
 
 // node_modules/chunk-store-stream/write.js
 var require_write = __commonJS({
   "node_modules/chunk-store-stream/write.js"(exports, module2) {
     var BlockStream = require_block_stream2();
     var stream = require_readable();
     var ChunkStoreWriteStream = class extends stream.Writable {
       constructor(store, chunkLength, opts = {}) {
         super(opts);
         if (!store || !store.put || !store.get) {
           throw new Error("First argument must be an abstract-chunk-store compliant store");
         }
         chunkLength = Number(chunkLength);
         if (!chunkLength)
           throw new Error("Second argument must be a chunk length");
         const zeroPadding = opts.zeroPadding === void 0 ? false : opts.zeroPadding;
         this._blockstream = new BlockStream(chunkLength, { ...opts, zeroPadding });
         this._outstandingPuts = 0;
         this._storeMaxOutstandingPuts = opts.storeMaxOutstandingPuts || 16;
         let index = 0;
         const onData = (chunk) => {
           if (this.destroyed)
             return;
           this._outstandingPuts += 1;
           if (this._outstandingPuts >= this._storeMaxOutstandingPuts) {
             this._blockstream.pause();
           }
           store.put(index, chunk, (err) => {
             if (err)
               return this.destroy(err);
             this._outstandingPuts -= 1;
             if (this._outstandingPuts < this._storeMaxOutstandingPuts) {
               this._blockstream.resume();
             }
             if (this._outstandingPuts === 0 && typeof this._finalCb === "function") {
               this._finalCb(null);
               this._finalCb = null;
             }
           });
           index += 1;
         };
         this._blockstream.on("data", onData).on("error", (err) => {
           this.destroy(err);
         });
       }
       _write(chunk, encoding, callback) {
         this._blockstream.write(chunk, encoding, callback);
       }
       _final(cb) {
         this._blockstream.end();
         this._blockstream.once("end", () => {
           if (this._outstandingPuts === 0)
             cb(null);
           else
             this._finalCb = cb;
         });
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         if (err)
           this.emit("error", err);
         this.emit("close");
       }
     };
     module2.exports = ChunkStoreWriteStream;
   }
 });
 
 // node_modules/cpus/index.js
 var require_cpus = __commonJS({
   "node_modules/cpus/index.js"(exports, module2) {
     var os2 = require("os");
     module2.exports = function cpus() {
       return os2.cpus();
     };
   }
 });
 
 // node_modules/bittorrent-tracker/lib/common-node.js
 var require_common_node = __commonJS({
   "node_modules/bittorrent-tracker/lib/common-node.js"(exports) {
     var querystring = require("querystring");
     exports.IPV4_RE = /^[\d.]+$/;
     exports.IPV6_RE = /^[\da-fA-F:]+$/;
     exports.REMOVE_IPV4_MAPPED_IPV6_RE = /^::ffff:/;
     exports.CONNECTION_ID = Buffer.concat([toUInt32(1047), toUInt32(655366528)]);
     exports.ACTIONS = { CONNECT: 0, ANNOUNCE: 1, SCRAPE: 2, ERROR: 3 };
     exports.EVENTS = { update: 0, completed: 1, started: 2, stopped: 3, paused: 4 };
     exports.EVENT_IDS = {
       0: "update",
       1: "completed",
       2: "started",
       3: "stopped",
       4: "paused"
     };
     exports.EVENT_NAMES = {
       update: "update",
       completed: "complete",
       started: "start",
       stopped: "stop",
       paused: "pause"
     };
     exports.REQUEST_TIMEOUT = 15e3;
     exports.DESTROY_TIMEOUT = 1e3;
     function toUInt32(n) {
       const buf = Buffer.allocUnsafe(4);
       buf.writeUInt32BE(n, 0);
       return buf;
     }
     exports.toUInt32 = toUInt32;
     exports.querystringParse = (q) => querystring.parse(q, null, null, { decodeURIComponent: unescape });
     exports.querystringStringify = (obj) => {
       let ret = querystring.stringify(obj, null, null, { encodeURIComponent: escape });
       ret = ret.replace(/[@*/+]/g, (char) => `%${char.charCodeAt(0).toString(16).toUpperCase()}`);
       return ret;
     };
   }
 });
 
 // node_modules/bittorrent-tracker/lib/common.js
 var require_common2 = __commonJS({
   "node_modules/bittorrent-tracker/lib/common.js"(exports) {
     exports.DEFAULT_ANNOUNCE_PEERS = 50;
     exports.MAX_ANNOUNCE_PEERS = 82;
     exports.binaryToHex = (str) => {
       if (typeof str !== "string") {
         str = String(str);
       }
       return Buffer.from(str, "binary").toString("hex");
     };
     exports.hexToBinary = (str) => {
       if (typeof str !== "string") {
         str = String(str);
       }
       return Buffer.from(str, "hex").toString("binary");
     };
     exports.parseUrl = (str) => {
       const url = new URL(str.replace(/^udp:/, "http:"));
       if (str.match(/^udp:/)) {
         Object.defineProperties(url, {
           href: { value: url.href.replace(/^http/, "udp") },
           protocol: { value: url.protocol.replace(/^http/, "udp") },
           origin: { value: url.origin.replace(/^http/, "udp") }
         });
       }
       return url;
     };
     var config = require_common_node();
     Object.assign(exports, config);
   }
 });
 
 // node_modules/clone/clone.js
 var require_clone = __commonJS({
   "node_modules/clone/clone.js"(exports, module2) {
     var clone = function() {
       "use strict";
       function _instanceof(obj, type) {
         return type != null && obj instanceof type;
       }
       var nativeMap;
       try {
         nativeMap = Map;
       } catch (_) {
         nativeMap = function() {
         };
       }
       var nativeSet;
       try {
         nativeSet = Set;
       } catch (_) {
         nativeSet = function() {
         };
       }
       var nativePromise;
       try {
         nativePromise = Promise;
       } catch (_) {
         nativePromise = function() {
         };
       }
       function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
         if (typeof circular === "object") {
           depth = circular.depth;
           prototype = circular.prototype;
           includeNonEnumerable = circular.includeNonEnumerable;
           circular = circular.circular;
         }
         var allParents = [];
         var allChildren = [];
         var useBuffer = typeof Buffer != "undefined";
         if (typeof circular == "undefined")
           circular = true;
         if (typeof depth == "undefined")
           depth = Infinity;
         function _clone(parent2, depth2) {
           if (parent2 === null)
             return null;
           if (depth2 === 0)
             return parent2;
           var child;
           var proto;
           if (typeof parent2 != "object") {
             return parent2;
           }
           if (_instanceof(parent2, nativeMap)) {
             child = new nativeMap();
           } else if (_instanceof(parent2, nativeSet)) {
             child = new nativeSet();
           } else if (_instanceof(parent2, nativePromise)) {
             child = new nativePromise(function(resolve, reject) {
               parent2.then(function(value) {
                 resolve(_clone(value, depth2 - 1));
               }, function(err) {
                 reject(_clone(err, depth2 - 1));
               });
             });
           } else if (clone2.__isArray(parent2)) {
             child = [];
           } else if (clone2.__isRegExp(parent2)) {
             child = new RegExp(parent2.source, __getRegExpFlags(parent2));
             if (parent2.lastIndex)
               child.lastIndex = parent2.lastIndex;
           } else if (clone2.__isDate(parent2)) {
             child = new Date(parent2.getTime());
           } else if (useBuffer && Buffer.isBuffer(parent2)) {
             if (Buffer.allocUnsafe) {
               child = Buffer.allocUnsafe(parent2.length);
             } else {
               child = new Buffer(parent2.length);
             }
             parent2.copy(child);
             return child;
           } else if (_instanceof(parent2, Error)) {
             child = Object.create(parent2);
           } else {
             if (typeof prototype == "undefined") {
               proto = Object.getPrototypeOf(parent2);
               child = Object.create(proto);
             } else {
               child = Object.create(prototype);
               proto = prototype;
             }
           }
           if (circular) {
             var index = allParents.indexOf(parent2);
             if (index != -1) {
               return allChildren[index];
             }
             allParents.push(parent2);
             allChildren.push(child);
           }
           if (_instanceof(parent2, nativeMap)) {
             parent2.forEach(function(value, key) {
               var keyChild = _clone(key, depth2 - 1);
               var valueChild = _clone(value, depth2 - 1);
               child.set(keyChild, valueChild);
             });
           }
           if (_instanceof(parent2, nativeSet)) {
             parent2.forEach(function(value) {
               var entryChild = _clone(value, depth2 - 1);
               child.add(entryChild);
             });
           }
           for (var i in parent2) {
             var attrs;
             if (proto) {
               attrs = Object.getOwnPropertyDescriptor(proto, i);
             }
             if (attrs && attrs.set == null) {
               continue;
             }
             child[i] = _clone(parent2[i], depth2 - 1);
           }
           if (Object.getOwnPropertySymbols) {
             var symbols = Object.getOwnPropertySymbols(parent2);
             for (var i = 0; i < symbols.length; i++) {
               var symbol = symbols[i];
               var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
               if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                 continue;
               }
               child[symbol] = _clone(parent2[symbol], depth2 - 1);
               if (!descriptor.enumerable) {
                 Object.defineProperty(child, symbol, {
                   enumerable: false
                 });
               }
             }
           }
           if (includeNonEnumerable) {
             var allPropertyNames = Object.getOwnPropertyNames(parent2);
             for (var i = 0; i < allPropertyNames.length; i++) {
               var propertyName = allPropertyNames[i];
               var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
               if (descriptor && descriptor.enumerable) {
                 continue;
               }
               child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
               Object.defineProperty(child, propertyName, {
                 enumerable: false
               });
             }
           }
           return child;
         }
         return _clone(parent, depth);
       }
       clone2.clonePrototype = function clonePrototype(parent) {
         if (parent === null)
           return null;
         var c = function() {
         };
         c.prototype = parent;
         return new c();
       };
       function __objToStr(o) {
         return Object.prototype.toString.call(o);
       }
       clone2.__objToStr = __objToStr;
       function __isDate(o) {
         return typeof o === "object" && __objToStr(o) === "[object Date]";
       }
       clone2.__isDate = __isDate;
       function __isArray(o) {
         return typeof o === "object" && __objToStr(o) === "[object Array]";
       }
       clone2.__isArray = __isArray;
       function __isRegExp(o) {
         return typeof o === "object" && __objToStr(o) === "[object RegExp]";
       }
       clone2.__isRegExp = __isRegExp;
       function __getRegExpFlags(re) {
         var flags = "";
         if (re.global)
           flags += "g";
         if (re.ignoreCase)
           flags += "i";
         if (re.multiline)
           flags += "m";
         return flags;
       }
       clone2.__getRegExpFlags = __getRegExpFlags;
       return clone2;
     }();
     if (typeof module2 === "object" && module2.exports) {
       module2.exports = clone;
     }
   }
 });
 
 // node_modules/ipaddr.js/lib/ipaddr.js
 var require_ipaddr = __commonJS({
   "node_modules/ipaddr.js/lib/ipaddr.js"(exports, module2) {
     (function(root) {
       "use strict";
       const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
       const ipv4Regexes = {
         fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
         threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
         twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
         longValue: new RegExp(`^${ipv4Part}$`, "i")
       };
       const octalRegex = new RegExp(`^0[0-7]+$`, "i");
       const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
       const zoneIndex = "%[0-9a-z]{1,}";
       const ipv6Part = "(?:[0-9a-f]+::?)+";
       const ipv6Regexes = {
         zoneIndex: new RegExp(zoneIndex, "i"),
         "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
         deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
         transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
       };
       function expandIPv6(string, parts) {
         if (string.indexOf("::") !== string.lastIndexOf("::")) {
           return null;
         }
         let colonCount = 0;
         let lastColon = -1;
         let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
         let replacement, replacementCount;
         if (zoneId) {
           zoneId = zoneId.substring(1);
           string = string.replace(/%.+$/, "");
         }
         while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
           colonCount++;
         }
         if (string.substr(0, 2) === "::") {
           colonCount--;
         }
         if (string.substr(-2, 2) === "::") {
           colonCount--;
         }
         if (colonCount > parts) {
           return null;
         }
         replacementCount = parts - colonCount;
         replacement = ":";
         while (replacementCount--) {
           replacement += "0:";
         }
         string = string.replace("::", replacement);
         if (string[0] === ":") {
           string = string.slice(1);
         }
         if (string[string.length - 1] === ":") {
           string = string.slice(0, -1);
         }
         parts = function() {
           const ref = string.split(":");
           const results = [];
           for (let i = 0; i < ref.length; i++) {
             results.push(parseInt(ref[i], 16));
           }
           return results;
         }();
         return {
           parts,
           zoneId
         };
       }
       function matchCIDR(first, second, partSize, cidrBits) {
         if (first.length !== second.length) {
           throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
         }
         let part = 0;
         let shift;
         while (cidrBits > 0) {
           shift = partSize - cidrBits;
           if (shift < 0) {
             shift = 0;
           }
           if (first[part] >> shift !== second[part] >> shift) {
             return false;
           }
           cidrBits -= partSize;
           part += 1;
         }
         return true;
       }
       function parseIntAuto(string) {
         if (hexRegex.test(string)) {
           return parseInt(string, 16);
         }
         if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
           if (octalRegex.test(string)) {
             return parseInt(string, 8);
           }
           throw new Error(`ipaddr: cannot parse ${string} as octal`);
         }
         return parseInt(string, 10);
       }
       function padPart(part, length) {
         while (part.length < length) {
           part = `0${part}`;
         }
         return part;
       }
       const ipaddr = {};
       ipaddr.IPv4 = function() {
         function IPv4(octets) {
           if (octets.length !== 4) {
             throw new Error("ipaddr: ipv4 octet count should be 4");
           }
           let i, octet;
           for (i = 0; i < octets.length; i++) {
             octet = octets[i];
             if (!(0 <= octet && octet <= 255)) {
               throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
             }
           }
           this.octets = octets;
         }
         IPv4.prototype.SpecialRanges = {
           unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
           broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
           multicast: [[new IPv4([224, 0, 0, 0]), 4]],
           linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
           loopback: [[new IPv4([127, 0, 0, 0]), 8]],
           carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
           "private": [
             [new IPv4([10, 0, 0, 0]), 8],
             [new IPv4([172, 16, 0, 0]), 12],
             [new IPv4([192, 168, 0, 0]), 16]
           ],
           reserved: [
             [new IPv4([192, 0, 0, 0]), 24],
             [new IPv4([192, 0, 2, 0]), 24],
             [new IPv4([192, 88, 99, 0]), 24],
             [new IPv4([198, 51, 100, 0]), 24],
             [new IPv4([203, 0, 113, 0]), 24],
             [new IPv4([240, 0, 0, 0]), 4]
           ]
         };
         IPv4.prototype.kind = function() {
           return "ipv4";
         };
         IPv4.prototype.match = function(other, cidrRange) {
           let ref;
           if (cidrRange === void 0) {
             ref = other;
             other = ref[0];
             cidrRange = ref[1];
           }
           if (other.kind() !== "ipv4") {
             throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
           }
           return matchCIDR(this.octets, other.octets, 8, cidrRange);
         };
         IPv4.prototype.prefixLengthFromSubnetMask = function() {
           let cidr = 0;
           let stop = false;
           const zerotable = {
             0: 8,
             128: 7,
             192: 6,
             224: 5,
             240: 4,
             248: 3,
             252: 2,
             254: 1,
             255: 0
           };
           let i, octet, zeros;
           for (i = 3; i >= 0; i -= 1) {
             octet = this.octets[i];
             if (octet in zerotable) {
               zeros = zerotable[octet];
               if (stop && zeros !== 0) {
                 return null;
               }
               if (zeros !== 8) {
                 stop = true;
               }
               cidr += zeros;
             } else {
               return null;
             }
           }
           return 32 - cidr;
         };
         IPv4.prototype.range = function() {
           return ipaddr.subnetMatch(this, this.SpecialRanges);
         };
         IPv4.prototype.toByteArray = function() {
           return this.octets.slice(0);
         };
         IPv4.prototype.toIPv4MappedAddress = function() {
           return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
         };
         IPv4.prototype.toNormalizedString = function() {
           return this.toString();
         };
         IPv4.prototype.toString = function() {
           return this.octets.join(".");
         };
         return IPv4;
       }();
       ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
         try {
           const cidr = this.parseCIDR(string);
           const ipInterfaceOctets = cidr[0].toByteArray();
           const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
           const octets = [];
           let i = 0;
           while (i < 4) {
             octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
             i++;
           }
           return new this(octets);
         } catch (e) {
           throw new Error("ipaddr: the address does not have IPv4 CIDR format");
         }
       };
       ipaddr.IPv4.isIPv4 = function(string) {
         return this.parser(string) !== null;
       };
       ipaddr.IPv4.isValid = function(string) {
         try {
           new this(this.parser(string));
           return true;
         } catch (e) {
           return false;
         }
       };
       ipaddr.IPv4.isValidFourPartDecimal = function(string) {
         if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
           return true;
         } else {
           return false;
         }
       };
       ipaddr.IPv4.networkAddressFromCIDR = function(string) {
         let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
         try {
           cidr = this.parseCIDR(string);
           ipInterfaceOctets = cidr[0].toByteArray();
           subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
           octets = [];
           i = 0;
           while (i < 4) {
             octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
             i++;
           }
           return new this(octets);
         } catch (e) {
           throw new Error("ipaddr: the address does not have IPv4 CIDR format");
         }
       };
       ipaddr.IPv4.parse = function(string) {
         const parts = this.parser(string);
         if (parts === null) {
           throw new Error("ipaddr: string is not formatted like an IPv4 Address");
         }
         return new this(parts);
       };
       ipaddr.IPv4.parseCIDR = function(string) {
         let match;
         if (match = string.match(/^(.+)\/(\d+)$/)) {
           const maskLength = parseInt(match[2]);
           if (maskLength >= 0 && maskLength <= 32) {
             const parsed = [this.parse(match[1]), maskLength];
             Object.defineProperty(parsed, "toString", {
               value: function() {
                 return this.join("/");
               }
             });
             return parsed;
           }
         }
         throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
       };
       ipaddr.IPv4.parser = function(string) {
         let match, part, value;
         if (match = string.match(ipv4Regexes.fourOctet)) {
           return function() {
             const ref = match.slice(1, 6);
             const results = [];
             for (let i = 0; i < ref.length; i++) {
               part = ref[i];
               results.push(parseIntAuto(part));
             }
             return results;
           }();
         } else if (match = string.match(ipv4Regexes.longValue)) {
           value = parseIntAuto(match[1]);
           if (value > 4294967295 || value < 0) {
             throw new Error("ipaddr: address outside defined range");
           }
           return function() {
             const results = [];
             let shift;
             for (shift = 0; shift <= 24; shift += 8) {
               results.push(value >> shift & 255);
             }
             return results;
           }().reverse();
         } else if (match = string.match(ipv4Regexes.twoOctet)) {
           return function() {
             const ref = match.slice(1, 4);
             const results = [];
             value = parseIntAuto(ref[1]);
             if (value > 16777215 || value < 0) {
               throw new Error("ipaddr: address outside defined range");
             }
             results.push(parseIntAuto(ref[0]));
             results.push(value >> 16 & 255);
             results.push(value >> 8 & 255);
             results.push(value & 255);
             return results;
           }();
         } else if (match = string.match(ipv4Regexes.threeOctet)) {
           return function() {
             const ref = match.slice(1, 5);
             const results = [];
             value = parseIntAuto(ref[2]);
             if (value > 65535 || value < 0) {
               throw new Error("ipaddr: address outside defined range");
             }
             results.push(parseIntAuto(ref[0]));
             results.push(parseIntAuto(ref[1]));
             results.push(value >> 8 & 255);
             results.push(value & 255);
             return results;
           }();
         } else {
           return null;
         }
       };
       ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
         prefix = parseInt(prefix);
         if (prefix < 0 || prefix > 32) {
           throw new Error("ipaddr: invalid IPv4 prefix length");
         }
         const octets = [0, 0, 0, 0];
         let j = 0;
         const filledOctetCount = Math.floor(prefix / 8);
         while (j < filledOctetCount) {
           octets[j] = 255;
           j++;
         }
         if (filledOctetCount < 4) {
           octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
         }
         return new this(octets);
       };
       ipaddr.IPv6 = function() {
         function IPv6(parts, zoneId) {
           let i, part;
           if (parts.length === 16) {
             this.parts = [];
             for (i = 0; i <= 14; i += 2) {
               this.parts.push(parts[i] << 8 | parts[i + 1]);
             }
           } else if (parts.length === 8) {
             this.parts = parts;
           } else {
             throw new Error("ipaddr: ipv6 part count should be 8 or 16");
           }
           for (i = 0; i < this.parts.length; i++) {
             part = this.parts[i];
             if (!(0 <= part && part <= 65535)) {
               throw new Error("ipaddr: ipv6 part should fit in 16 bits");
             }
           }
           if (zoneId) {
             this.zoneId = zoneId;
           }
         }
         IPv6.prototype.SpecialRanges = {
           unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
           linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
           multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
           loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
           uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
           ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
           rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
           rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
           "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
           teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
           reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
         };
         IPv6.prototype.isIPv4MappedAddress = function() {
           return this.range() === "ipv4Mapped";
         };
         IPv6.prototype.kind = function() {
           return "ipv6";
         };
         IPv6.prototype.match = function(other, cidrRange) {
           let ref;
           if (cidrRange === void 0) {
             ref = other;
             other = ref[0];
             cidrRange = ref[1];
           }
           if (other.kind() !== "ipv6") {
             throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
           }
           return matchCIDR(this.parts, other.parts, 16, cidrRange);
         };
         IPv6.prototype.prefixLengthFromSubnetMask = function() {
           let cidr = 0;
           let stop = false;
           const zerotable = {
             0: 16,
             32768: 15,
             49152: 14,
             57344: 13,
             61440: 12,
             63488: 11,
             64512: 10,
             65024: 9,
             65280: 8,
             65408: 7,
             65472: 6,
             65504: 5,
             65520: 4,
             65528: 3,
             65532: 2,
             65534: 1,
             65535: 0
           };
           let part, zeros;
           for (let i = 7; i >= 0; i -= 1) {
             part = this.parts[i];
             if (part in zerotable) {
               zeros = zerotable[part];
               if (stop && zeros !== 0) {
                 return null;
               }
               if (zeros !== 16) {
                 stop = true;
               }
               cidr += zeros;
             } else {
               return null;
             }
           }
           return 128 - cidr;
         };
         IPv6.prototype.range = function() {
           return ipaddr.subnetMatch(this, this.SpecialRanges);
         };
         IPv6.prototype.toByteArray = function() {
           let part;
           const bytes = [];
           const ref = this.parts;
           for (let i = 0; i < ref.length; i++) {
             part = ref[i];
             bytes.push(part >> 8);
             bytes.push(part & 255);
           }
           return bytes;
         };
         IPv6.prototype.toFixedLengthString = function() {
           const addr = function() {
             const results = [];
             for (let i = 0; i < this.parts.length; i++) {
               results.push(padPart(this.parts[i].toString(16), 4));
             }
             return results;
           }.call(this).join(":");
           let suffix = "";
           if (this.zoneId) {
             suffix = `%${this.zoneId}`;
           }
           return addr + suffix;
         };
         IPv6.prototype.toIPv4Address = function() {
           if (!this.isIPv4MappedAddress()) {
             throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
           }
           const ref = this.parts.slice(-2);
           const high = ref[0];
           const low = ref[1];
           return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
         };
         IPv6.prototype.toNormalizedString = function() {
           const addr = function() {
             const results = [];
             for (let i = 0; i < this.parts.length; i++) {
               results.push(this.parts[i].toString(16));
             }
             return results;
           }.call(this).join(":");
           let suffix = "";
           if (this.zoneId) {
             suffix = `%${this.zoneId}`;
           }
           return addr + suffix;
         };
         IPv6.prototype.toRFC5952String = function() {
           const regex = /((^|:)(0(:|$)){2,})/g;
           const string = this.toNormalizedString();
           let bestMatchIndex = 0;
           let bestMatchLength = -1;
           let match;
           while (match = regex.exec(string)) {
             if (match[0].length > bestMatchLength) {
               bestMatchIndex = match.index;
               bestMatchLength = match[0].length;
             }
           }
           if (bestMatchLength < 0) {
             return string;
           }
           return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
         };
         IPv6.prototype.toString = function() {
           return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
         };
         return IPv6;
       }();
       ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
         try {
           const cidr = this.parseCIDR(string);
           const ipInterfaceOctets = cidr[0].toByteArray();
           const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
           const octets = [];
           let i = 0;
           while (i < 16) {
             octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
             i++;
           }
           return new this(octets);
         } catch (e) {
           throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
         }
       };
       ipaddr.IPv6.isIPv6 = function(string) {
         return this.parser(string) !== null;
       };
       ipaddr.IPv6.isValid = function(string) {
         if (typeof string === "string" && string.indexOf(":") === -1) {
           return false;
         }
         try {
           const addr = this.parser(string);
           new this(addr.parts, addr.zoneId);
           return true;
         } catch (e) {
           return false;
         }
       };
       ipaddr.IPv6.networkAddressFromCIDR = function(string) {
         let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
         try {
           cidr = this.parseCIDR(string);
           ipInterfaceOctets = cidr[0].toByteArray();
           subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
           octets = [];
           i = 0;
           while (i < 16) {
             octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
             i++;
           }
           return new this(octets);
         } catch (e) {
           throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
         }
       };
       ipaddr.IPv6.parse = function(string) {
         const addr = this.parser(string);
         if (addr.parts === null) {
           throw new Error("ipaddr: string is not formatted like an IPv6 Address");
         }
         return new this(addr.parts, addr.zoneId);
       };
       ipaddr.IPv6.parseCIDR = function(string) {
         let maskLength, match, parsed;
         if (match = string.match(/^(.+)\/(\d+)$/)) {
           maskLength = parseInt(match[2]);
           if (maskLength >= 0 && maskLength <= 128) {
             parsed = [this.parse(match[1]), maskLength];
             Object.defineProperty(parsed, "toString", {
               value: function() {
                 return this.join("/");
               }
             });
             return parsed;
           }
         }
         throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
       };
       ipaddr.IPv6.parser = function(string) {
         let addr, i, match, octet, octets, zoneId;
         if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
           return this.parser(`::ffff:${match[1]}`);
         }
         if (ipv6Regexes.native.test(string)) {
           return expandIPv6(string, 8);
         }
         if (match = string.match(ipv6Regexes.transitional)) {
           zoneId = match[6] || "";
           addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
           if (addr.parts) {
             octets = [
               parseInt(match[2]),
               parseInt(match[3]),
               parseInt(match[4]),
               parseInt(match[5])
             ];
             for (i = 0; i < octets.length; i++) {
               octet = octets[i];
               if (!(0 <= octet && octet <= 255)) {
                 return null;
               }
             }
             addr.parts.push(octets[0] << 8 | octets[1]);
             addr.parts.push(octets[2] << 8 | octets[3]);
             return {
               parts: addr.parts,
               zoneId: addr.zoneId
             };
           }
         }
         return null;
       };
       ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
         prefix = parseInt(prefix);
         if (prefix < 0 || prefix > 128) {
           throw new Error("ipaddr: invalid IPv6 prefix length");
         }
         const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
         let j = 0;
         const filledOctetCount = Math.floor(prefix / 8);
         while (j < filledOctetCount) {
           octets[j] = 255;
           j++;
         }
         if (filledOctetCount < 16) {
           octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
         }
         return new this(octets);
       };
       ipaddr.fromByteArray = function(bytes) {
         const length = bytes.length;
         if (length === 4) {
           return new ipaddr.IPv4(bytes);
         } else if (length === 16) {
           return new ipaddr.IPv6(bytes);
         } else {
           throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
         }
       };
       ipaddr.isValid = function(string) {
         return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
       };
       ipaddr.parse = function(string) {
         if (ipaddr.IPv6.isValid(string)) {
           return ipaddr.IPv6.parse(string);
         } else if (ipaddr.IPv4.isValid(string)) {
           return ipaddr.IPv4.parse(string);
         } else {
           throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
         }
       };
       ipaddr.parseCIDR = function(string) {
         try {
           return ipaddr.IPv6.parseCIDR(string);
         } catch (e) {
           try {
             return ipaddr.IPv4.parseCIDR(string);
           } catch (e2) {
             throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
           }
         }
       };
       ipaddr.process = function(string) {
         const addr = this.parse(string);
         if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
           return addr.toIPv4Address();
         } else {
           return addr;
         }
       };
       ipaddr.subnetMatch = function(address, rangeList, defaultName) {
         let i, rangeName, rangeSubnets, subnet;
         if (defaultName === void 0 || defaultName === null) {
           defaultName = "unicast";
         }
         for (rangeName in rangeList) {
           if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
             rangeSubnets = rangeList[rangeName];
             if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
               rangeSubnets = [rangeSubnets];
             }
             for (i = 0; i < rangeSubnets.length; i++) {
               subnet = rangeSubnets[i];
               if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                 return rangeName;
               }
             }
           }
         }
         return defaultName;
       };
       if (typeof module2 !== "undefined" && module2.exports) {
         module2.exports = ipaddr;
       } else {
         root.ipaddr = ipaddr;
       }
     })(exports);
   }
 });
 
 // node_modules/compact2string/index.js
 var require_compact2string = __commonJS({
   "node_modules/compact2string/index.js"(exports, module2) {
     var ipaddr = require_ipaddr();
     var compact2string = function(buf) {
       switch (buf.length) {
         case 6:
           return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3] + ":" + buf.readUInt16BE(4);
           break;
         case 18:
           var hexGroups = [];
           for (var i = 0; i < 8; i++) {
             hexGroups.push(buf.readUInt16BE(i * 2).toString(16));
           }
           var host = ipaddr.parse(hexGroups.join(":")).toString();
           return "[" + host + "]:" + buf.readUInt16BE(16);
         default:
           throw new Error("Invalid Compact IP/PORT, It should contain 6 or 18 bytes");
       }
     };
     compact2string.multi = function(buf) {
       if (buf.length % 6 !== 0)
         throw new Error("buf length isn't multiple of compact IP/PORTs (6 bytes)");
       var output = [];
       for (var i = 0; i <= buf.length - 1; i = i + 6) {
         output.push(compact2string(buf.slice(i, i + 6)));
       }
       return output;
     };
     compact2string.multi6 = function(buf) {
       if (buf.length % 18 !== 0)
         throw new Error("buf length isn't multiple of compact IP6/PORTs (18 bytes)");
       var output = [];
       for (var i = 0; i <= buf.length - 1; i = i + 18) {
         output.push(compact2string(buf.slice(i, i + 18)));
       }
       return output;
     };
     module2.exports = compact2string;
   }
 });
 
 // node_modules/socks/node_modules/ip/lib/ip.js
 var require_ip2 = __commonJS({
   "node_modules/socks/node_modules/ip/lib/ip.js"(exports) {
     var ip = exports;
     var { Buffer: Buffer2 } = require("buffer");
     var os2 = require("os");
     ip.toBuffer = function(ip2, buff, offset) {
       offset = ~~offset;
       let result;
       if (this.isV4Format(ip2)) {
         result = buff || Buffer2.alloc(offset + 4);
         ip2.split(/\./g).map((byte) => {
           result[offset++] = parseInt(byte, 10) & 255;
         });
       } else if (this.isV6Format(ip2)) {
         const sections = ip2.split(":", 8);
         let i;
         for (i = 0; i < sections.length; i++) {
           const isv4 = this.isV4Format(sections[i]);
           let v4Buffer;
           if (isv4) {
             v4Buffer = this.toBuffer(sections[i]);
             sections[i] = v4Buffer.slice(0, 2).toString("hex");
           }
           if (v4Buffer && ++i < 8) {
             sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
           }
         }
         if (sections[0] === "") {
           while (sections.length < 8)
             sections.unshift("0");
         } else if (sections[sections.length - 1] === "") {
           while (sections.length < 8)
             sections.push("0");
         } else if (sections.length < 8) {
           for (i = 0; i < sections.length && sections[i] !== ""; i++)
             ;
           const argv = [i, 1];
           for (i = 9 - sections.length; i > 0; i--) {
             argv.push("0");
           }
           sections.splice(...argv);
         }
         result = buff || Buffer2.alloc(offset + 16);
         for (i = 0; i < sections.length; i++) {
           const word = parseInt(sections[i], 16);
           result[offset++] = word >> 8 & 255;
           result[offset++] = word & 255;
         }
       }
       if (!result) {
         throw Error(`Invalid ip address: ${ip2}`);
       }
       return result;
     };
     ip.toString = function(buff, offset, length) {
       offset = ~~offset;
       length = length || buff.length - offset;
       let result = [];
       if (length === 4) {
         for (let i = 0; i < length; i++) {
           result.push(buff[offset + i]);
         }
         result = result.join(".");
       } else if (length === 16) {
         for (let i = 0; i < length; i += 2) {
           result.push(buff.readUInt16BE(offset + i).toString(16));
         }
         result = result.join(":");
         result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
         result = result.replace(/:{3,4}/, "::");
       }
       return result;
     };
     var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
     var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
     ip.isV4Format = function(ip2) {
       return ipv4Regex.test(ip2);
     };
     ip.isV6Format = function(ip2) {
       return ipv6Regex.test(ip2);
     };
     function _normalizeFamily(family) {
       if (family === 4) {
         return "ipv4";
       }
       if (family === 6) {
         return "ipv6";
       }
       return family ? family.toLowerCase() : "ipv4";
     }
     ip.fromPrefixLen = function(prefixlen, family) {
       if (prefixlen > 32) {
         family = "ipv6";
       } else {
         family = _normalizeFamily(family);
       }
       let len = 4;
       if (family === "ipv6") {
         len = 16;
       }
       const buff = Buffer2.alloc(len);
       for (let i = 0, n = buff.length; i < n; ++i) {
         let bits = 8;
         if (prefixlen < 8) {
           bits = prefixlen;
         }
         prefixlen -= bits;
         buff[i] = ~(255 >> bits) & 255;
       }
       return ip.toString(buff);
     };
     ip.mask = function(addr, mask) {
       addr = ip.toBuffer(addr);
       mask = ip.toBuffer(mask);
       const result = Buffer2.alloc(Math.max(addr.length, mask.length));
       let i;
       if (addr.length === mask.length) {
         for (i = 0; i < addr.length; i++) {
           result[i] = addr[i] & mask[i];
         }
       } else if (mask.length === 4) {
         for (i = 0; i < mask.length; i++) {
           result[i] = addr[addr.length - 4 + i] & mask[i];
         }
       } else {
         for (i = 0; i < result.length - 6; i++) {
           result[i] = 0;
         }
         result[10] = 255;
         result[11] = 255;
         for (i = 0; i < addr.length; i++) {
           result[i + 12] = addr[i] & mask[i + 12];
         }
         i += 12;
       }
       for (; i < result.length; i++) {
         result[i] = 0;
       }
       return ip.toString(result);
     };
     ip.cidr = function(cidrString) {
       const cidrParts = cidrString.split("/");
       const addr = cidrParts[0];
       if (cidrParts.length !== 2) {
         throw new Error(`invalid CIDR subnet: ${addr}`);
       }
       const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
       return ip.mask(addr, mask);
     };
     ip.subnet = function(addr, mask) {
       const networkAddress = ip.toLong(ip.mask(addr, mask));
       const maskBuffer = ip.toBuffer(mask);
       let maskLength = 0;
       for (let i = 0; i < maskBuffer.length; i++) {
         if (maskBuffer[i] === 255) {
           maskLength += 8;
         } else {
           let octet = maskBuffer[i] & 255;
           while (octet) {
             octet = octet << 1 & 255;
             maskLength++;
           }
         }
       }
       const numberOfAddresses = 2 ** (32 - maskLength);
       return {
         networkAddress: ip.fromLong(networkAddress),
         firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
         lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
         broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
         subnetMask: mask,
         subnetMaskLength: maskLength,
         numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
         length: numberOfAddresses,
         contains(other) {
           return networkAddress === ip.toLong(ip.mask(other, mask));
         }
       };
     };
     ip.cidrSubnet = function(cidrString) {
       const cidrParts = cidrString.split("/");
       const addr = cidrParts[0];
       if (cidrParts.length !== 2) {
         throw new Error(`invalid CIDR subnet: ${addr}`);
       }
       const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
       return ip.subnet(addr, mask);
     };
     ip.not = function(addr) {
       const buff = ip.toBuffer(addr);
       for (let i = 0; i < buff.length; i++) {
         buff[i] = 255 ^ buff[i];
       }
       return ip.toString(buff);
     };
     ip.or = function(a, b) {
       a = ip.toBuffer(a);
       b = ip.toBuffer(b);
       if (a.length === b.length) {
         for (let i = 0; i < a.length; ++i) {
           a[i] |= b[i];
         }
         return ip.toString(a);
       }
       let buff = a;
       let other = b;
       if (b.length > a.length) {
         buff = b;
         other = a;
       }
       const offset = buff.length - other.length;
       for (let i = offset; i < buff.length; ++i) {
         buff[i] |= other[i - offset];
       }
       return ip.toString(buff);
     };
     ip.isEqual = function(a, b) {
       a = ip.toBuffer(a);
       b = ip.toBuffer(b);
       if (a.length === b.length) {
         for (let i = 0; i < a.length; i++) {
           if (a[i] !== b[i])
             return false;
         }
         return true;
       }
       if (b.length === 4) {
         const t = b;
         b = a;
         a = t;
       }
       for (let i = 0; i < 10; i++) {
         if (b[i] !== 0)
           return false;
       }
       const word = b.readUInt16BE(10);
       if (word !== 0 && word !== 65535)
         return false;
       for (let i = 0; i < 4; i++) {
         if (a[i] !== b[i + 12])
           return false;
       }
       return true;
     };
     ip.isPrivate = function(addr) {
       return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
     };
     ip.isPublic = function(addr) {
       return !ip.isPrivate(addr);
     };
     ip.isLoopback = function(addr) {
       return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
     };
     ip.loopback = function(family) {
       family = _normalizeFamily(family);
       if (family !== "ipv4" && family !== "ipv6") {
         throw new Error("family must be ipv4 or ipv6");
       }
       return family === "ipv4" ? "127.0.0.1" : "fe80::1";
     };
     ip.address = function(name, family) {
       const interfaces = os2.networkInterfaces();
       family = _normalizeFamily(family);
       if (name && name !== "private" && name !== "public") {
         const res = interfaces[name].filter((details) => {
           const itemFamily = _normalizeFamily(details.family);
           return itemFamily === family;
         });
         if (res.length === 0) {
           return void 0;
         }
         return res[0].address;
       }
       const all = Object.keys(interfaces).map((nic) => {
         const addresses = interfaces[nic].filter((details) => {
           details.family = _normalizeFamily(details.family);
           if (details.family !== family || ip.isLoopback(details.address)) {
             return false;
           }
           if (!name) {
             return true;
           }
           return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
         });
         return addresses.length ? addresses[0].address : void 0;
       }).filter(Boolean);
       return !all.length ? ip.loopback(family) : all[0];
     };
     ip.toLong = function(ip2) {
       let ipl = 0;
       ip2.split(".").forEach((octet) => {
         ipl <<= 8;
         ipl += parseInt(octet);
       });
       return ipl >>> 0;
     };
     ip.fromLong = function(ipl) {
       return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;
     };
   }
 });
 
 // node_modules/smart-buffer/build/utils.js
 var require_utils2 = __commonJS({
   "node_modules/smart-buffer/build/utils.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     var buffer_1 = require("buffer");
     var ERRORS = {
       INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
       INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
       INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
       INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
       INVALID_OFFSET: "An invalid offset value was provided.",
       INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
       INVALID_LENGTH: "An invalid length value was provided.",
       INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
       INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
       INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
       INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
       INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
     };
     exports.ERRORS = ERRORS;
     function checkEncoding(encoding) {
       if (!buffer_1.Buffer.isEncoding(encoding)) {
         throw new Error(ERRORS.INVALID_ENCODING);
       }
     }
     exports.checkEncoding = checkEncoding;
     function isFiniteInteger(value) {
       return typeof value === "number" && isFinite(value) && isInteger(value);
     }
     exports.isFiniteInteger = isFiniteInteger;
     function checkOffsetOrLengthValue(value, offset) {
       if (typeof value === "number") {
         if (!isFiniteInteger(value) || value < 0) {
           throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
         }
       } else {
         throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
       }
     }
     function checkLengthValue(length) {
       checkOffsetOrLengthValue(length, false);
     }
     exports.checkLengthValue = checkLengthValue;
     function checkOffsetValue(offset) {
       checkOffsetOrLengthValue(offset, true);
     }
     exports.checkOffsetValue = checkOffsetValue;
     function checkTargetOffset(offset, buff) {
       if (offset < 0 || offset > buff.length) {
         throw new Error(ERRORS.INVALID_TARGET_OFFSET);
       }
     }
     exports.checkTargetOffset = checkTargetOffset;
     function isInteger(value) {
       return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
     }
     function bigIntAndBufferInt64Check(bufferMethod) {
       if (typeof BigInt === "undefined") {
         throw new Error("Platform does not support JS BigInt type.");
       }
       if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
         throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
       }
     }
     exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
   }
 });
 
 // node_modules/smart-buffer/build/smartbuffer.js
 var require_smartbuffer = __commonJS({
   "node_modules/smart-buffer/build/smartbuffer.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     var utils_1 = require_utils2();
     var DEFAULT_SMARTBUFFER_SIZE = 4096;
     var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
     var SmartBuffer = class {
       constructor(options) {
         this.length = 0;
         this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
         this._writeOffset = 0;
         this._readOffset = 0;
         if (SmartBuffer.isSmartBufferOptions(options)) {
           if (options.encoding) {
             utils_1.checkEncoding(options.encoding);
             this._encoding = options.encoding;
           }
           if (options.size) {
             if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
               this._buff = Buffer.allocUnsafe(options.size);
             } else {
               throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
             }
           } else if (options.buff) {
             if (Buffer.isBuffer(options.buff)) {
               this._buff = options.buff;
               this.length = options.buff.length;
             } else {
               throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
             }
           } else {
             this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
           }
         } else {
           if (typeof options !== "undefined") {
             throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
           }
           this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
         }
       }
       static fromSize(size, encoding) {
         return new this({
           size,
           encoding
         });
       }
       static fromBuffer(buff, encoding) {
         return new this({
           buff,
           encoding
         });
       }
       static fromOptions(options) {
         return new this(options);
       }
       static isSmartBufferOptions(options) {
         const castOptions = options;
         return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
       }
       readInt8(offset) {
         return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
       }
       readInt16BE(offset) {
         return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
       }
       readInt16LE(offset) {
         return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
       }
       readInt32BE(offset) {
         return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
       }
       readInt32LE(offset) {
         return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
       }
       readBigInt64BE(offset) {
         utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
         return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
       }
       readBigInt64LE(offset) {
         utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
         return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
       }
       writeInt8(value, offset) {
         this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
         return this;
       }
       insertInt8(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
       }
       writeInt16BE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
       }
       insertInt16BE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
       }
       writeInt16LE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
       }
       insertInt16LE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
       }
       writeInt32BE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
       }
       insertInt32BE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
       }
       writeInt32LE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
       }
       insertInt32LE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
       }
       writeBigInt64BE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
         return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
       }
       insertBigInt64BE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
         return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
       }
       writeBigInt64LE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
         return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
       }
       insertBigInt64LE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
         return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
       }
       readUInt8(offset) {
         return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
       }
       readUInt16BE(offset) {
         return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
       }
       readUInt16LE(offset) {
         return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
       }
       readUInt32BE(offset) {
         return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
       }
       readUInt32LE(offset) {
         return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
       }
       readBigUInt64BE(offset) {
         utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
         return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
       }
       readBigUInt64LE(offset) {
         utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
         return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
       }
       writeUInt8(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
       }
       insertUInt8(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
       }
       writeUInt16BE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
       }
       insertUInt16BE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
       }
       writeUInt16LE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
       }
       insertUInt16LE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
       }
       writeUInt32BE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
       }
       insertUInt32BE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
       }
       writeUInt32LE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
       }
       insertUInt32LE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
       }
       writeBigUInt64BE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
         return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
       }
       insertBigUInt64BE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
         return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
       }
       writeBigUInt64LE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
         return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
       }
       insertBigUInt64LE(value, offset) {
         utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
         return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
       }
       readFloatBE(offset) {
         return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
       }
       readFloatLE(offset) {
         return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
       }
       writeFloatBE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
       }
       insertFloatBE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
       }
       writeFloatLE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
       }
       insertFloatLE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
       }
       readDoubleBE(offset) {
         return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
       }
       readDoubleLE(offset) {
         return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
       }
       writeDoubleBE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
       }
       insertDoubleBE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
       }
       writeDoubleLE(value, offset) {
         return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
       }
       insertDoubleLE(value, offset) {
         return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
       }
       readString(arg1, encoding) {
         let lengthVal;
         if (typeof arg1 === "number") {
           utils_1.checkLengthValue(arg1);
           lengthVal = Math.min(arg1, this.length - this._readOffset);
         } else {
           encoding = arg1;
           lengthVal = this.length - this._readOffset;
         }
         if (typeof encoding !== "undefined") {
           utils_1.checkEncoding(encoding);
         }
         const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
         this._readOffset += lengthVal;
         return value;
       }
       insertString(value, offset, encoding) {
         utils_1.checkOffsetValue(offset);
         return this._handleString(value, true, offset, encoding);
       }
       writeString(value, arg2, encoding) {
         return this._handleString(value, false, arg2, encoding);
       }
       readStringNT(encoding) {
         if (typeof encoding !== "undefined") {
           utils_1.checkEncoding(encoding);
         }
         let nullPos = this.length;
         for (let i = this._readOffset; i < this.length; i++) {
           if (this._buff[i] === 0) {
             nullPos = i;
             break;
           }
         }
         const value = this._buff.slice(this._readOffset, nullPos);
         this._readOffset = nullPos + 1;
         return value.toString(encoding || this._encoding);
       }
       insertStringNT(value, offset, encoding) {
         utils_1.checkOffsetValue(offset);
         this.insertString(value, offset, encoding);
         this.insertUInt8(0, offset + value.length);
         return this;
       }
       writeStringNT(value, arg2, encoding) {
         this.writeString(value, arg2, encoding);
         this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
         return this;
       }
       readBuffer(length) {
         if (typeof length !== "undefined") {
           utils_1.checkLengthValue(length);
         }
         const lengthVal = typeof length === "number" ? length : this.length;
         const endPoint = Math.min(this.length, this._readOffset + lengthVal);
         const value = this._buff.slice(this._readOffset, endPoint);
         this._readOffset = endPoint;
         return value;
       }
       insertBuffer(value, offset) {
         utils_1.checkOffsetValue(offset);
         return this._handleBuffer(value, true, offset);
       }
       writeBuffer(value, offset) {
         return this._handleBuffer(value, false, offset);
       }
       readBufferNT() {
         let nullPos = this.length;
         for (let i = this._readOffset; i < this.length; i++) {
           if (this._buff[i] === 0) {
             nullPos = i;
             break;
           }
         }
         const value = this._buff.slice(this._readOffset, nullPos);
         this._readOffset = nullPos + 1;
         return value;
       }
       insertBufferNT(value, offset) {
         utils_1.checkOffsetValue(offset);
         this.insertBuffer(value, offset);
         this.insertUInt8(0, offset + value.length);
         return this;
       }
       writeBufferNT(value, offset) {
         if (typeof offset !== "undefined") {
           utils_1.checkOffsetValue(offset);
         }
         this.writeBuffer(value, offset);
         this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
         return this;
       }
       clear() {
         this._writeOffset = 0;
         this._readOffset = 0;
         this.length = 0;
         return this;
       }
       remaining() {
         return this.length - this._readOffset;
       }
       get readOffset() {
         return this._readOffset;
       }
       set readOffset(offset) {
         utils_1.checkOffsetValue(offset);
         utils_1.checkTargetOffset(offset, this);
         this._readOffset = offset;
       }
       get writeOffset() {
         return this._writeOffset;
       }
       set writeOffset(offset) {
         utils_1.checkOffsetValue(offset);
         utils_1.checkTargetOffset(offset, this);
         this._writeOffset = offset;
       }
       get encoding() {
         return this._encoding;
       }
       set encoding(encoding) {
         utils_1.checkEncoding(encoding);
         this._encoding = encoding;
       }
       get internalBuffer() {
         return this._buff;
       }
       toBuffer() {
         return this._buff.slice(0, this.length);
       }
       toString(encoding) {
         const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
         utils_1.checkEncoding(encodingVal);
         return this._buff.toString(encodingVal, 0, this.length);
       }
       destroy() {
         this.clear();
         return this;
       }
       _handleString(value, isInsert, arg3, encoding) {
         let offsetVal = this._writeOffset;
         let encodingVal = this._encoding;
         if (typeof arg3 === "number") {
           offsetVal = arg3;
         } else if (typeof arg3 === "string") {
           utils_1.checkEncoding(arg3);
           encodingVal = arg3;
         }
         if (typeof encoding === "string") {
           utils_1.checkEncoding(encoding);
           encodingVal = encoding;
         }
         const byteLength = Buffer.byteLength(value, encodingVal);
         if (isInsert) {
           this.ensureInsertable(byteLength, offsetVal);
         } else {
           this._ensureWriteable(byteLength, offsetVal);
         }
         this._buff.write(value, offsetVal, byteLength, encodingVal);
         if (isInsert) {
           this._writeOffset += byteLength;
         } else {
           if (typeof arg3 === "number") {
             this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
           } else {
             this._writeOffset += byteLength;
           }
         }
         return this;
       }
       _handleBuffer(value, isInsert, offset) {
         const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
         if (isInsert) {
           this.ensureInsertable(value.length, offsetVal);
         } else {
           this._ensureWriteable(value.length, offsetVal);
         }
         value.copy(this._buff, offsetVal);
         if (isInsert) {
           this._writeOffset += value.length;
         } else {
           if (typeof offset === "number") {
             this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
           } else {
             this._writeOffset += value.length;
           }
         }
         return this;
       }
       ensureReadable(length, offset) {
         let offsetVal = this._readOffset;
         if (typeof offset !== "undefined") {
           utils_1.checkOffsetValue(offset);
           offsetVal = offset;
         }
         if (offsetVal < 0 || offsetVal + length > this.length) {
           throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
         }
       }
       ensureInsertable(dataLength, offset) {
         utils_1.checkOffsetValue(offset);
         this._ensureCapacity(this.length + dataLength);
         if (offset < this.length) {
           this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
         }
         if (offset + dataLength > this.length) {
           this.length = offset + dataLength;
         } else {
           this.length += dataLength;
         }
       }
       _ensureWriteable(dataLength, offset) {
         const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
         this._ensureCapacity(offsetVal + dataLength);
         if (offsetVal + dataLength > this.length) {
           this.length = offsetVal + dataLength;
         }
       }
       _ensureCapacity(minLength) {
         const oldLength = this._buff.length;
         if (minLength > oldLength) {
           let data = this._buff;
           let newLength = oldLength * 3 / 2 + 1;
           if (newLength < minLength) {
             newLength = minLength;
           }
           this._buff = Buffer.allocUnsafe(newLength);
           data.copy(this._buff, 0, 0, oldLength);
         }
       }
       _readNumberValue(func, byteSize, offset) {
         this.ensureReadable(byteSize, offset);
         const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
         if (typeof offset === "undefined") {
           this._readOffset += byteSize;
         }
         return value;
       }
       _insertNumberValue(func, byteSize, value, offset) {
         utils_1.checkOffsetValue(offset);
         this.ensureInsertable(byteSize, offset);
         func.call(this._buff, value, offset);
         this._writeOffset += byteSize;
         return this;
       }
       _writeNumberValue(func, byteSize, value, offset) {
         if (typeof offset === "number") {
           if (offset < 0) {
             throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
           }
           utils_1.checkOffsetValue(offset);
         }
         const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
         this._ensureWriteable(byteSize, offsetVal);
         func.call(this._buff, value, offsetVal);
         if (typeof offset === "number") {
           this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
         } else {
           this._writeOffset += byteSize;
         }
         return this;
       }
     };
     exports.SmartBuffer = SmartBuffer;
   }
 });
 
 // node_modules/socks/build/common/constants.js
 var require_constants = __commonJS({
   "node_modules/socks/build/common/constants.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     exports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = void 0;
     var DEFAULT_TIMEOUT = 3e4;
     exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
     var ERRORS = {
       InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
       InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
       InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
       InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
       InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
       InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
       InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
       InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
       InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
       InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
       NegotiationError: "Negotiation error",
       SocketClosed: "Socket closed",
       ProxyConnectionTimedOut: "Proxy connection timed out",
       InternalError: "SocksClient internal error (this should not happen)",
       InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
       Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
       InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
       Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
       InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
       InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
       InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
       InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
       Socks5AuthenticationFailed: "Socks5 Authentication failed",
       InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
       InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
       InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
       Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
     };
     exports.ERRORS = ERRORS;
     var SOCKS_INCOMING_PACKET_SIZES = {
       Socks5InitialHandshakeResponse: 2,
       Socks5UserPassAuthenticationResponse: 2,
       Socks5ResponseHeader: 5,
       Socks5ResponseIPv4: 10,
       Socks5ResponseIPv6: 22,
       Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
       Socks4Response: 8
     };
     exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
     var SocksCommand;
     (function(SocksCommand2) {
       SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
       SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
       SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
     })(SocksCommand || (SocksCommand = {}));
     exports.SocksCommand = SocksCommand;
     var Socks4Response;
     (function(Socks4Response2) {
       Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
       Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
       Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
       Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
     })(Socks4Response || (Socks4Response = {}));
     exports.Socks4Response = Socks4Response;
     var Socks5Auth;
     (function(Socks5Auth2) {
       Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
       Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
       Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
     })(Socks5Auth || (Socks5Auth = {}));
     exports.Socks5Auth = Socks5Auth;
     var SOCKS5_CUSTOM_AUTH_START = 128;
     exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
     var SOCKS5_CUSTOM_AUTH_END = 254;
     exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
     var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
     exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
     var Socks5Response;
     (function(Socks5Response2) {
       Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
       Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
       Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
       Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
       Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
       Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
       Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
       Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
       Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
     })(Socks5Response || (Socks5Response = {}));
     exports.Socks5Response = Socks5Response;
     var Socks5HostType;
     (function(Socks5HostType2) {
       Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
       Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
       Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
     })(Socks5HostType || (Socks5HostType = {}));
     exports.Socks5HostType = Socks5HostType;
     var SocksClientState;
     (function(SocksClientState2) {
       SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
       SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
       SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
       SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
       SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
       SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
       SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
       SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
       SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
       SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
       SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
       SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
       SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
     })(SocksClientState || (SocksClientState = {}));
     exports.SocksClientState = SocksClientState;
   }
 });
 
 // node_modules/socks/build/common/util.js
 var require_util2 = __commonJS({
   "node_modules/socks/build/common/util.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     exports.shuffleArray = exports.SocksClientError = void 0;
     var SocksClientError = class extends Error {
       constructor(message, options) {
         super(message);
         this.options = options;
       }
     };
     exports.SocksClientError = SocksClientError;
     function shuffleArray(array) {
       for (let i = array.length - 1; i > 0; i--) {
         const j = Math.floor(Math.random() * (i + 1));
         [array[i], array[j]] = [array[j], array[i]];
       }
     }
     exports.shuffleArray = shuffleArray;
   }
 });
 
 // node_modules/socks/build/common/helpers.js
 var require_helpers = __commonJS({
   "node_modules/socks/build/common/helpers.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = void 0;
     var util_1 = require_util2();
     var constants_1 = require_constants();
     var stream = require("stream");
     function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
       if (!constants_1.SocksCommand[options.command]) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
       }
       if (acceptedCommands.indexOf(options.command) === -1) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
       }
       if (!isValidSocksRemoteHost(options.destination)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
       }
       if (!isValidSocksProxy(options.proxy)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
       }
       validateCustomProxyAuth(options.proxy, options);
       if (options.timeout && !isValidTimeoutValue(options.timeout)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
       }
       if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
       }
     }
     exports.validateSocksClientOptions = validateSocksClientOptions;
     function validateSocksClientChainOptions(options) {
       if (options.command !== "connect") {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
       }
       if (!isValidSocksRemoteHost(options.destination)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
       }
       if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
       }
       options.proxies.forEach((proxy) => {
         if (!isValidSocksProxy(proxy)) {
           throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
         }
         validateCustomProxyAuth(proxy, options);
       });
       if (options.timeout && !isValidTimeoutValue(options.timeout)) {
         throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
       }
     }
     exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
     function validateCustomProxyAuth(proxy, options) {
       if (proxy.custom_auth_method !== void 0) {
         if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
           throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
         }
         if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
           throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
         }
         if (proxy.custom_auth_response_size === void 0) {
           throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
         }
         if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
           throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
         }
       }
     }
     function isValidSocksRemoteHost(remoteHost) {
       return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
     }
     function isValidSocksProxy(proxy) {
       return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
     }
     function isValidTimeoutValue(value) {
       return typeof value === "number" && value > 0;
     }
   }
 });
 
 // node_modules/socks/build/common/receivebuffer.js
 var require_receivebuffer = __commonJS({
   "node_modules/socks/build/common/receivebuffer.js"(exports) {
     "use strict";
     Object.defineProperty(exports, "__esModule", { value: true });
     exports.ReceiveBuffer = void 0;
     var ReceiveBuffer = class {
       constructor(size = 4096) {
         this.buffer = Buffer.allocUnsafe(size);
         this.offset = 0;
         this.originalSize = size;
       }
       get length() {
         return this.offset;
       }
       append(data) {
         if (!Buffer.isBuffer(data)) {
           throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
         }
         if (this.offset + data.length >= this.buffer.length) {
           const tmp = this.buffer;
           this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
           tmp.copy(this.buffer);
         }
         data.copy(this.buffer, this.offset);
         return this.offset += data.length;
       }
       peek(length) {
         if (length > this.offset) {
           throw new Error("Attempted to read beyond the bounds of the managed internal data.");
         }
         return this.buffer.slice(0, length);
       }
       get(length) {
         if (length > this.offset) {
           throw new Error("Attempted to read beyond the bounds of the managed internal data.");
         }
         const value = Buffer.allocUnsafe(length);
         this.buffer.slice(0, length).copy(value);
         this.buffer.copyWithin(0, length, length + this.offset - length);
         this.offset -= length;
         return value;
       }
     };
     exports.ReceiveBuffer = ReceiveBuffer;
   }
 });
 
 // node_modules/socks/build/client/socksclient.js
 var require_socksclient = __commonJS({
   "node_modules/socks/build/client/socksclient.js"(exports) {
     "use strict";
     var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
       function adopt(value) {
         return value instanceof P ? value : new P(function(resolve) {
           resolve(value);
         });
       }
       return new (P || (P = Promise))(function(resolve, reject) {
         function fulfilled(value) {
           try {
             step(generator.next(value));
           } catch (e) {
             reject(e);
           }
         }
         function rejected(value) {
           try {
             step(generator["throw"](value));
           } catch (e) {
             reject(e);
           }
         }
         function step(result) {
           result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
         }
         step((generator = generator.apply(thisArg, _arguments || [])).next());
       });
     };
     Object.defineProperty(exports, "__esModule", { value: true });
     exports.SocksClientError = exports.SocksClient = void 0;
     var events_1 = require("events");
     var net = require("net");
     var ip = require_ip2();
     var smart_buffer_1 = require_smartbuffer();
     var constants_1 = require_constants();
     var helpers_1 = require_helpers();
     var receivebuffer_1 = require_receivebuffer();
     var util_1 = require_util2();
     Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
       return util_1.SocksClientError;
     } });
     var SocksClient = class extends events_1.EventEmitter {
       constructor(options) {
         super();
         this.options = Object.assign({}, options);
         (0, helpers_1.validateSocksClientOptions)(options);
         this.setState(constants_1.SocksClientState.Created);
       }
       static createConnection(options, callback) {
         return new Promise((resolve, reject) => {
           try {
             (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
           } catch (err) {
             if (typeof callback === "function") {
               callback(err);
               return resolve(err);
             } else {
               return reject(err);
             }
           }
           const client = new SocksClient(options);
           client.connect(options.existing_socket);
           client.once("established", (info) => {
             client.removeAllListeners();
             if (typeof callback === "function") {
               callback(null, info);
               resolve(info);
             } else {
               resolve(info);
             }
           });
           client.once("error", (err) => {
             client.removeAllListeners();
             if (typeof callback === "function") {
               callback(err);
               resolve(err);
             } else {
               reject(err);
             }
           });
         });
       }
       static createConnectionChain(options, callback) {
         return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
           try {
             (0, helpers_1.validateSocksClientChainOptions)(options);
           } catch (err) {
             if (typeof callback === "function") {
               callback(err);
               return resolve(err);
             } else {
               return reject(err);
             }
           }
           if (options.randomizeChain) {
             (0, util_1.shuffleArray)(options.proxies);
           }
           try {
             let sock;
             for (let i = 0; i < options.proxies.length; i++) {
               const nextProxy = options.proxies[i];
               const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                 host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                 port: options.proxies[i + 1].port
               };
               const result = yield SocksClient.createConnection({
                 command: "connect",
                 proxy: nextProxy,
                 destination: nextDestination,
                 existing_socket: sock
               });
               sock = sock || result.socket;
             }
             if (typeof callback === "function") {
               callback(null, { socket: sock });
               resolve({ socket: sock });
             } else {
               resolve({ socket: sock });
             }
           } catch (err) {
             if (typeof callback === "function") {
               callback(err);
               resolve(err);
             } else {
               reject(err);
             }
           }
         }));
       }
       static createUDPFrame(options) {
         const buff = new smart_buffer_1.SmartBuffer();
         buff.writeUInt16BE(0);
         buff.writeUInt8(options.frameNumber || 0);
         if (net.isIPv4(options.remoteHost.host)) {
           buff.writeUInt8(constants_1.Socks5HostType.IPv4);
           buff.writeUInt32BE(ip.toLong(options.remoteHost.host));
         } else if (net.isIPv6(options.remoteHost.host)) {
           buff.writeUInt8(constants_1.Socks5HostType.IPv6);
           buff.writeBuffer(ip.toBuffer(options.remoteHost.host));
         } else {
           buff.writeUInt8(constants_1.Socks5HostType.Hostname);
           buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
           buff.writeString(options.remoteHost.host);
         }
         buff.writeUInt16BE(options.remoteHost.port);
         buff.writeBuffer(options.data);
         return buff.toBuffer();
       }
       static parseUDPFrame(data) {
         const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
         buff.readOffset = 2;
         const frameNumber = buff.readUInt8();
         const hostType = buff.readUInt8();
         let remoteHost;
         if (hostType === constants_1.Socks5HostType.IPv4) {
           remoteHost = ip.fromLong(buff.readUInt32BE());
         } else if (hostType === constants_1.Socks5HostType.IPv6) {
           remoteHost = ip.toString(buff.readBuffer(16));
         } else {
           remoteHost = buff.readString(buff.readUInt8());
         }
         const remotePort = buff.readUInt16BE();
         return {
           frameNumber,
           remoteHost: {
             host: remoteHost,
             port: remotePort
           },
           data: buff.readBuffer()
         };
       }
       setState(newState) {
         if (this.state !== constants_1.SocksClientState.Error) {
           this.state = newState;
         }
       }
       connect(existingSocket) {
         this.onDataReceived = (data) => this.onDataReceivedHandler(data);
         this.onClose = () => this.onCloseHandler();
         this.onError = (err) => this.onErrorHandler(err);
         this.onConnect = () => this.onConnectHandler();
         const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
         if (timer.unref && typeof timer.unref === "function") {
           timer.unref();
         }
         if (existingSocket) {
           this.socket = existingSocket;
         } else {
           this.socket = new net.Socket();
         }
         this.socket.once("close", this.onClose);
         this.socket.once("error", this.onError);
         this.socket.once("connect", this.onConnect);
         this.socket.on("data", this.onDataReceived);
         this.setState(constants_1.SocksClientState.Connecting);
         this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
         if (existingSocket) {
           this.socket.emit("connect");
         } else {
           this.socket.connect(this.getSocketOptions());
           if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
             this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
           }
         }
         this.prependOnceListener("established", (info) => {
           setImmediate(() => {
             if (this.receiveBuffer.length > 0) {
               const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
               info.socket.emit("data", excessData);
             }
             info.socket.resume();
           });
         });
       }
       getSocketOptions() {
         return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
       }
       onEstablishedTimeout() {
         if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
           this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
         }
       }
       onConnectHandler() {
         this.setState(constants_1.SocksClientState.Connected);
         if (this.options.proxy.type === 4) {
           this.sendSocks4InitialHandshake();
         } else {
           this.sendSocks5InitialHandshake();
         }
         this.setState(constants_1.SocksClientState.SentInitialHandshake);
       }
       onDataReceivedHandler(data) {
         this.receiveBuffer.append(data);
         this.processData();
       }
       processData() {
         while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
           if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
             if (this.options.proxy.type === 4) {
               this.handleSocks4FinalHandshakeResponse();
             } else {
               this.handleInitialSocks5HandshakeResponse();
             }
           } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
             this.handleInitialSocks5AuthenticationHandshakeResponse();
           } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
             this.handleSocks5FinalHandshakeResponse();
           } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
             if (this.options.proxy.type === 4) {
               this.handleSocks4IncomingConnectionResponse();
             } else {
               this.handleSocks5IncomingConnectionResponse();
             }
           } else {
             this.closeSocket(constants_1.ERRORS.InternalError);
             break;
           }
         }
       }
       onCloseHandler() {
         this.closeSocket(constants_1.ERRORS.SocketClosed);
       }
       onErrorHandler(err) {
         this.closeSocket(err.message);
       }
       removeInternalSocketHandlers() {
         this.socket.pause();
         this.socket.removeListener("data", this.onDataReceived);
         this.socket.removeListener("close", this.onClose);
         this.socket.removeListener("error", this.onError);
         this.socket.removeListener("connect", this.onConnect);
       }
       closeSocket(err) {
         if (this.state !== constants_1.SocksClientState.Error) {
           this.setState(constants_1.SocksClientState.Error);
           this.socket.destroy();
           this.removeInternalSocketHandlers();
           this.emit("error", new util_1.SocksClientError(err, this.options));
         }
       }
       sendSocks4InitialHandshake() {
         const userId = this.options.proxy.userId || "";
         const buff = new smart_buffer_1.SmartBuffer();
         buff.writeUInt8(4);
         buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
         buff.writeUInt16BE(this.options.destination.port);
         if (net.isIPv4(this.options.destination.host)) {
           buff.writeBuffer(ip.toBuffer(this.options.destination.host));
           buff.writeStringNT(userId);
         } else {
           buff.writeUInt8(0);
           buff.writeUInt8(0);
           buff.writeUInt8(0);
           buff.writeUInt8(1);
           buff.writeStringNT(userId);
           buff.writeStringNT(this.options.destination.host);
         }
         this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
         this.socket.write(buff.toBuffer());
       }
       handleSocks4FinalHandshakeResponse() {
         const data = this.receiveBuffer.get(8);
         if (data[1] !== constants_1.Socks4Response.Granted) {
           this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
         } else {
           if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
             const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
             buff.readOffset = 2;
             const remoteHost = {
               port: buff.readUInt16BE(),
               host: ip.fromLong(buff.readUInt32BE())
             };
             if (remoteHost.host === "0.0.0.0") {
               remoteHost.host = this.options.proxy.ipaddress;
             }
             this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
             this.emit("bound", { remoteHost, socket: this.socket });
           } else {
             this.setState(constants_1.SocksClientState.Established);
             this.removeInternalSocketHandlers();
             this.emit("established", { socket: this.socket });
           }
         }
       }
       handleSocks4IncomingConnectionResponse() {
         const data = this.receiveBuffer.get(8);
         if (data[1] !== constants_1.Socks4Response.Granted) {
           this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
         } else {
           const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
           buff.readOffset = 2;
           const remoteHost = {
             port: buff.readUInt16BE(),
             host: ip.fromLong(buff.readUInt32BE())
           };
           this.setState(constants_1.SocksClientState.Established);
           this.removeInternalSocketHandlers();
           this.emit("established", { remoteHost, socket: this.socket });
         }
       }
       sendSocks5InitialHandshake() {
         const buff = new smart_buffer_1.SmartBuffer();
         const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
         if (this.options.proxy.userId || this.options.proxy.password) {
           supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
         }
         if (this.options.proxy.custom_auth_method !== void 0) {
           supportedAuthMethods.push(this.options.proxy.custom_auth_method);
         }
         buff.writeUInt8(5);
         buff.writeUInt8(supportedAuthMethods.length);
         for (const authMethod of supportedAuthMethods) {
           buff.writeUInt8(authMethod);
         }
         this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
         this.socket.write(buff.toBuffer());
         this.setState(constants_1.SocksClientState.SentInitialHandshake);
       }
       handleInitialSocks5HandshakeResponse() {
         const data = this.receiveBuffer.get(2);
         if (data[0] !== 5) {
           this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
         } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
           this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
         } else {
           if (data[1] === constants_1.Socks5Auth.NoAuth) {
             this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
             this.sendSocks5CommandRequest();
           } else if (data[1] === constants_1.Socks5Auth.UserPass) {
             this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
             this.sendSocks5UserPassAuthentication();
           } else if (data[1] === this.options.proxy.custom_auth_method) {
             this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
             this.sendSocks5CustomAuthentication();
           } else {
             this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
           }
         }
       }
       sendSocks5UserPassAuthentication() {
         const userId = this.options.proxy.userId || "";
         const password = this.options.proxy.password || "";
         const buff = new smart_buffer_1.SmartBuffer();
         buff.writeUInt8(1);
         buff.writeUInt8(Buffer.byteLength(userId));
         buff.writeString(userId);
         buff.writeUInt8(Buffer.byteLength(password));
         buff.writeString(password);
         this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
         this.socket.write(buff.toBuffer());
         this.setState(constants_1.SocksClientState.SentAuthentication);
       }
       sendSocks5CustomAuthentication() {
         return __awaiter(this, void 0, void 0, function* () {
           this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
           this.socket.write(yield this.options.proxy.custom_auth_request_handler());
           this.setState(constants_1.SocksClientState.SentAuthentication);
         });
       }
       handleSocks5CustomAuthHandshakeResponse(data) {
         return __awaiter(this, void 0, void 0, function* () {
           return yield this.options.proxy.custom_auth_response_handler(data);
         });
       }
       handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
         return __awaiter(this, void 0, void 0, function* () {
           return data[1] === 0;
         });
       }
       handleSocks5AuthenticationUserPassHandshakeResponse(data) {
         return __awaiter(this, void 0, void 0, function* () {
           return data[1] === 0;
         });
       }
       handleInitialSocks5AuthenticationHandshakeResponse() {
         return __awaiter(this, void 0, void 0, function* () {
           this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
           let authResult = false;
           if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
             authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
           } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
             authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
           } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
             authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
           }
           if (!authResult) {
             this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
           } else {
             this.sendSocks5CommandRequest();
           }
         });
       }
       sendSocks5CommandRequest() {
         const buff = new smart_buffer_1.SmartBuffer();
         buff.writeUInt8(5);
         buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
         buff.writeUInt8(0);
         if (net.isIPv4(this.options.destination.host)) {
           buff.writeUInt8(constants_1.Socks5HostType.IPv4);
           buff.writeBuffer(ip.toBuffer(this.options.destination.host));
         } else if (net.isIPv6(this.options.destination.host)) {
           buff.writeUInt8(constants_1.Socks5HostType.IPv6);
           buff.writeBuffer(ip.toBuffer(this.options.destination.host));
         } else {
           buff.writeUInt8(constants_1.Socks5HostType.Hostname);
           buff.writeUInt8(this.options.destination.host.length);
           buff.writeString(this.options.destination.host);
         }
         buff.writeUInt16BE(this.options.destination.port);
         this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
         this.socket.write(buff.toBuffer());
         this.setState(constants_1.SocksClientState.SentFinalHandshake);
       }
       handleSocks5FinalHandshakeResponse() {
         const header = this.receiveBuffer.peek(5);
         if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
           this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
         } else {
           const addressType = header[3];
           let remoteHost;
           let buff;
           if (addressType === constants_1.Socks5HostType.IPv4) {
             const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
             if (this.receiveBuffer.length < dataNeeded) {
               this.nextRequiredPacketBufferSize = dataNeeded;
               return;
             }
             buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
             remoteHost = {
               host: ip.fromLong(buff.readUInt32BE()),
               port: buff.readUInt16BE()
             };
             if (remoteHost.host === "0.0.0.0") {
               remoteHost.host = this.options.proxy.ipaddress;
             }
           } else if (addressType === constants_1.Socks5HostType.Hostname) {
             const hostLength = header[4];
             const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
             if (this.receiveBuffer.length < dataNeeded) {
               this.nextRequiredPacketBufferSize = dataNeeded;
               return;
             }
             buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
             remoteHost = {
               host: buff.readString(hostLength),
               port: buff.readUInt16BE()
             };
           } else if (addressType === constants_1.Socks5HostType.IPv6) {
             const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
             if (this.receiveBuffer.length < dataNeeded) {
               this.nextRequiredPacketBufferSize = dataNeeded;
               return;
             }
             buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
             remoteHost = {
               host: ip.toString(buff.readBuffer(16)),
               port: buff.readUInt16BE()
             };
           }
           this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
           if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
             this.setState(constants_1.SocksClientState.Established);
             this.removeInternalSocketHandlers();
             this.emit("established", { remoteHost, socket: this.socket });
           } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
             this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
             this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
             this.emit("bound", { remoteHost, socket: this.socket });
           } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
             this.setState(constants_1.SocksClientState.Established);
             this.removeInternalSocketHandlers();
             this.emit("established", {
               remoteHost,
               socket: this.socket
             });
           }
         }
       }
       handleSocks5IncomingConnectionResponse() {
         const header = this.receiveBuffer.peek(5);
         if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
           this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
         } else {
           const addressType = header[3];
           let remoteHost;
           let buff;
           if (addressType === constants_1.Socks5HostType.IPv4) {
             const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
             if (this.receiveBuffer.length < dataNeeded) {
               this.nextRequiredPacketBufferSize = dataNeeded;
               return;
             }
             buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
             remoteHost = {
               host: ip.fromLong(buff.readUInt32BE()),
               port: buff.readUInt16BE()
             };
             if (remoteHost.host === "0.0.0.0") {
               remoteHost.host = this.options.proxy.ipaddress;
             }
           } else if (addressType === constants_1.Socks5HostType.Hostname) {
             const hostLength = header[4];
             const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
             if (this.receiveBuffer.length < dataNeeded) {
               this.nextRequiredPacketBufferSize = dataNeeded;
               return;
             }
             buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
             remoteHost = {
               host: buff.readString(hostLength),
               port: buff.readUInt16BE()
             };
           } else if (addressType === constants_1.Socks5HostType.IPv6) {
             const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
             if (this.receiveBuffer.length < dataNeeded) {
               this.nextRequiredPacketBufferSize = dataNeeded;
               return;
             }
             buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
             remoteHost = {
               host: ip.toString(buff.readBuffer(16)),
               port: buff.readUInt16BE()
             };
           }
           this.setState(constants_1.SocksClientState.Established);
           this.removeInternalSocketHandlers();
           this.emit("established", { remoteHost, socket: this.socket });
         }
       }
       get socksClientOptions() {
         return Object.assign({}, this.options);
       }
     };
     exports.SocksClient = SocksClient;
   }
 });
 
 // node_modules/socks/build/index.js
 var require_build = __commonJS({
   "node_modules/socks/build/index.js"(exports) {
     "use strict";
     var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
       if (k2 === void 0)
         k2 = k;
       var desc = Object.getOwnPropertyDescriptor(m, k);
       if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
         desc = { enumerable: true, get: function() {
           return m[k];
         } };
       }
       Object.defineProperty(o, k2, desc);
     } : function(o, m, k, k2) {
       if (k2 === void 0)
         k2 = k;
       o[k2] = m[k];
     });
     var __exportStar = exports && exports.__exportStar || function(m, exports2) {
       for (var p in m)
         if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
           __createBinding(exports2, m, p);
     };
     Object.defineProperty(exports, "__esModule", { value: true });
     __exportStar(require_socksclient(), exports);
   }
 });
 
 // node_modules/bittorrent-tracker/lib/client/tracker.js
 var require_tracker = __commonJS({
   "node_modules/bittorrent-tracker/lib/client/tracker.js"(exports, module2) {
     var EventEmitter = require("events");
     var Tracker = class extends EventEmitter {
       constructor(client, announceUrl) {
         super();
         this.client = client;
         this.announceUrl = announceUrl;
         this.interval = null;
         this.destroyed = false;
       }
       setInterval(intervalMs) {
         if (intervalMs == null)
           intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL;
         clearInterval(this.interval);
         if (intervalMs) {
           this.interval = setInterval(() => {
             this.announce(this.client._defaultAnnounceOpts());
           }, intervalMs);
           if (this.interval.unref)
             this.interval.unref();
         }
       }
     };
     module2.exports = Tracker;
   }
 });
 
 // node_modules/bittorrent-tracker/lib/client/http-tracker.js
 var require_http_tracker = __commonJS({
   "node_modules/bittorrent-tracker/lib/client/http-tracker.js"(exports, module2) {
     var arrayRemove = require_unordered_array_remove();
     var bencode = require_lib();
     var clone = require_clone();
     var compact2string = require_compact2string();
     var debug = require_src()("bittorrent-tracker:http-tracker");
     var get = require_simple_get();
     var Socks = require_build();
     var common = require_common2();
     var Tracker = require_tracker();
     var HTTP_SCRAPE_SUPPORT = /\/(announce)[^/]*$/;
     var HTTPTracker = class extends Tracker {
       constructor(client, announceUrl) {
         super(client, announceUrl);
         debug("new http tracker %s", announceUrl);
         this.scrapeUrl = null;
         const match = this.announceUrl.match(HTTP_SCRAPE_SUPPORT);
         if (match) {
           const pre = this.announceUrl.slice(0, match.index);
           const post = this.announceUrl.slice(match.index + 9);
           this.scrapeUrl = `${pre}/scrape${post}`;
         }
         this.cleanupFns = [];
         this.maybeDestroyCleanup = null;
       }
       announce(opts) {
         if (this.destroyed)
           return;
         const params = Object.assign({}, opts, {
           compact: opts.compact == null ? 1 : opts.compact,
           info_hash: this.client._infoHashBinary,
           peer_id: this.client._peerIdBinary,
           port: this.client._port
         });
         if (this._trackerId)
           params.trackerid = this._trackerId;
         this._request(this.announceUrl, params, (err, data) => {
           if (err)
             return this.client.emit("warning", err);
           this._onAnnounceResponse(data);
         });
       }
       scrape(opts) {
         if (this.destroyed)
           return;
         if (!this.scrapeUrl) {
           this.client.emit("error", new Error(`scrape not supported ${this.announceUrl}`));
           return;
         }
         const infoHashes = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? opts.infoHash.map((infoHash) => infoHash.toString("binary")) : opts.infoHash && opts.infoHash.toString("binary") || this.client._infoHashBinary;
         const params = {
           info_hash: infoHashes
         };
         this._request(this.scrapeUrl, params, (err, data) => {
           if (err)
             return this.client.emit("warning", err);
           this._onScrapeResponse(data);
         });
       }
       destroy(cb) {
         const self = this;
         if (this.destroyed)
           return cb(null);
         this.destroyed = true;
         clearInterval(this.interval);
         let timeout;
         if (this.cleanupFns.length === 0)
           return destroyCleanup();
         timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT);
         this.maybeDestroyCleanup = () => {
           if (this.cleanupFns.length === 0)
             destroyCleanup();
         };
         function destroyCleanup() {
           if (timeout) {
             clearTimeout(timeout);
             timeout = null;
           }
           self.maybeDestroyCleanup = null;
           self.cleanupFns.slice(0).forEach((cleanup) => {
             cleanup();
           });
           self.cleanupFns = [];
           cb(null);
         }
       }
       _request(requestUrl, params, cb) {
         const self = this;
         const parsedUrl = new URL(requestUrl + (requestUrl.indexOf("?") === -1 ? "?" : "&") + common.querystringStringify(params));
         let agent;
         if (this.client._proxyOpts) {
           agent = parsedUrl.protocol === "https:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent;
           if (!agent && this.client._proxyOpts.socksProxy) {
             agent = new Socks.Agent(clone(this.client._proxyOpts.socksProxy), parsedUrl.protocol === "https:");
           }
         }
         this.cleanupFns.push(cleanup);
         let request = get.concat({
           url: parsedUrl.toString(),
           agent,
           timeout: common.REQUEST_TIMEOUT,
           headers: {
             "user-agent": this.client._userAgent || ""
           }
         }, onResponse);
         function cleanup() {
           if (request) {
             arrayRemove(self.cleanupFns, self.cleanupFns.indexOf(cleanup));
             request.abort();
             request = null;
           }
           if (self.maybeDestroyCleanup)
             self.maybeDestroyCleanup();
         }
         function onResponse(err, res, data) {
           cleanup();
           if (self.destroyed)
             return;
           if (err)
             return cb(err);
           if (res.statusCode !== 200) {
             return cb(new Error(`Non-200 response code ${res.statusCode} from ${self.announceUrl}`));
           }
           if (!data || data.length === 0) {
             return cb(new Error(`Invalid tracker response from${self.announceUrl}`));
           }
           try {
             data = bencode.decode(data);
           } catch (err2) {
             return cb(new Error(`Error decoding tracker response: ${err2.message}`));
           }
           const failure = data["failure reason"];
           if (failure) {
             debug(`failure from ${requestUrl} (${failure})`);
             return cb(new Error(failure));
           }
           const warning = data["warning message"];
           if (warning) {
             debug(`warning from ${requestUrl} (${warning})`);
             self.client.emit("warning", new Error(warning));
           }
           debug(`response from ${requestUrl}`);
           cb(null, data);
         }
       }
       _onAnnounceResponse(data) {
         const interval = data.interval || data["min interval"];
         if (interval)
           this.setInterval(interval * 1e3);
         const trackerId = data["tracker id"];
         if (trackerId) {
           this._trackerId = trackerId;
         }
         const response = Object.assign({}, data, {
           announce: this.announceUrl,
           infoHash: common.binaryToHex(data.info_hash)
         });
         this.client.emit("update", response);
         let addrs;
         if (Buffer.isBuffer(data.peers)) {
           try {
             addrs = compact2string.multi(data.peers);
           } catch (err) {
             return this.client.emit("warning", err);
           }
           addrs.forEach((addr) => {
             this.client.emit("peer", addr);
           });
         } else if (Array.isArray(data.peers)) {
           data.peers.forEach((peer) => {
             this.client.emit("peer", `${peer.ip}:${peer.port}`);
           });
         }
         if (Buffer.isBuffer(data.peers6)) {
           try {
             addrs = compact2string.multi6(data.peers6);
           } catch (err) {
             return this.client.emit("warning", err);
           }
           addrs.forEach((addr) => {
             this.client.emit("peer", addr);
           });
         } else if (Array.isArray(data.peers6)) {
           data.peers6.forEach((peer) => {
             const ip = /^\[/.test(peer.ip) || !/:/.test(peer.ip) ? peer.ip : `[${peer.ip}]`;
             this.client.emit("peer", `${ip}:${peer.port}`);
           });
         }
       }
       _onScrapeResponse(data) {
         data = data.files || data.host || {};
         const keys = Object.keys(data);
         if (keys.length === 0) {
           this.client.emit("warning", new Error("invalid scrape response"));
           return;
         }
         keys.forEach((infoHash) => {
           const response = Object.assign(data[infoHash], {
             announce: this.announceUrl,
             infoHash: common.binaryToHex(infoHash)
           });
           this.client.emit("scrape", response);
         });
       }
     };
     HTTPTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 60 * 1e3;
     module2.exports = HTTPTracker;
   }
 });
 
 // node_modules/bn.js/lib/bn.js
 var require_bn = __commonJS({
   "node_modules/bn.js/lib/bn.js"(exports, module2) {
     (function(module3, exports2) {
       "use strict";
       function assert(val, msg) {
         if (!val)
           throw new Error(msg || "Assertion failed");
       }
       function inherits(ctor, superCtor) {
         ctor.super_ = superCtor;
         var TempCtor = function() {
         };
         TempCtor.prototype = superCtor.prototype;
         ctor.prototype = new TempCtor();
         ctor.prototype.constructor = ctor;
       }
       function BN(number, base, endian) {
         if (BN.isBN(number)) {
           return number;
         }
         this.negative = 0;
         this.words = null;
         this.length = 0;
         this.red = null;
         if (number !== null) {
           if (base === "le" || base === "be") {
             endian = base;
             base = 10;
           }
           this._init(number || 0, base || 10, endian || "be");
         }
       }
       if (typeof module3 === "object") {
         module3.exports = BN;
       } else {
         exports2.BN = BN;
       }
       BN.BN = BN;
       BN.wordSize = 26;
       var Buffer2;
       try {
         if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
           Buffer2 = window.Buffer;
         } else {
           Buffer2 = require("buffer").Buffer;
         }
       } catch (e) {
       }
       BN.isBN = function isBN(num) {
         if (num instanceof BN) {
           return true;
         }
         return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
       };
       BN.max = function max(left, right) {
         if (left.cmp(right) > 0)
           return left;
         return right;
       };
       BN.min = function min(left, right) {
         if (left.cmp(right) < 0)
           return left;
         return right;
       };
       BN.prototype._init = function init(number, base, endian) {
         if (typeof number === "number") {
           return this._initNumber(number, base, endian);
         }
         if (typeof number === "object") {
           return this._initArray(number, base, endian);
         }
         if (base === "hex") {
           base = 16;
         }
         assert(base === (base | 0) && base >= 2 && base <= 36);
         number = number.toString().replace(/\s+/g, "");
         var start = 0;
         if (number[0] === "-") {
           start++;
           this.negative = 1;
         }
         if (start < number.length) {
           if (base === 16) {
             this._parseHex(number, start, endian);
           } else {
             this._parseBase(number, base, start);
             if (endian === "le") {
               this._initArray(this.toArray(), base, endian);
             }
           }
         }
       };
       BN.prototype._initNumber = function _initNumber(number, base, endian) {
         if (number < 0) {
           this.negative = 1;
           number = -number;
         }
         if (number < 67108864) {
           this.words = [number & 67108863];
           this.length = 1;
         } else if (number < 4503599627370496) {
           this.words = [
             number & 67108863,
             number / 67108864 & 67108863
           ];
           this.length = 2;
         } else {
           assert(number < 9007199254740992);
           this.words = [
             number & 67108863,
             number / 67108864 & 67108863,
             1
           ];
           this.length = 3;
         }
         if (endian !== "le")
           return;
         this._initArray(this.toArray(), base, endian);
       };
       BN.prototype._initArray = function _initArray(number, base, endian) {
         assert(typeof number.length === "number");
         if (number.length <= 0) {
           this.words = [0];
           this.length = 1;
           return this;
         }
         this.length = Math.ceil(number.length / 3);
         this.words = new Array(this.length);
         for (var i = 0; i < this.length; i++) {
           this.words[i] = 0;
         }
         var j, w;
         var off = 0;
         if (endian === "be") {
           for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
             w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
             this.words[j] |= w << off & 67108863;
             this.words[j + 1] = w >>> 26 - off & 67108863;
             off += 24;
             if (off >= 26) {
               off -= 26;
               j++;
             }
           }
         } else if (endian === "le") {
           for (i = 0, j = 0; i < number.length; i += 3) {
             w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
             this.words[j] |= w << off & 67108863;
             this.words[j + 1] = w >>> 26 - off & 67108863;
             off += 24;
             if (off >= 26) {
               off -= 26;
               j++;
             }
           }
         }
         return this._strip();
       };
       function parseHex4Bits(string, index) {
         var c = string.charCodeAt(index);
         if (c >= 48 && c <= 57) {
           return c - 48;
         } else if (c >= 65 && c <= 70) {
           return c - 55;
         } else if (c >= 97 && c <= 102) {
           return c - 87;
         } else {
           assert(false, "Invalid character in " + string);
         }
       }
       function parseHexByte(string, lowerBound, index) {
         var r = parseHex4Bits(string, index);
         if (index - 1 >= lowerBound) {
           r |= parseHex4Bits(string, index - 1) << 4;
         }
         return r;
       }
       BN.prototype._parseHex = function _parseHex(number, start, endian) {
         this.length = Math.ceil((number.length - start) / 6);
         this.words = new Array(this.length);
         for (var i = 0; i < this.length; i++) {
           this.words[i] = 0;
         }
         var off = 0;
         var j = 0;
         var w;
         if (endian === "be") {
           for (i = number.length - 1; i >= start; i -= 2) {
             w = parseHexByte(number, start, i) << off;
             this.words[j] |= w & 67108863;
             if (off >= 18) {
               off -= 18;
               j += 1;
               this.words[j] |= w >>> 26;
             } else {
               off += 8;
             }
           }
         } else {
           var parseLength = number.length - start;
           for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
             w = parseHexByte(number, start, i) << off;
             this.words[j] |= w & 67108863;
             if (off >= 18) {
               off -= 18;
               j += 1;
               this.words[j] |= w >>> 26;
             } else {
               off += 8;
             }
           }
         }
         this._strip();
       };
       function parseBase(str, start, end, mul) {
         var r = 0;
         var b = 0;
         var len = Math.min(str.length, end);
         for (var i = start; i < len; i++) {
           var c = str.charCodeAt(i) - 48;
           r *= mul;
           if (c >= 49) {
             b = c - 49 + 10;
           } else if (c >= 17) {
             b = c - 17 + 10;
           } else {
             b = c;
           }
           assert(c >= 0 && b < mul, "Invalid character");
           r += b;
         }
         return r;
       }
       BN.prototype._parseBase = function _parseBase(number, base, start) {
         this.words = [0];
         this.length = 1;
         for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
           limbLen++;
         }
         limbLen--;
         limbPow = limbPow / base | 0;
         var total = number.length - start;
         var mod = total % limbLen;
         var end = Math.min(total, total - mod) + start;
         var word = 0;
         for (var i = start; i < end; i += limbLen) {
           word = parseBase(number, i, i + limbLen, base);
           this.imuln(limbPow);
           if (this.words[0] + word < 67108864) {
             this.words[0] += word;
           } else {
             this._iaddn(word);
           }
         }
         if (mod !== 0) {
           var pow = 1;
           word = parseBase(number, i, number.length, base);
           for (i = 0; i < mod; i++) {
             pow *= base;
           }
           this.imuln(pow);
           if (this.words[0] + word < 67108864) {
             this.words[0] += word;
           } else {
             this._iaddn(word);
           }
         }
         this._strip();
       };
       BN.prototype.copy = function copy(dest) {
         dest.words = new Array(this.length);
         for (var i = 0; i < this.length; i++) {
           dest.words[i] = this.words[i];
         }
         dest.length = this.length;
         dest.negative = this.negative;
         dest.red = this.red;
       };
       function move(dest, src) {
         dest.words = src.words;
         dest.length = src.length;
         dest.negative = src.negative;
         dest.red = src.red;
       }
       BN.prototype._move = function _move(dest) {
         move(dest, this);
       };
       BN.prototype.clone = function clone() {
         var r = new BN(null);
         this.copy(r);
         return r;
       };
       BN.prototype._expand = function _expand(size) {
         while (this.length < size) {
           this.words[this.length++] = 0;
         }
         return this;
       };
       BN.prototype._strip = function strip() {
         while (this.length > 1 && this.words[this.length - 1] === 0) {
           this.length--;
         }
         return this._normSign();
       };
       BN.prototype._normSign = function _normSign() {
         if (this.length === 1 && this.words[0] === 0) {
           this.negative = 0;
         }
         return this;
       };
       if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
         try {
           BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
         } catch (e) {
           BN.prototype.inspect = inspect;
         }
       } else {
         BN.prototype.inspect = inspect;
       }
       function inspect() {
         return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
       }
       var zeros = [
         "",
         "0",
         "00",
         "000",
         "0000",
         "00000",
         "000000",
         "0000000",
         "00000000",
         "000000000",
         "0000000000",
         "00000000000",
         "000000000000",
         "0000000000000",
         "00000000000000",
         "000000000000000",
         "0000000000000000",
         "00000000000000000",
         "000000000000000000",
         "0000000000000000000",
         "00000000000000000000",
         "000000000000000000000",
         "0000000000000000000000",
         "00000000000000000000000",
         "000000000000000000000000",
         "0000000000000000000000000"
       ];
       var groupSizes = [
         0,
         0,
         25,
         16,
         12,
         11,
         10,
         9,
         8,
         8,
         7,
         7,
         7,
         7,
         6,
         6,
         6,
         6,
         6,
         6,
         6,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5,
         5
       ];
       var groupBases = [
         0,
         0,
         33554432,
         43046721,
         16777216,
         48828125,
         60466176,
         40353607,
         16777216,
         43046721,
         1e7,
         19487171,
         35831808,
         62748517,
         7529536,
         11390625,
         16777216,
         24137569,
         34012224,
         47045881,
         64e6,
         4084101,
         5153632,
         6436343,
         7962624,
         9765625,
         11881376,
         14348907,
         17210368,
         20511149,
         243e5,
         28629151,
         33554432,
         39135393,
         45435424,
         52521875,
         60466176
       ];
       BN.prototype.toString = function toString(base, padding) {
         base = base || 10;
         padding = padding | 0 || 1;
         var out;
         if (base === 16 || base === "hex") {
           out = "";
           var off = 0;
           var carry = 0;
           for (var i = 0; i < this.length; i++) {
             var w = this.words[i];
             var word = ((w << off | carry) & 16777215).toString(16);
             carry = w >>> 24 - off & 16777215;
             off += 2;
             if (off >= 26) {
               off -= 26;
               i--;
             }
             if (carry !== 0 || i !== this.length - 1) {
               out = zeros[6 - word.length] + word + out;
             } else {
               out = word + out;
             }
           }
           if (carry !== 0) {
             out = carry.toString(16) + out;
           }
           while (out.length % padding !== 0) {
             out = "0" + out;
           }
           if (this.negative !== 0) {
             out = "-" + out;
           }
           return out;
         }
         if (base === (base | 0) && base >= 2 && base <= 36) {
           var groupSize = groupSizes[base];
           var groupBase = groupBases[base];
           out = "";
           var c = this.clone();
           c.negative = 0;
           while (!c.isZero()) {
             var r = c.modrn(groupBase).toString(base);
             c = c.idivn(groupBase);
             if (!c.isZero()) {
               out = zeros[groupSize - r.length] + r + out;
             } else {
               out = r + out;
             }
           }
           if (this.isZero()) {
             out = "0" + out;
           }
           while (out.length % padding !== 0) {
             out = "0" + out;
           }
           if (this.negative !== 0) {
             out = "-" + out;
           }
           return out;
         }
         assert(false, "Base should be between 2 and 36");
       };
       BN.prototype.toNumber = function toNumber() {
         var ret = this.words[0];
         if (this.length === 2) {
           ret += this.words[1] * 67108864;
         } else if (this.length === 3 && this.words[2] === 1) {
           ret += 4503599627370496 + this.words[1] * 67108864;
         } else if (this.length > 2) {
           assert(false, "Number can only safely store up to 53 bits");
         }
         return this.negative !== 0 ? -ret : ret;
       };
       BN.prototype.toJSON = function toJSON() {
         return this.toString(16, 2);
       };
       if (Buffer2) {
         BN.prototype.toBuffer = function toBuffer(endian, length) {
           return this.toArrayLike(Buffer2, endian, length);
         };
       }
       BN.prototype.toArray = function toArray(endian, length) {
         return this.toArrayLike(Array, endian, length);
       };
       var allocate = function allocate2(ArrayType, size) {
         if (ArrayType.allocUnsafe) {
           return ArrayType.allocUnsafe(size);
         }
         return new ArrayType(size);
       };
       BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
         this._strip();
         var byteLength = this.byteLength();
         var reqLength = length || Math.max(1, byteLength);
         assert(byteLength <= reqLength, "byte array longer than desired length");
         assert(reqLength > 0, "Requested array length <= 0");
         var res = allocate(ArrayType, reqLength);
         var postfix = endian === "le" ? "LE" : "BE";
         this["_toArrayLike" + postfix](res, byteLength);
         return res;
       };
       BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
         var position = 0;
         var carry = 0;
         for (var i = 0, shift = 0; i < this.length; i++) {
           var word = this.words[i] << shift | carry;
           res[position++] = word & 255;
           if (position < res.length) {
             res[position++] = word >> 8 & 255;
           }
           if (position < res.length) {
             res[position++] = word >> 16 & 255;
           }
           if (shift === 6) {
             if (position < res.length) {
               res[position++] = word >> 24 & 255;
             }
             carry = 0;
             shift = 0;
           } else {
             carry = word >>> 24;
             shift += 2;
           }
         }
         if (position < res.length) {
           res[position++] = carry;
           while (position < res.length) {
             res[position++] = 0;
           }
         }
       };
       BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
         var position = res.length - 1;
         var carry = 0;
         for (var i = 0, shift = 0; i < this.length; i++) {
           var word = this.words[i] << shift | carry;
           res[position--] = word & 255;
           if (position >= 0) {
             res[position--] = word >> 8 & 255;
           }
           if (position >= 0) {
             res[position--] = word >> 16 & 255;
           }
           if (shift === 6) {
             if (position >= 0) {
               res[position--] = word >> 24 & 255;
             }
             carry = 0;
             shift = 0;
           } else {
             carry = word >>> 24;
             shift += 2;
           }
         }
         if (position >= 0) {
           res[position--] = carry;
           while (position >= 0) {
             res[position--] = 0;
           }
         }
       };
       if (Math.clz32) {
         BN.prototype._countBits = function _countBits(w) {
           return 32 - Math.clz32(w);
         };
       } else {
         BN.prototype._countBits = function _countBits(w) {
           var t = w;
           var r = 0;
           if (t >= 4096) {
             r += 13;
             t >>>= 13;
           }
           if (t >= 64) {
             r += 7;
             t >>>= 7;
           }
           if (t >= 8) {
             r += 4;
             t >>>= 4;
           }
           if (t >= 2) {
             r += 2;
             t >>>= 2;
           }
           return r + t;
         };
       }
       BN.prototype._zeroBits = function _zeroBits(w) {
         if (w === 0)
           return 26;
         var t = w;
         var r = 0;
         if ((t & 8191) === 0) {
           r += 13;
           t >>>= 13;
         }
         if ((t & 127) === 0) {
           r += 7;
           t >>>= 7;
         }
         if ((t & 15) === 0) {
           r += 4;
           t >>>= 4;
         }
         if ((t & 3) === 0) {
           r += 2;
           t >>>= 2;
         }
         if ((t & 1) === 0) {
           r++;
         }
         return r;
       };
       BN.prototype.bitLength = function bitLength() {
         var w = this.words[this.length - 1];
         var hi = this._countBits(w);
         return (this.length - 1) * 26 + hi;
       };
       function toBitArray(num) {
         var w = new Array(num.bitLength());
         for (var bit = 0; bit < w.length; bit++) {
           var off = bit / 26 | 0;
           var wbit = bit % 26;
           w[bit] = num.words[off] >>> wbit & 1;
         }
         return w;
       }
       BN.prototype.zeroBits = function zeroBits() {
         if (this.isZero())
           return 0;
         var r = 0;
         for (var i = 0; i < this.length; i++) {
           var b = this._zeroBits(this.words[i]);
           r += b;
           if (b !== 26)
             break;
         }
         return r;
       };
       BN.prototype.byteLength = function byteLength() {
         return Math.ceil(this.bitLength() / 8);
       };
       BN.prototype.toTwos = function toTwos(width) {
         if (this.negative !== 0) {
           return this.abs().inotn(width).iaddn(1);
         }
         return this.clone();
       };
       BN.prototype.fromTwos = function fromTwos(width) {
         if (this.testn(width - 1)) {
           return this.notn(width).iaddn(1).ineg();
         }
         return this.clone();
       };
       BN.prototype.isNeg = function isNeg() {
         return this.negative !== 0;
       };
       BN.prototype.neg = function neg() {
         return this.clone().ineg();
       };
       BN.prototype.ineg = function ineg() {
         if (!this.isZero()) {
           this.negative ^= 1;
         }
         return this;
       };
       BN.prototype.iuor = function iuor(num) {
         while (this.length < num.length) {
           this.words[this.length++] = 0;
         }
         for (var i = 0; i < num.length; i++) {
           this.words[i] = this.words[i] | num.words[i];
         }
         return this._strip();
       };
       BN.prototype.ior = function ior(num) {
         assert((this.negative | num.negative) === 0);
         return this.iuor(num);
       };
       BN.prototype.or = function or(num) {
         if (this.length > num.length)
           return this.clone().ior(num);
         return num.clone().ior(this);
       };
       BN.prototype.uor = function uor(num) {
         if (this.length > num.length)
           return this.clone().iuor(num);
         return num.clone().iuor(this);
       };
       BN.prototype.iuand = function iuand(num) {
         var b;
         if (this.length > num.length) {
           b = num;
         } else {
           b = this;
         }
         for (var i = 0; i < b.length; i++) {
           this.words[i] = this.words[i] & num.words[i];
         }
         this.length = b.length;
         return this._strip();
       };
       BN.prototype.iand = function iand(num) {
         assert((this.negative | num.negative) === 0);
         return this.iuand(num);
       };
       BN.prototype.and = function and(num) {
         if (this.length > num.length)
           return this.clone().iand(num);
         return num.clone().iand(this);
       };
       BN.prototype.uand = function uand(num) {
         if (this.length > num.length)
           return this.clone().iuand(num);
         return num.clone().iuand(this);
       };
       BN.prototype.iuxor = function iuxor(num) {
         var a;
         var b;
         if (this.length > num.length) {
           a = this;
           b = num;
         } else {
           a = num;
           b = this;
         }
         for (var i = 0; i < b.length; i++) {
           this.words[i] = a.words[i] ^ b.words[i];
         }
         if (this !== a) {
           for (; i < a.length; i++) {
             this.words[i] = a.words[i];
           }
         }
         this.length = a.length;
         return this._strip();
       };
       BN.prototype.ixor = function ixor(num) {
         assert((this.negative | num.negative) === 0);
         return this.iuxor(num);
       };
       BN.prototype.xor = function xor(num) {
         if (this.length > num.length)
           return this.clone().ixor(num);
         return num.clone().ixor(this);
       };
       BN.prototype.uxor = function uxor(num) {
         if (this.length > num.length)
           return this.clone().iuxor(num);
         return num.clone().iuxor(this);
       };
       BN.prototype.inotn = function inotn(width) {
         assert(typeof width === "number" && width >= 0);
         var bytesNeeded = Math.ceil(width / 26) | 0;
         var bitsLeft = width % 26;
         this._expand(bytesNeeded);
         if (bitsLeft > 0) {
           bytesNeeded--;
         }
         for (var i = 0; i < bytesNeeded; i++) {
           this.words[i] = ~this.words[i] & 67108863;
         }
         if (bitsLeft > 0) {
           this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
         }
         return this._strip();
       };
       BN.prototype.notn = function notn(width) {
         return this.clone().inotn(width);
       };
       BN.prototype.setn = function setn(bit, val) {
         assert(typeof bit === "number" && bit >= 0);
         var off = bit / 26 | 0;
         var wbit = bit % 26;
         this._expand(off + 1);
         if (val) {
           this.words[off] = this.words[off] | 1 << wbit;
         } else {
           this.words[off] = this.words[off] & ~(1 << wbit);
         }
         return this._strip();
       };
       BN.prototype.iadd = function iadd(num) {
         var r;
         if (this.negative !== 0 && num.negative === 0) {
           this.negative = 0;
           r = this.isub(num);
           this.negative ^= 1;
           return this._normSign();
         } else if (this.negative === 0 && num.negative !== 0) {
           num.negative = 0;
           r = this.isub(num);
           num.negative = 1;
           return r._normSign();
         }
         var a, b;
         if (this.length > num.length) {
           a = this;
           b = num;
         } else {
           a = num;
           b = this;
         }
         var carry = 0;
         for (var i = 0; i < b.length; i++) {
           r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
           this.words[i] = r & 67108863;
           carry = r >>> 26;
         }
         for (; carry !== 0 && i < a.length; i++) {
           r = (a.words[i] | 0) + carry;
           this.words[i] = r & 67108863;
           carry = r >>> 26;
         }
         this.length = a.length;
         if (carry !== 0) {
           this.words[this.length] = carry;
           this.length++;
         } else if (a !== this) {
           for (; i < a.length; i++) {
             this.words[i] = a.words[i];
           }
         }
         return this;
       };
       BN.prototype.add = function add(num) {
         var res;
         if (num.negative !== 0 && this.negative === 0) {
           num.negative = 0;
           res = this.sub(num);
           num.negative ^= 1;
           return res;
         } else if (num.negative === 0 && this.negative !== 0) {
           this.negative = 0;
           res = num.sub(this);
           this.negative = 1;
           return res;
         }
         if (this.length > num.length)
           return this.clone().iadd(num);
         return num.clone().iadd(this);
       };
       BN.prototype.isub = function isub(num) {
         if (num.negative !== 0) {
           num.negative = 0;
           var r = this.iadd(num);
           num.negative = 1;
           return r._normSign();
         } else if (this.negative !== 0) {
           this.negative = 0;
           this.iadd(num);
           this.negative = 1;
           return this._normSign();
         }
         var cmp = this.cmp(num);
         if (cmp === 0) {
           this.negative = 0;
           this.length = 1;
           this.words[0] = 0;
           return this;
         }
         var a, b;
         if (cmp > 0) {
           a = this;
           b = num;
         } else {
           a = num;
           b = this;
         }
         var carry = 0;
         for (var i = 0; i < b.length; i++) {
           r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
           carry = r >> 26;
           this.words[i] = r & 67108863;
         }
         for (; carry !== 0 && i < a.length; i++) {
           r = (a.words[i] | 0) + carry;
           carry = r >> 26;
           this.words[i] = r & 67108863;
         }
         if (carry === 0 && i < a.length && a !== this) {
           for (; i < a.length; i++) {
             this.words[i] = a.words[i];
           }
         }
         this.length = Math.max(this.length, i);
         if (a !== this) {
           this.negative = 1;
         }
         return this._strip();
       };
       BN.prototype.sub = function sub(num) {
         return this.clone().isub(num);
       };
       function smallMulTo(self, num, out) {
         out.negative = num.negative ^ self.negative;
         var len = self.length + num.length | 0;
         out.length = len;
         len = len - 1 | 0;
         var a = self.words[0] | 0;
         var b = num.words[0] | 0;
         var r = a * b;
         var lo = r & 67108863;
         var carry = r / 67108864 | 0;
         out.words[0] = lo;
         for (var k = 1; k < len; k++) {
           var ncarry = carry >>> 26;
           var rword = carry & 67108863;
           var maxJ = Math.min(k, num.length - 1);
           for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
             var i = k - j | 0;
             a = self.words[i] | 0;
             b = num.words[j] | 0;
             r = a * b + rword;
             ncarry += r / 67108864 | 0;
             rword = r & 67108863;
           }
           out.words[k] = rword | 0;
           carry = ncarry | 0;
         }
         if (carry !== 0) {
           out.words[k] = carry | 0;
         } else {
           out.length--;
         }
         return out._strip();
       }
       var comb10MulTo = function comb10MulTo2(self, num, out) {
         var a = self.words;
         var b = num.words;
         var o = out.words;
         var c = 0;
         var lo;
         var mid;
         var hi;
         var a0 = a[0] | 0;
         var al0 = a0 & 8191;
         var ah0 = a0 >>> 13;
         var a1 = a[1] | 0;
         var al1 = a1 & 8191;
         var ah1 = a1 >>> 13;
         var a2 = a[2] | 0;
         var al2 = a2 & 8191;
         var ah2 = a2 >>> 13;
         var a3 = a[3] | 0;
         var al3 = a3 & 8191;
         var ah3 = a3 >>> 13;
         var a4 = a[4] | 0;
         var al4 = a4 & 8191;
         var ah4 = a4 >>> 13;
         var a5 = a[5] | 0;
         var al5 = a5 & 8191;
         var ah5 = a5 >>> 13;
         var a6 = a[6] | 0;
         var al6 = a6 & 8191;
         var ah6 = a6 >>> 13;
         var a7 = a[7] | 0;
         var al7 = a7 & 8191;
         var ah7 = a7 >>> 13;
         var a8 = a[8] | 0;
         var al8 = a8 & 8191;
         var ah8 = a8 >>> 13;
         var a9 = a[9] | 0;
         var al9 = a9 & 8191;
         var ah9 = a9 >>> 13;
         var b0 = b[0] | 0;
         var bl0 = b0 & 8191;
         var bh0 = b0 >>> 13;
         var b1 = b[1] | 0;
         var bl1 = b1 & 8191;
         var bh1 = b1 >>> 13;
         var b2 = b[2] | 0;
         var bl2 = b2 & 8191;
         var bh2 = b2 >>> 13;
         var b3 = b[3] | 0;
         var bl3 = b3 & 8191;
         var bh3 = b3 >>> 13;
         var b4 = b[4] | 0;
         var bl4 = b4 & 8191;
         var bh4 = b4 >>> 13;
         var b5 = b[5] | 0;
         var bl5 = b5 & 8191;
         var bh5 = b5 >>> 13;
         var b6 = b[6] | 0;
         var bl6 = b6 & 8191;
         var bh6 = b6 >>> 13;
         var b7 = b[7] | 0;
         var bl7 = b7 & 8191;
         var bh7 = b7 >>> 13;
         var b8 = b[8] | 0;
         var bl8 = b8 & 8191;
         var bh8 = b8 >>> 13;
         var b9 = b[9] | 0;
         var bl9 = b9 & 8191;
         var bh9 = b9 >>> 13;
         out.negative = self.negative ^ num.negative;
         out.length = 19;
         lo = Math.imul(al0, bl0);
         mid = Math.imul(al0, bh0);
         mid = mid + Math.imul(ah0, bl0) | 0;
         hi = Math.imul(ah0, bh0);
         var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
         w0 &= 67108863;
         lo = Math.imul(al1, bl0);
         mid = Math.imul(al1, bh0);
         mid = mid + Math.imul(ah1, bl0) | 0;
         hi = Math.imul(ah1, bh0);
         lo = lo + Math.imul(al0, bl1) | 0;
         mid = mid + Math.imul(al0, bh1) | 0;
         mid = mid + Math.imul(ah0, bl1) | 0;
         hi = hi + Math.imul(ah0, bh1) | 0;
         var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
         w1 &= 67108863;
         lo = Math.imul(al2, bl0);
         mid = Math.imul(al2, bh0);
         mid = mid + Math.imul(ah2, bl0) | 0;
         hi = Math.imul(ah2, bh0);
         lo = lo + Math.imul(al1, bl1) | 0;
         mid = mid + Math.imul(al1, bh1) | 0;
         mid = mid + Math.imul(ah1, bl1) | 0;
         hi = hi + Math.imul(ah1, bh1) | 0;
         lo = lo + Math.imul(al0, bl2) | 0;
         mid = mid + Math.imul(al0, bh2) | 0;
         mid = mid + Math.imul(ah0, bl2) | 0;
         hi = hi + Math.imul(ah0, bh2) | 0;
         var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
         w2 &= 67108863;
         lo = Math.imul(al3, bl0);
         mid = Math.imul(al3, bh0);
         mid = mid + Math.imul(ah3, bl0) | 0;
         hi = Math.imul(ah3, bh0);
         lo = lo + Math.imul(al2, bl1) | 0;
         mid = mid + Math.imul(al2, bh1) | 0;
         mid = mid + Math.imul(ah2, bl1) | 0;
         hi = hi + Math.imul(ah2, bh1) | 0;
         lo = lo + Math.imul(al1, bl2) | 0;
         mid = mid + Math.imul(al1, bh2) | 0;
         mid = mid + Math.imul(ah1, bl2) | 0;
         hi = hi + Math.imul(ah1, bh2) | 0;
         lo = lo + Math.imul(al0, bl3) | 0;
         mid = mid + Math.imul(al0, bh3) | 0;
         mid = mid + Math.imul(ah0, bl3) | 0;
         hi = hi + Math.imul(ah0, bh3) | 0;
         var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
         w3 &= 67108863;
         lo = Math.imul(al4, bl0);
         mid = Math.imul(al4, bh0);
         mid = mid + Math.imul(ah4, bl0) | 0;
         hi = Math.imul(ah4, bh0);
         lo = lo + Math.imul(al3, bl1) | 0;
         mid = mid + Math.imul(al3, bh1) | 0;
         mid = mid + Math.imul(ah3, bl1) | 0;
         hi = hi + Math.imul(ah3, bh1) | 0;
         lo = lo + Math.imul(al2, bl2) | 0;
         mid = mid + Math.imul(al2, bh2) | 0;
         mid = mid + Math.imul(ah2, bl2) | 0;
         hi = hi + Math.imul(ah2, bh2) | 0;
         lo = lo + Math.imul(al1, bl3) | 0;
         mid = mid + Math.imul(al1, bh3) | 0;
         mid = mid + Math.imul(ah1, bl3) | 0;
         hi = hi + Math.imul(ah1, bh3) | 0;
         lo = lo + Math.imul(al0, bl4) | 0;
         mid = mid + Math.imul(al0, bh4) | 0;
         mid = mid + Math.imul(ah0, bl4) | 0;
         hi = hi + Math.imul(ah0, bh4) | 0;
         var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
         w4 &= 67108863;
         lo = Math.imul(al5, bl0);
         mid = Math.imul(al5, bh0);
         mid = mid + Math.imul(ah5, bl0) | 0;
         hi = Math.imul(ah5, bh0);
         lo = lo + Math.imul(al4, bl1) | 0;
         mid = mid + Math.imul(al4, bh1) | 0;
         mid = mid + Math.imul(ah4, bl1) | 0;
         hi = hi + Math.imul(ah4, bh1) | 0;
         lo = lo + Math.imul(al3, bl2) | 0;
         mid = mid + Math.imul(al3, bh2) | 0;
         mid = mid + Math.imul(ah3, bl2) | 0;
         hi = hi + Math.imul(ah3, bh2) | 0;
         lo = lo + Math.imul(al2, bl3) | 0;
         mid = mid + Math.imul(al2, bh3) | 0;
         mid = mid + Math.imul(ah2, bl3) | 0;
         hi = hi + Math.imul(ah2, bh3) | 0;
         lo = lo + Math.imul(al1, bl4) | 0;
         mid = mid + Math.imul(al1, bh4) | 0;
         mid = mid + Math.imul(ah1, bl4) | 0;
         hi = hi + Math.imul(ah1, bh4) | 0;
         lo = lo + Math.imul(al0, bl5) | 0;
         mid = mid + Math.imul(al0, bh5) | 0;
         mid = mid + Math.imul(ah0, bl5) | 0;
         hi = hi + Math.imul(ah0, bh5) | 0;
         var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
         w5 &= 67108863;
         lo = Math.imul(al6, bl0);
         mid = Math.imul(al6, bh0);
         mid = mid + Math.imul(ah6, bl0) | 0;
         hi = Math.imul(ah6, bh0);
         lo = lo + Math.imul(al5, bl1) | 0;
         mid = mid + Math.imul(al5, bh1) | 0;
         mid = mid + Math.imul(ah5, bl1) | 0;
         hi = hi + Math.imul(ah5, bh1) | 0;
         lo = lo + Math.imul(al4, bl2) | 0;
         mid = mid + Math.imul(al4, bh2) | 0;
         mid = mid + Math.imul(ah4, bl2) | 0;
         hi = hi + Math.imul(ah4, bh2) | 0;
         lo = lo + Math.imul(al3, bl3) | 0;
         mid = mid + Math.imul(al3, bh3) | 0;
         mid = mid + Math.imul(ah3, bl3) | 0;
         hi = hi + Math.imul(ah3, bh3) | 0;
         lo = lo + Math.imul(al2, bl4) | 0;
         mid = mid + Math.imul(al2, bh4) | 0;
         mid = mid + Math.imul(ah2, bl4) | 0;
         hi = hi + Math.imul(ah2, bh4) | 0;
         lo = lo + Math.imul(al1, bl5) | 0;
         mid = mid + Math.imul(al1, bh5) | 0;
         mid = mid + Math.imul(ah1, bl5) | 0;
         hi = hi + Math.imul(ah1, bh5) | 0;
         lo = lo + Math.imul(al0, bl6) | 0;
         mid = mid + Math.imul(al0, bh6) | 0;
         mid = mid + Math.imul(ah0, bl6) | 0;
         hi = hi + Math.imul(ah0, bh6) | 0;
         var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
         w6 &= 67108863;
         lo = Math.imul(al7, bl0);
         mid = Math.imul(al7, bh0);
         mid = mid + Math.imul(ah7, bl0) | 0;
         hi = Math.imul(ah7, bh0);
         lo = lo + Math.imul(al6, bl1) | 0;
         mid = mid + Math.imul(al6, bh1) | 0;
         mid = mid + Math.imul(ah6, bl1) | 0;
         hi = hi + Math.imul(ah6, bh1) | 0;
         lo = lo + Math.imul(al5, bl2) | 0;
         mid = mid + Math.imul(al5, bh2) | 0;
         mid = mid + Math.imul(ah5, bl2) | 0;
         hi = hi + Math.imul(ah5, bh2) | 0;
         lo = lo + Math.imul(al4, bl3) | 0;
         mid = mid + Math.imul(al4, bh3) | 0;
         mid = mid + Math.imul(ah4, bl3) | 0;
         hi = hi + Math.imul(ah4, bh3) | 0;
         lo = lo + Math.imul(al3, bl4) | 0;
         mid = mid + Math.imul(al3, bh4) | 0;
         mid = mid + Math.imul(ah3, bl4) | 0;
         hi = hi + Math.imul(ah3, bh4) | 0;
         lo = lo + Math.imul(al2, bl5) | 0;
         mid = mid + Math.imul(al2, bh5) | 0;
         mid = mid + Math.imul(ah2, bl5) | 0;
         hi = hi + Math.imul(ah2, bh5) | 0;
         lo = lo + Math.imul(al1, bl6) | 0;
         mid = mid + Math.imul(al1, bh6) | 0;
         mid = mid + Math.imul(ah1, bl6) | 0;
         hi = hi + Math.imul(ah1, bh6) | 0;
         lo = lo + Math.imul(al0, bl7) | 0;
         mid = mid + Math.imul(al0, bh7) | 0;
         mid = mid + Math.imul(ah0, bl7) | 0;
         hi = hi + Math.imul(ah0, bh7) | 0;
         var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
         w7 &= 67108863;
         lo = Math.imul(al8, bl0);
         mid = Math.imul(al8, bh0);
         mid = mid + Math.imul(ah8, bl0) | 0;
         hi = Math.imul(ah8, bh0);
         lo = lo + Math.imul(al7, bl1) | 0;
         mid = mid + Math.imul(al7, bh1) | 0;
         mid = mid + Math.imul(ah7, bl1) | 0;
         hi = hi + Math.imul(ah7, bh1) | 0;
         lo = lo + Math.imul(al6, bl2) | 0;
         mid = mid + Math.imul(al6, bh2) | 0;
         mid = mid + Math.imul(ah6, bl2) | 0;
         hi = hi + Math.imul(ah6, bh2) | 0;
         lo = lo + Math.imul(al5, bl3) | 0;
         mid = mid + Math.imul(al5, bh3) | 0;
         mid = mid + Math.imul(ah5, bl3) | 0;
         hi = hi + Math.imul(ah5, bh3) | 0;
         lo = lo + Math.imul(al4, bl4) | 0;
         mid = mid + Math.imul(al4, bh4) | 0;
         mid = mid + Math.imul(ah4, bl4) | 0;
         hi = hi + Math.imul(ah4, bh4) | 0;
         lo = lo + Math.imul(al3, bl5) | 0;
         mid = mid + Math.imul(al3, bh5) | 0;
         mid = mid + Math.imul(ah3, bl5) | 0;
         hi = hi + Math.imul(ah3, bh5) | 0;
         lo = lo + Math.imul(al2, bl6) | 0;
         mid = mid + Math.imul(al2, bh6) | 0;
         mid = mid + Math.imul(ah2, bl6) | 0;
         hi = hi + Math.imul(ah2, bh6) | 0;
         lo = lo + Math.imul(al1, bl7) | 0;
         mid = mid + Math.imul(al1, bh7) | 0;
         mid = mid + Math.imul(ah1, bl7) | 0;
         hi = hi + Math.imul(ah1, bh7) | 0;
         lo = lo + Math.imul(al0, bl8) | 0;
         mid = mid + Math.imul(al0, bh8) | 0;
         mid = mid + Math.imul(ah0, bl8) | 0;
         hi = hi + Math.imul(ah0, bh8) | 0;
         var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
         w8 &= 67108863;
         lo = Math.imul(al9, bl0);
         mid = Math.imul(al9, bh0);
         mid = mid + Math.imul(ah9, bl0) | 0;
         hi = Math.imul(ah9, bh0);
         lo = lo + Math.imul(al8, bl1) | 0;
         mid = mid + Math.imul(al8, bh1) | 0;
         mid = mid + Math.imul(ah8, bl1) | 0;
         hi = hi + Math.imul(ah8, bh1) | 0;
         lo = lo + Math.imul(al7, bl2) | 0;
         mid = mid + Math.imul(al7, bh2) | 0;
         mid = mid + Math.imul(ah7, bl2) | 0;
         hi = hi + Math.imul(ah7, bh2) | 0;
         lo = lo + Math.imul(al6, bl3) | 0;
         mid = mid + Math.imul(al6, bh3) | 0;
         mid = mid + Math.imul(ah6, bl3) | 0;
         hi = hi + Math.imul(ah6, bh3) | 0;
         lo = lo + Math.imul(al5, bl4) | 0;
         mid = mid + Math.imul(al5, bh4) | 0;
         mid = mid + Math.imul(ah5, bl4) | 0;
         hi = hi + Math.imul(ah5, bh4) | 0;
         lo = lo + Math.imul(al4, bl5) | 0;
         mid = mid + Math.imul(al4, bh5) | 0;
         mid = mid + Math.imul(ah4, bl5) | 0;
         hi = hi + Math.imul(ah4, bh5) | 0;
         lo = lo + Math.imul(al3, bl6) | 0;
         mid = mid + Math.imul(al3, bh6) | 0;
         mid = mid + Math.imul(ah3, bl6) | 0;
         hi = hi + Math.imul(ah3, bh6) | 0;
         lo = lo + Math.imul(al2, bl7) | 0;
         mid = mid + Math.imul(al2, bh7) | 0;
         mid = mid + Math.imul(ah2, bl7) | 0;
         hi = hi + Math.imul(ah2, bh7) | 0;
         lo = lo + Math.imul(al1, bl8) | 0;
         mid = mid + Math.imul(al1, bh8) | 0;
         mid = mid + Math.imul(ah1, bl8) | 0;
         hi = hi + Math.imul(ah1, bh8) | 0;
         lo = lo + Math.imul(al0, bl9) | 0;
         mid = mid + Math.imul(al0, bh9) | 0;
         mid = mid + Math.imul(ah0, bl9) | 0;
         hi = hi + Math.imul(ah0, bh9) | 0;
         var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
         w9 &= 67108863;
         lo = Math.imul(al9, bl1);
         mid = Math.imul(al9, bh1);
         mid = mid + Math.imul(ah9, bl1) | 0;
         hi = Math.imul(ah9, bh1);
         lo = lo + Math.imul(al8, bl2) | 0;
         mid = mid + Math.imul(al8, bh2) | 0;
         mid = mid + Math.imul(ah8, bl2) | 0;
         hi = hi + Math.imul(ah8, bh2) | 0;
         lo = lo + Math.imul(al7, bl3) | 0;
         mid = mid + Math.imul(al7, bh3) | 0;
         mid = mid + Math.imul(ah7, bl3) | 0;
         hi = hi + Math.imul(ah7, bh3) | 0;
         lo = lo + Math.imul(al6, bl4) | 0;
         mid = mid + Math.imul(al6, bh4) | 0;
         mid = mid + Math.imul(ah6, bl4) | 0;
         hi = hi + Math.imul(ah6, bh4) | 0;
         lo = lo + Math.imul(al5, bl5) | 0;
         mid = mid + Math.imul(al5, bh5) | 0;
         mid = mid + Math.imul(ah5, bl5) | 0;
         hi = hi + Math.imul(ah5, bh5) | 0;
         lo = lo + Math.imul(al4, bl6) | 0;
         mid = mid + Math.imul(al4, bh6) | 0;
         mid = mid + Math.imul(ah4, bl6) | 0;
         hi = hi + Math.imul(ah4, bh6) | 0;
         lo = lo + Math.imul(al3, bl7) | 0;
         mid = mid + Math.imul(al3, bh7) | 0;
         mid = mid + Math.imul(ah3, bl7) | 0;
         hi = hi + Math.imul(ah3, bh7) | 0;
         lo = lo + Math.imul(al2, bl8) | 0;
         mid = mid + Math.imul(al2, bh8) | 0;
         mid = mid + Math.imul(ah2, bl8) | 0;
         hi = hi + Math.imul(ah2, bh8) | 0;
         lo = lo + Math.imul(al1, bl9) | 0;
         mid = mid + Math.imul(al1, bh9) | 0;
         mid = mid + Math.imul(ah1, bl9) | 0;
         hi = hi + Math.imul(ah1, bh9) | 0;
         var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
         w10 &= 67108863;
         lo = Math.imul(al9, bl2);
         mid = Math.imul(al9, bh2);
         mid = mid + Math.imul(ah9, bl2) | 0;
         hi = Math.imul(ah9, bh2);
         lo = lo + Math.imul(al8, bl3) | 0;
         mid = mid + Math.imul(al8, bh3) | 0;
         mid = mid + Math.imul(ah8, bl3) | 0;
         hi = hi + Math.imul(ah8, bh3) | 0;
         lo = lo + Math.imul(al7, bl4) | 0;
         mid = mid + Math.imul(al7, bh4) | 0;
         mid = mid + Math.imul(ah7, bl4) | 0;
         hi = hi + Math.imul(ah7, bh4) | 0;
         lo = lo + Math.imul(al6, bl5) | 0;
         mid = mid + Math.imul(al6, bh5) | 0;
         mid = mid + Math.imul(ah6, bl5) | 0;
         hi = hi + Math.imul(ah6, bh5) | 0;
         lo = lo + Math.imul(al5, bl6) | 0;
         mid = mid + Math.imul(al5, bh6) | 0;
         mid = mid + Math.imul(ah5, bl6) | 0;
         hi = hi + Math.imul(ah5, bh6) | 0;
         lo = lo + Math.imul(al4, bl7) | 0;
         mid = mid + Math.imul(al4, bh7) | 0;
         mid = mid + Math.imul(ah4, bl7) | 0;
         hi = hi + Math.imul(ah4, bh7) | 0;
         lo = lo + Math.imul(al3, bl8) | 0;
         mid = mid + Math.imul(al3, bh8) | 0;
         mid = mid + Math.imul(ah3, bl8) | 0;
         hi = hi + Math.imul(ah3, bh8) | 0;
         lo = lo + Math.imul(al2, bl9) | 0;
         mid = mid + Math.imul(al2, bh9) | 0;
         mid = mid + Math.imul(ah2, bl9) | 0;
         hi = hi + Math.imul(ah2, bh9) | 0;
         var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
         w11 &= 67108863;
         lo = Math.imul(al9, bl3);
         mid = Math.imul(al9, bh3);
         mid = mid + Math.imul(ah9, bl3) | 0;
         hi = Math.imul(ah9, bh3);
         lo = lo + Math.imul(al8, bl4) | 0;
         mid = mid + Math.imul(al8, bh4) | 0;
         mid = mid + Math.imul(ah8, bl4) | 0;
         hi = hi + Math.imul(ah8, bh4) | 0;
         lo = lo + Math.imul(al7, bl5) | 0;
         mid = mid + Math.imul(al7, bh5) | 0;
         mid = mid + Math.imul(ah7, bl5) | 0;
         hi = hi + Math.imul(ah7, bh5) | 0;
         lo = lo + Math.imul(al6, bl6) | 0;
         mid = mid + Math.imul(al6, bh6) | 0;
         mid = mid + Math.imul(ah6, bl6) | 0;
         hi = hi + Math.imul(ah6, bh6) | 0;
         lo = lo + Math.imul(al5, bl7) | 0;
         mid = mid + Math.imul(al5, bh7) | 0;
         mid = mid + Math.imul(ah5, bl7) | 0;
         hi = hi + Math.imul(ah5, bh7) | 0;
         lo = lo + Math.imul(al4, bl8) | 0;
         mid = mid + Math.imul(al4, bh8) | 0;
         mid = mid + Math.imul(ah4, bl8) | 0;
         hi = hi + Math.imul(ah4, bh8) | 0;
         lo = lo + Math.imul(al3, bl9) | 0;
         mid = mid + Math.imul(al3, bh9) | 0;
         mid = mid + Math.imul(ah3, bl9) | 0;
         hi = hi + Math.imul(ah3, bh9) | 0;
         var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
         w12 &= 67108863;
         lo = Math.imul(al9, bl4);
         mid = Math.imul(al9, bh4);
         mid = mid + Math.imul(ah9, bl4) | 0;
         hi = Math.imul(ah9, bh4);
         lo = lo + Math.imul(al8, bl5) | 0;
         mid = mid + Math.imul(al8, bh5) | 0;
         mid = mid + Math.imul(ah8, bl5) | 0;
         hi = hi + Math.imul(ah8, bh5) | 0;
         lo = lo + Math.imul(al7, bl6) | 0;
         mid = mid + Math.imul(al7, bh6) | 0;
         mid = mid + Math.imul(ah7, bl6) | 0;
         hi = hi + Math.imul(ah7, bh6) | 0;
         lo = lo + Math.imul(al6, bl7) | 0;
         mid = mid + Math.imul(al6, bh7) | 0;
         mid = mid + Math.imul(ah6, bl7) | 0;
         hi = hi + Math.imul(ah6, bh7) | 0;
         lo = lo + Math.imul(al5, bl8) | 0;
         mid = mid + Math.imul(al5, bh8) | 0;
         mid = mid + Math.imul(ah5, bl8) | 0;
         hi = hi + Math.imul(ah5, bh8) | 0;
         lo = lo + Math.imul(al4, bl9) | 0;
         mid = mid + Math.imul(al4, bh9) | 0;
         mid = mid + Math.imul(ah4, bl9) | 0;
         hi = hi + Math.imul(ah4, bh9) | 0;
         var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
         w13 &= 67108863;
         lo = Math.imul(al9, bl5);
         mid = Math.imul(al9, bh5);
         mid = mid + Math.imul(ah9, bl5) | 0;
         hi = Math.imul(ah9, bh5);
         lo = lo + Math.imul(al8, bl6) | 0;
         mid = mid + Math.imul(al8, bh6) | 0;
         mid = mid + Math.imul(ah8, bl6) | 0;
         hi = hi + Math.imul(ah8, bh6) | 0;
         lo = lo + Math.imul(al7, bl7) | 0;
         mid = mid + Math.imul(al7, bh7) | 0;
         mid = mid + Math.imul(ah7, bl7) | 0;
         hi = hi + Math.imul(ah7, bh7) | 0;
         lo = lo + Math.imul(al6, bl8) | 0;
         mid = mid + Math.imul(al6, bh8) | 0;
         mid = mid + Math.imul(ah6, bl8) | 0;
         hi = hi + Math.imul(ah6, bh8) | 0;
         lo = lo + Math.imul(al5, bl9) | 0;
         mid = mid + Math.imul(al5, bh9) | 0;
         mid = mid + Math.imul(ah5, bl9) | 0;
         hi = hi + Math.imul(ah5, bh9) | 0;
         var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
         w14 &= 67108863;
         lo = Math.imul(al9, bl6);
         mid = Math.imul(al9, bh6);
         mid = mid + Math.imul(ah9, bl6) | 0;
         hi = Math.imul(ah9, bh6);
         lo = lo + Math.imul(al8, bl7) | 0;
         mid = mid + Math.imul(al8, bh7) | 0;
         mid = mid + Math.imul(ah8, bl7) | 0;
         hi = hi + Math.imul(ah8, bh7) | 0;
         lo = lo + Math.imul(al7, bl8) | 0;
         mid = mid + Math.imul(al7, bh8) | 0;
         mid = mid + Math.imul(ah7, bl8) | 0;
         hi = hi + Math.imul(ah7, bh8) | 0;
         lo = lo + Math.imul(al6, bl9) | 0;
         mid = mid + Math.imul(al6, bh9) | 0;
         mid = mid + Math.imul(ah6, bl9) | 0;
         hi = hi + Math.imul(ah6, bh9) | 0;
         var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
         w15 &= 67108863;
         lo = Math.imul(al9, bl7);
         mid = Math.imul(al9, bh7);
         mid = mid + Math.imul(ah9, bl7) | 0;
         hi = Math.imul(ah9, bh7);
         lo = lo + Math.imul(al8, bl8) | 0;
         mid = mid + Math.imul(al8, bh8) | 0;
         mid = mid + Math.imul(ah8, bl8) | 0;
         hi = hi + Math.imul(ah8, bh8) | 0;
         lo = lo + Math.imul(al7, bl9) | 0;
         mid = mid + Math.imul(al7, bh9) | 0;
         mid = mid + Math.imul(ah7, bl9) | 0;
         hi = hi + Math.imul(ah7, bh9) | 0;
         var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
         w16 &= 67108863;
         lo = Math.imul(al9, bl8);
         mid = Math.imul(al9, bh8);
         mid = mid + Math.imul(ah9, bl8) | 0;
         hi = Math.imul(ah9, bh8);
         lo = lo + Math.imul(al8, bl9) | 0;
         mid = mid + Math.imul(al8, bh9) | 0;
         mid = mid + Math.imul(ah8, bl9) | 0;
         hi = hi + Math.imul(ah8, bh9) | 0;
         var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
         w17 &= 67108863;
         lo = Math.imul(al9, bl9);
         mid = Math.imul(al9, bh9);
         mid = mid + Math.imul(ah9, bl9) | 0;
         hi = Math.imul(ah9, bh9);
         var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
         c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
         w18 &= 67108863;
         o[0] = w0;
         o[1] = w1;
         o[2] = w2;
         o[3] = w3;
         o[4] = w4;
         o[5] = w5;
         o[6] = w6;
         o[7] = w7;
         o[8] = w8;
         o[9] = w9;
         o[10] = w10;
         o[11] = w11;
         o[12] = w12;
         o[13] = w13;
         o[14] = w14;
         o[15] = w15;
         o[16] = w16;
         o[17] = w17;
         o[18] = w18;
         if (c !== 0) {
           o[19] = c;
           out.length++;
         }
         return out;
       };
       if (!Math.imul) {
         comb10MulTo = smallMulTo;
       }
       function bigMulTo(self, num, out) {
         out.negative = num.negative ^ self.negative;
         out.length = self.length + num.length;
         var carry = 0;
         var hncarry = 0;
         for (var k = 0; k < out.length - 1; k++) {
           var ncarry = hncarry;
           hncarry = 0;
           var rword = carry & 67108863;
           var maxJ = Math.min(k, num.length - 1);
           for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
             var i = k - j;
             var a = self.words[i] | 0;
             var b = num.words[j] | 0;
             var r = a * b;
             var lo = r & 67108863;
             ncarry = ncarry + (r / 67108864 | 0) | 0;
             lo = lo + rword | 0;
             rword = lo & 67108863;
             ncarry = ncarry + (lo >>> 26) | 0;
             hncarry += ncarry >>> 26;
             ncarry &= 67108863;
           }
           out.words[k] = rword;
           carry = ncarry;
           ncarry = hncarry;
         }
         if (carry !== 0) {
           out.words[k] = carry;
         } else {
           out.length--;
         }
         return out._strip();
       }
       function jumboMulTo(self, num, out) {
         return bigMulTo(self, num, out);
       }
       BN.prototype.mulTo = function mulTo(num, out) {
         var res;
         var len = this.length + num.length;
         if (this.length === 10 && num.length === 10) {
           res = comb10MulTo(this, num, out);
         } else if (len < 63) {
           res = smallMulTo(this, num, out);
         } else if (len < 1024) {
           res = bigMulTo(this, num, out);
         } else {
           res = jumboMulTo(this, num, out);
         }
         return res;
       };
       function FFTM(x, y) {
         this.x = x;
         this.y = y;
       }
       FFTM.prototype.makeRBT = function makeRBT(N) {
         var t = new Array(N);
         var l = BN.prototype._countBits(N) - 1;
         for (var i = 0; i < N; i++) {
           t[i] = this.revBin(i, l, N);
         }
         return t;
       };
       FFTM.prototype.revBin = function revBin(x, l, N) {
         if (x === 0 || x === N - 1)
           return x;
         var rb = 0;
         for (var i = 0; i < l; i++) {
           rb |= (x & 1) << l - i - 1;
           x >>= 1;
         }
         return rb;
       };
       FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
         for (var i = 0; i < N; i++) {
           rtws[i] = rws[rbt[i]];
           itws[i] = iws[rbt[i]];
         }
       };
       FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
         this.permute(rbt, rws, iws, rtws, itws, N);
         for (var s = 1; s < N; s <<= 1) {
           var l = s << 1;
           var rtwdf = Math.cos(2 * Math.PI / l);
           var itwdf = Math.sin(2 * Math.PI / l);
           for (var p = 0; p < N; p += l) {
             var rtwdf_ = rtwdf;
             var itwdf_ = itwdf;
             for (var j = 0; j < s; j++) {
               var re = rtws[p + j];
               var ie = itws[p + j];
               var ro = rtws[p + j + s];
               var io = itws[p + j + s];
               var rx = rtwdf_ * ro - itwdf_ * io;
               io = rtwdf_ * io + itwdf_ * ro;
               ro = rx;
               rtws[p + j] = re + ro;
               itws[p + j] = ie + io;
               rtws[p + j + s] = re - ro;
               itws[p + j + s] = ie - io;
               if (j !== l) {
                 rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                 itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                 rtwdf_ = rx;
               }
             }
           }
         }
       };
       FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
         var N = Math.max(m, n) | 1;
         var odd = N & 1;
         var i = 0;
         for (N = N / 2 | 0; N; N = N >>> 1) {
           i++;
         }
         return 1 << i + 1 + odd;
       };
       FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
         if (N <= 1)
           return;
         for (var i = 0; i < N / 2; i++) {
           var t = rws[i];
           rws[i] = rws[N - i - 1];
           rws[N - i - 1] = t;
           t = iws[i];
           iws[i] = -iws[N - i - 1];
           iws[N - i - 1] = -t;
         }
       };
       FFTM.prototype.normalize13b = function normalize13b(ws, N) {
         var carry = 0;
         for (var i = 0; i < N / 2; i++) {
           var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
           ws[i] = w & 67108863;
           if (w < 67108864) {
             carry = 0;
           } else {
             carry = w / 67108864 | 0;
           }
         }
         return ws;
       };
       FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
         var carry = 0;
         for (var i = 0; i < len; i++) {
           carry = carry + (ws[i] | 0);
           rws[2 * i] = carry & 8191;
           carry = carry >>> 13;
           rws[2 * i + 1] = carry & 8191;
           carry = carry >>> 13;
         }
         for (i = 2 * len; i < N; ++i) {
           rws[i] = 0;
         }
         assert(carry === 0);
         assert((carry & ~8191) === 0);
       };
       FFTM.prototype.stub = function stub(N) {
         var ph = new Array(N);
         for (var i = 0; i < N; i++) {
           ph[i] = 0;
         }
         return ph;
       };
       FFTM.prototype.mulp = function mulp(x, y, out) {
         var N = 2 * this.guessLen13b(x.length, y.length);
         var rbt = this.makeRBT(N);
         var _ = this.stub(N);
         var rws = new Array(N);
         var rwst = new Array(N);
         var iwst = new Array(N);
         var nrws = new Array(N);
         var nrwst = new Array(N);
         var niwst = new Array(N);
         var rmws = out.words;
         rmws.length = N;
         this.convert13b(x.words, x.length, rws, N);
         this.convert13b(y.words, y.length, nrws, N);
         this.transform(rws, _, rwst, iwst, N, rbt);
         this.transform(nrws, _, nrwst, niwst, N, rbt);
         for (var i = 0; i < N; i++) {
           var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
           iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
           rwst[i] = rx;
         }
         this.conjugate(rwst, iwst, N);
         this.transform(rwst, iwst, rmws, _, N, rbt);
         this.conjugate(rmws, _, N);
         this.normalize13b(rmws, N);
         out.negative = x.negative ^ y.negative;
         out.length = x.length + y.length;
         return out._strip();
       };
       BN.prototype.mul = function mul(num) {
         var out = new BN(null);
         out.words = new Array(this.length + num.length);
         return this.mulTo(num, out);
       };
       BN.prototype.mulf = function mulf(num) {
         var out = new BN(null);
         out.words = new Array(this.length + num.length);
         return jumboMulTo(this, num, out);
       };
       BN.prototype.imul = function imul(num) {
         return this.clone().mulTo(num, this);
       };
       BN.prototype.imuln = function imuln(num) {
         var isNegNum = num < 0;
         if (isNegNum)
           num = -num;
         assert(typeof num === "number");
         assert(num < 67108864);
         var carry = 0;
         for (var i = 0; i < this.length; i++) {
           var w = (this.words[i] | 0) * num;
           var lo = (w & 67108863) + (carry & 67108863);
           carry >>= 26;
           carry += w / 67108864 | 0;
           carry += lo >>> 26;
           this.words[i] = lo & 67108863;
         }
         if (carry !== 0) {
           this.words[i] = carry;
           this.length++;
         }
         return isNegNum ? this.ineg() : this;
       };
       BN.prototype.muln = function muln(num) {
         return this.clone().imuln(num);
       };
       BN.prototype.sqr = function sqr() {
         return this.mul(this);
       };
       BN.prototype.isqr = function isqr() {
         return this.imul(this.clone());
       };
       BN.prototype.pow = function pow(num) {
         var w = toBitArray(num);
         if (w.length === 0)
           return new BN(1);
         var res = this;
         for (var i = 0; i < w.length; i++, res = res.sqr()) {
           if (w[i] !== 0)
             break;
         }
         if (++i < w.length) {
           for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
             if (w[i] === 0)
               continue;
             res = res.mul(q);
           }
         }
         return res;
       };
       BN.prototype.iushln = function iushln(bits) {
         assert(typeof bits === "number" && bits >= 0);
         var r = bits % 26;
         var s = (bits - r) / 26;
         var carryMask = 67108863 >>> 26 - r << 26 - r;
         var i;
         if (r !== 0) {
           var carry = 0;
           for (i = 0; i < this.length; i++) {
             var newCarry = this.words[i] & carryMask;
             var c = (this.words[i] | 0) - newCarry << r;
             this.words[i] = c | carry;
             carry = newCarry >>> 26 - r;
           }
           if (carry) {
             this.words[i] = carry;
             this.length++;
           }
         }
         if (s !== 0) {
           for (i = this.length - 1; i >= 0; i--) {
             this.words[i + s] = this.words[i];
           }
           for (i = 0; i < s; i++) {
             this.words[i] = 0;
           }
           this.length += s;
         }
         return this._strip();
       };
       BN.prototype.ishln = function ishln(bits) {
         assert(this.negative === 0);
         return this.iushln(bits);
       };
       BN.prototype.iushrn = function iushrn(bits, hint, extended) {
         assert(typeof bits === "number" && bits >= 0);
         var h;
         if (hint) {
           h = (hint - hint % 26) / 26;
         } else {
           h = 0;
         }
         var r = bits % 26;
         var s = Math.min((bits - r) / 26, this.length);
         var mask = 67108863 ^ 67108863 >>> r << r;
         var maskedWords = extended;
         h -= s;
         h = Math.max(0, h);
         if (maskedWords) {
           for (var i = 0; i < s; i++) {
             maskedWords.words[i] = this.words[i];
           }
           maskedWords.length = s;
         }
         if (s === 0) {
         } else if (this.length > s) {
           this.length -= s;
           for (i = 0; i < this.length; i++) {
             this.words[i] = this.words[i + s];
           }
         } else {
           this.words[0] = 0;
           this.length = 1;
         }
         var carry = 0;
         for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
           var word = this.words[i] | 0;
           this.words[i] = carry << 26 - r | word >>> r;
           carry = word & mask;
         }
         if (maskedWords && carry !== 0) {
           maskedWords.words[maskedWords.length++] = carry;
         }
         if (this.length === 0) {
           this.words[0] = 0;
           this.length = 1;
         }
         return this._strip();
       };
       BN.prototype.ishrn = function ishrn(bits, hint, extended) {
         assert(this.negative === 0);
         return this.iushrn(bits, hint, extended);
       };
       BN.prototype.shln = function shln(bits) {
         return this.clone().ishln(bits);
       };
       BN.prototype.ushln = function ushln(bits) {
         return this.clone().iushln(bits);
       };
       BN.prototype.shrn = function shrn(bits) {
         return this.clone().ishrn(bits);
       };
       BN.prototype.ushrn = function ushrn(bits) {
         return this.clone().iushrn(bits);
       };
       BN.prototype.testn = function testn(bit) {
         assert(typeof bit === "number" && bit >= 0);
         var r = bit % 26;
         var s = (bit - r) / 26;
         var q = 1 << r;
         if (this.length <= s)
           return false;
         var w = this.words[s];
         return !!(w & q);
       };
       BN.prototype.imaskn = function imaskn(bits) {
         assert(typeof bits === "number" && bits >= 0);
         var r = bits % 26;
         var s = (bits - r) / 26;
         assert(this.negative === 0, "imaskn works only with positive numbers");
         if (this.length <= s) {
           return this;
         }
         if (r !== 0) {
           s++;
         }
         this.length = Math.min(s, this.length);
         if (r !== 0) {
           var mask = 67108863 ^ 67108863 >>> r << r;
           this.words[this.length - 1] &= mask;
         }
         return this._strip();
       };
       BN.prototype.maskn = function maskn(bits) {
         return this.clone().imaskn(bits);
       };
       BN.prototype.iaddn = function iaddn(num) {
         assert(typeof num === "number");
         assert(num < 67108864);
         if (num < 0)
           return this.isubn(-num);
         if (this.negative !== 0) {
           if (this.length === 1 && (this.words[0] | 0) <= num) {
             this.words[0] = num - (this.words[0] | 0);
             this.negative = 0;
             return this;
           }
           this.negative = 0;
           this.isubn(num);
           this.negative = 1;
           return this;
         }
         return this._iaddn(num);
       };
       BN.prototype._iaddn = function _iaddn(num) {
         this.words[0] += num;
         for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
           this.words[i] -= 67108864;
           if (i === this.length - 1) {
             this.words[i + 1] = 1;
           } else {
             this.words[i + 1]++;
           }
         }
         this.length = Math.max(this.length, i + 1);
         return this;
       };
       BN.prototype.isubn = function isubn(num) {
         assert(typeof num === "number");
         assert(num < 67108864);
         if (num < 0)
           return this.iaddn(-num);
         if (this.negative !== 0) {
           this.negative = 0;
           this.iaddn(num);
           this.negative = 1;
           return this;
         }
         this.words[0] -= num;
         if (this.length === 1 && this.words[0] < 0) {
           this.words[0] = -this.words[0];
           this.negative = 1;
         } else {
           for (var i = 0; i < this.length && this.words[i] < 0; i++) {
             this.words[i] += 67108864;
             this.words[i + 1] -= 1;
           }
         }
         return this._strip();
       };
       BN.prototype.addn = function addn(num) {
         return this.clone().iaddn(num);
       };
       BN.prototype.subn = function subn(num) {
         return this.clone().isubn(num);
       };
       BN.prototype.iabs = function iabs() {
         this.negative = 0;
         return this;
       };
       BN.prototype.abs = function abs() {
         return this.clone().iabs();
       };
       BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
         var len = num.length + shift;
         var i;
         this._expand(len);
         var w;
         var carry = 0;
         for (i = 0; i < num.length; i++) {
           w = (this.words[i + shift] | 0) + carry;
           var right = (num.words[i] | 0) * mul;
           w -= right & 67108863;
           carry = (w >> 26) - (right / 67108864 | 0);
           this.words[i + shift] = w & 67108863;
         }
         for (; i < this.length - shift; i++) {
           w = (this.words[i + shift] | 0) + carry;
           carry = w >> 26;
           this.words[i + shift] = w & 67108863;
         }
         if (carry === 0)
           return this._strip();
         assert(carry === -1);
         carry = 0;
         for (i = 0; i < this.length; i++) {
           w = -(this.words[i] | 0) + carry;
           carry = w >> 26;
           this.words[i] = w & 67108863;
         }
         this.negative = 1;
         return this._strip();
       };
       BN.prototype._wordDiv = function _wordDiv(num, mode) {
         var shift = this.length - num.length;
         var a = this.clone();
         var b = num;
         var bhi = b.words[b.length - 1] | 0;
         var bhiBits = this._countBits(bhi);
         shift = 26 - bhiBits;
         if (shift !== 0) {
           b = b.ushln(shift);
           a.iushln(shift);
           bhi = b.words[b.length - 1] | 0;
         }
         var m = a.length - b.length;
         var q;
         if (mode !== "mod") {
           q = new BN(null);
           q.length = m + 1;
           q.words = new Array(q.length);
           for (var i = 0; i < q.length; i++) {
             q.words[i] = 0;
           }
         }
         var diff = a.clone()._ishlnsubmul(b, 1, m);
         if (diff.negative === 0) {
           a = diff;
           if (q) {
             q.words[m] = 1;
           }
         }
         for (var j = m - 1; j >= 0; j--) {
           var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
           qj = Math.min(qj / bhi | 0, 67108863);
           a._ishlnsubmul(b, qj, j);
           while (a.negative !== 0) {
             qj--;
             a.negative = 0;
             a._ishlnsubmul(b, 1, j);
             if (!a.isZero()) {
               a.negative ^= 1;
             }
           }
           if (q) {
             q.words[j] = qj;
           }
         }
         if (q) {
           q._strip();
         }
         a._strip();
         if (mode !== "div" && shift !== 0) {
           a.iushrn(shift);
         }
         return {
           div: q || null,
           mod: a
         };
       };
       BN.prototype.divmod = function divmod(num, mode, positive) {
         assert(!num.isZero());
         if (this.isZero()) {
           return {
             div: new BN(0),
             mod: new BN(0)
           };
         }
         var div, mod, res;
         if (this.negative !== 0 && num.negative === 0) {
           res = this.neg().divmod(num, mode);
           if (mode !== "mod") {
             div = res.div.neg();
           }
           if (mode !== "div") {
             mod = res.mod.neg();
             if (positive && mod.negative !== 0) {
               mod.iadd(num);
             }
           }
           return {
             div,
             mod
           };
         }
         if (this.negative === 0 && num.negative !== 0) {
           res = this.divmod(num.neg(), mode);
           if (mode !== "mod") {
             div = res.div.neg();
           }
           return {
             div,
             mod: res.mod
           };
         }
         if ((this.negative & num.negative) !== 0) {
           res = this.neg().divmod(num.neg(), mode);
           if (mode !== "div") {
             mod = res.mod.neg();
             if (positive && mod.negative !== 0) {
               mod.isub(num);
             }
           }
           return {
             div: res.div,
             mod
           };
         }
         if (num.length > this.length || this.cmp(num) < 0) {
           return {
             div: new BN(0),
             mod: this
           };
         }
         if (num.length === 1) {
           if (mode === "div") {
             return {
               div: this.divn(num.words[0]),
               mod: null
             };
           }
           if (mode === "mod") {
             return {
               div: null,
               mod: new BN(this.modrn(num.words[0]))
             };
           }
           return {
             div: this.divn(num.words[0]),
             mod: new BN(this.modrn(num.words[0]))
           };
         }
         return this._wordDiv(num, mode);
       };
       BN.prototype.div = function div(num) {
         return this.divmod(num, "div", false).div;
       };
       BN.prototype.mod = function mod(num) {
         return this.divmod(num, "mod", false).mod;
       };
       BN.prototype.umod = function umod(num) {
         return this.divmod(num, "mod", true).mod;
       };
       BN.prototype.divRound = function divRound(num) {
         var dm = this.divmod(num);
         if (dm.mod.isZero())
           return dm.div;
         var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
         var half = num.ushrn(1);
         var r2 = num.andln(1);
         var cmp = mod.cmp(half);
         if (cmp < 0 || r2 === 1 && cmp === 0)
           return dm.div;
         return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
       };
       BN.prototype.modrn = function modrn(num) {
         var isNegNum = num < 0;
         if (isNegNum)
           num = -num;
         assert(num <= 67108863);
         var p = (1 << 26) % num;
         var acc = 0;
         for (var i = this.length - 1; i >= 0; i--) {
           acc = (p * acc + (this.words[i] | 0)) % num;
         }
         return isNegNum ? -acc : acc;
       };
       BN.prototype.modn = function modn(num) {
         return this.modrn(num);
       };
       BN.prototype.idivn = function idivn(num) {
         var isNegNum = num < 0;
         if (isNegNum)
           num = -num;
         assert(num <= 67108863);
         var carry = 0;
         for (var i = this.length - 1; i >= 0; i--) {
           var w = (this.words[i] | 0) + carry * 67108864;
           this.words[i] = w / num | 0;
           carry = w % num;
         }
         this._strip();
         return isNegNum ? this.ineg() : this;
       };
       BN.prototype.divn = function divn(num) {
         return this.clone().idivn(num);
       };
       BN.prototype.egcd = function egcd(p) {
         assert(p.negative === 0);
         assert(!p.isZero());
         var x = this;
         var y = p.clone();
         if (x.negative !== 0) {
           x = x.umod(p);
         } else {
           x = x.clone();
         }
         var A = new BN(1);
         var B = new BN(0);
         var C = new BN(0);
         var D = new BN(1);
         var g = 0;
         while (x.isEven() && y.isEven()) {
           x.iushrn(1);
           y.iushrn(1);
           ++g;
         }
         var yp = y.clone();
         var xp = x.clone();
         while (!x.isZero()) {
           for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
             ;
           if (i > 0) {
             x.iushrn(i);
             while (i-- > 0) {
               if (A.isOdd() || B.isOdd()) {
                 A.iadd(yp);
                 B.isub(xp);
               }
               A.iushrn(1);
               B.iushrn(1);
             }
           }
           for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
             ;
           if (j > 0) {
             y.iushrn(j);
             while (j-- > 0) {
               if (C.isOdd() || D.isOdd()) {
                 C.iadd(yp);
                 D.isub(xp);
               }
               C.iushrn(1);
               D.iushrn(1);
             }
           }
           if (x.cmp(y) >= 0) {
             x.isub(y);
             A.isub(C);
             B.isub(D);
           } else {
             y.isub(x);
             C.isub(A);
             D.isub(B);
           }
         }
         return {
           a: C,
           b: D,
           gcd: y.iushln(g)
         };
       };
       BN.prototype._invmp = function _invmp(p) {
         assert(p.negative === 0);
         assert(!p.isZero());
         var a = this;
         var b = p.clone();
         if (a.negative !== 0) {
           a = a.umod(p);
         } else {
           a = a.clone();
         }
         var x1 = new BN(1);
         var x2 = new BN(0);
         var delta = b.clone();
         while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
           for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
             ;
           if (i > 0) {
             a.iushrn(i);
             while (i-- > 0) {
               if (x1.isOdd()) {
                 x1.iadd(delta);
               }
               x1.iushrn(1);
             }
           }
           for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
             ;
           if (j > 0) {
             b.iushrn(j);
             while (j-- > 0) {
               if (x2.isOdd()) {
                 x2.iadd(delta);
               }
               x2.iushrn(1);
             }
           }
           if (a.cmp(b) >= 0) {
             a.isub(b);
             x1.isub(x2);
           } else {
             b.isub(a);
             x2.isub(x1);
           }
         }
         var res;
         if (a.cmpn(1) === 0) {
           res = x1;
         } else {
           res = x2;
         }
         if (res.cmpn(0) < 0) {
           res.iadd(p);
         }
         return res;
       };
       BN.prototype.gcd = function gcd(num) {
         if (this.isZero())
           return num.abs();
         if (num.isZero())
           return this.abs();
         var a = this.clone();
         var b = num.clone();
         a.negative = 0;
         b.negative = 0;
         for (var shift = 0; a.isEven() && b.isEven(); shift++) {
           a.iushrn(1);
           b.iushrn(1);
         }
         do {
           while (a.isEven()) {
             a.iushrn(1);
           }
           while (b.isEven()) {
             b.iushrn(1);
           }
           var r = a.cmp(b);
           if (r < 0) {
             var t = a;
             a = b;
             b = t;
           } else if (r === 0 || b.cmpn(1) === 0) {
             break;
           }
           a.isub(b);
         } while (true);
         return b.iushln(shift);
       };
       BN.prototype.invm = function invm(num) {
         return this.egcd(num).a.umod(num);
       };
       BN.prototype.isEven = function isEven() {
         return (this.words[0] & 1) === 0;
       };
       BN.prototype.isOdd = function isOdd() {
         return (this.words[0] & 1) === 1;
       };
       BN.prototype.andln = function andln(num) {
         return this.words[0] & num;
       };
       BN.prototype.bincn = function bincn(bit) {
         assert(typeof bit === "number");
         var r = bit % 26;
         var s = (bit - r) / 26;
         var q = 1 << r;
         if (this.length <= s) {
           this._expand(s + 1);
           this.words[s] |= q;
           return this;
         }
         var carry = q;
         for (var i = s; carry !== 0 && i < this.length; i++) {
           var w = this.words[i] | 0;
           w += carry;
           carry = w >>> 26;
           w &= 67108863;
           this.words[i] = w;
         }
         if (carry !== 0) {
           this.words[i] = carry;
           this.length++;
         }
         return this;
       };
       BN.prototype.isZero = function isZero() {
         return this.length === 1 && this.words[0] === 0;
       };
       BN.prototype.cmpn = function cmpn(num) {
         var negative = num < 0;
         if (this.negative !== 0 && !negative)
           return -1;
         if (this.negative === 0 && negative)
           return 1;
         this._strip();
         var res;
         if (this.length > 1) {
           res = 1;
         } else {
           if (negative) {
             num = -num;
           }
           assert(num <= 67108863, "Number is too big");
           var w = this.words[0] | 0;
           res = w === num ? 0 : w < num ? -1 : 1;
         }
         if (this.negative !== 0)
           return -res | 0;
         return res;
       };
       BN.prototype.cmp = function cmp(num) {
         if (this.negative !== 0 && num.negative === 0)
           return -1;
         if (this.negative === 0 && num.negative !== 0)
           return 1;
         var res = this.ucmp(num);
         if (this.negative !== 0)
           return -res | 0;
         return res;
       };
       BN.prototype.ucmp = function ucmp(num) {
         if (this.length > num.length)
           return 1;
         if (this.length < num.length)
           return -1;
         var res = 0;
         for (var i = this.length - 1; i >= 0; i--) {
           var a = this.words[i] | 0;
           var b = num.words[i] | 0;
           if (a === b)
             continue;
           if (a < b) {
             res = -1;
           } else if (a > b) {
             res = 1;
           }
           break;
         }
         return res;
       };
       BN.prototype.gtn = function gtn(num) {
         return this.cmpn(num) === 1;
       };
       BN.prototype.gt = function gt(num) {
         return this.cmp(num) === 1;
       };
       BN.prototype.gten = function gten(num) {
         return this.cmpn(num) >= 0;
       };
       BN.prototype.gte = function gte(num) {
         return this.cmp(num) >= 0;
       };
       BN.prototype.ltn = function ltn(num) {
         return this.cmpn(num) === -1;
       };
       BN.prototype.lt = function lt(num) {
         return this.cmp(num) === -1;
       };
       BN.prototype.lten = function lten(num) {
         return this.cmpn(num) <= 0;
       };
       BN.prototype.lte = function lte(num) {
         return this.cmp(num) <= 0;
       };
       BN.prototype.eqn = function eqn(num) {
         return this.cmpn(num) === 0;
       };
       BN.prototype.eq = function eq(num) {
         return this.cmp(num) === 0;
       };
       BN.red = function red(num) {
         return new Red(num);
       };
       BN.prototype.toRed = function toRed(ctx) {
         assert(!this.red, "Already a number in reduction context");
         assert(this.negative === 0, "red works only with positives");
         return ctx.convertTo(this)._forceRed(ctx);
       };
       BN.prototype.fromRed = function fromRed() {
         assert(this.red, "fromRed works only with numbers in reduction context");
         return this.red.convertFrom(this);
       };
       BN.prototype._forceRed = function _forceRed(ctx) {
         this.red = ctx;
         return this;
       };
       BN.prototype.forceRed = function forceRed(ctx) {
         assert(!this.red, "Already a number in reduction context");
         return this._forceRed(ctx);
       };
       BN.prototype.redAdd = function redAdd(num) {
         assert(this.red, "redAdd works only with red numbers");
         return this.red.add(this, num);
       };
       BN.prototype.redIAdd = function redIAdd(num) {
         assert(this.red, "redIAdd works only with red numbers");
         return this.red.iadd(this, num);
       };
       BN.prototype.redSub = function redSub(num) {
         assert(this.red, "redSub works only with red numbers");
         return this.red.sub(this, num);
       };
       BN.prototype.redISub = function redISub(num) {
         assert(this.red, "redISub works only with red numbers");
         return this.red.isub(this, num);
       };
       BN.prototype.redShl = function redShl(num) {
         assert(this.red, "redShl works only with red numbers");
         return this.red.shl(this, num);
       };
       BN.prototype.redMul = function redMul(num) {
         assert(this.red, "redMul works only with red numbers");
         this.red._verify2(this, num);
         return this.red.mul(this, num);
       };
       BN.prototype.redIMul = function redIMul(num) {
         assert(this.red, "redMul works only with red numbers");
         this.red._verify2(this, num);
         return this.red.imul(this, num);
       };
       BN.prototype.redSqr = function redSqr() {
         assert(this.red, "redSqr works only with red numbers");
         this.red._verify1(this);
         return this.red.sqr(this);
       };
       BN.prototype.redISqr = function redISqr() {
         assert(this.red, "redISqr works only with red numbers");
         this.red._verify1(this);
         return this.red.isqr(this);
       };
       BN.prototype.redSqrt = function redSqrt() {
         assert(this.red, "redSqrt works only with red numbers");
         this.red._verify1(this);
         return this.red.sqrt(this);
       };
       BN.prototype.redInvm = function redInvm() {
         assert(this.red, "redInvm works only with red numbers");
         this.red._verify1(this);
         return this.red.invm(this);
       };
       BN.prototype.redNeg = function redNeg() {
         assert(this.red, "redNeg works only with red numbers");
         this.red._verify1(this);
         return this.red.neg(this);
       };
       BN.prototype.redPow = function redPow(num) {
         assert(this.red && !num.red, "redPow(normalNum)");
         this.red._verify1(this);
         return this.red.pow(this, num);
       };
       var primes = {
         k256: null,
         p224: null,
         p192: null,
         p25519: null
       };
       function MPrime(name, p) {
         this.name = name;
         this.p = new BN(p, 16);
         this.n = this.p.bitLength();
         this.k = new BN(1).iushln(this.n).isub(this.p);
         this.tmp = this._tmp();
       }
       MPrime.prototype._tmp = function _tmp() {
         var tmp = new BN(null);
         tmp.words = new Array(Math.ceil(this.n / 13));
         return tmp;
       };
       MPrime.prototype.ireduce = function ireduce(num) {
         var r = num;
         var rlen;
         do {
           this.split(r, this.tmp);
           r = this.imulK(r);
           r = r.iadd(this.tmp);
           rlen = r.bitLength();
         } while (rlen > this.n);
         var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
         if (cmp === 0) {
           r.words[0] = 0;
           r.length = 1;
         } else if (cmp > 0) {
           r.isub(this.p);
         } else {
           if (r.strip !== void 0) {
             r.strip();
           } else {
             r._strip();
           }
         }
         return r;
       };
       MPrime.prototype.split = function split(input, out) {
         input.iushrn(this.n, 0, out);
       };
       MPrime.prototype.imulK = function imulK(num) {
         return num.imul(this.k);
       };
       function K256() {
         MPrime.call(
           this,
           "k256",
           "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
         );
       }
       inherits(K256, MPrime);
       K256.prototype.split = function split(input, output) {
         var mask = 4194303;
         var outLen = Math.min(input.length, 9);
         for (var i = 0; i < outLen; i++) {
           output.words[i] = input.words[i];
         }
         output.length = outLen;
         if (input.length <= 9) {
           input.words[0] = 0;
           input.length = 1;
           return;
         }
         var prev = input.words[9];
         output.words[output.length++] = prev & mask;
         for (i = 10; i < input.length; i++) {
           var next = input.words[i] | 0;
           input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
           prev = next;
         }
         prev >>>= 22;
         input.words[i - 10] = prev;
         if (prev === 0 && input.length > 10) {
           input.length -= 10;
         } else {
           input.length -= 9;
         }
       };
       K256.prototype.imulK = function imulK(num) {
         num.words[num.length] = 0;
         num.words[num.length + 1] = 0;
         num.length += 2;
         var lo = 0;
         for (var i = 0; i < num.length; i++) {
           var w = num.words[i] | 0;
           lo += w * 977;
           num.words[i] = lo & 67108863;
           lo = w * 64 + (lo / 67108864 | 0);
         }
         if (num.words[num.length - 1] === 0) {
           num.length--;
           if (num.words[num.length - 1] === 0) {
             num.length--;
           }
         }
         return num;
       };
       function P224() {
         MPrime.call(
           this,
           "p224",
           "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
         );
       }
       inherits(P224, MPrime);
       function P192() {
         MPrime.call(
           this,
           "p192",
           "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
         );
       }
       inherits(P192, MPrime);
       function P25519() {
         MPrime.call(
           this,
           "25519",
           "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
         );
       }
       inherits(P25519, MPrime);
       P25519.prototype.imulK = function imulK(num) {
         var carry = 0;
         for (var i = 0; i < num.length; i++) {
           var hi = (num.words[i] | 0) * 19 + carry;
           var lo = hi & 67108863;
           hi >>>= 26;
           num.words[i] = lo;
           carry = hi;
         }
         if (carry !== 0) {
           num.words[num.length++] = carry;
         }
         return num;
       };
       BN._prime = function prime(name) {
         if (primes[name])
           return primes[name];
         var prime2;
         if (name === "k256") {
           prime2 = new K256();
         } else if (name === "p224") {
           prime2 = new P224();
         } else if (name === "p192") {
           prime2 = new P192();
         } else if (name === "p25519") {
           prime2 = new P25519();
         } else {
           throw new Error("Unknown prime " + name);
         }
         primes[name] = prime2;
         return prime2;
       };
       function Red(m) {
         if (typeof m === "string") {
           var prime = BN._prime(m);
           this.m = prime.p;
           this.prime = prime;
         } else {
           assert(m.gtn(1), "modulus must be greater than 1");
           this.m = m;
           this.prime = null;
         }
       }
       Red.prototype._verify1 = function _verify1(a) {
         assert(a.negative === 0, "red works only with positives");
         assert(a.red, "red works only with red numbers");
       };
       Red.prototype._verify2 = function _verify2(a, b) {
         assert((a.negative | b.negative) === 0, "red works only with positives");
         assert(
           a.red && a.red === b.red,
           "red works only with red numbers"
         );
       };
       Red.prototype.imod = function imod(a) {
         if (this.prime)
           return this.prime.ireduce(a)._forceRed(this);
         move(a, a.umod(this.m)._forceRed(this));
         return a;
       };
       Red.prototype.neg = function neg(a) {
         if (a.isZero()) {
           return a.clone();
         }
         return this.m.sub(a)._forceRed(this);
       };
       Red.prototype.add = function add(a, b) {
         this._verify2(a, b);
         var res = a.add(b);
         if (res.cmp(this.m) >= 0) {
           res.isub(this.m);
         }
         return res._forceRed(this);
       };
       Red.prototype.iadd = function iadd(a, b) {
         this._verify2(a, b);
         var res = a.iadd(b);
         if (res.cmp(this.m) >= 0) {
           res.isub(this.m);
         }
         return res;
       };
       Red.prototype.sub = function sub(a, b) {
         this._verify2(a, b);
         var res = a.sub(b);
         if (res.cmpn(0) < 0) {
           res.iadd(this.m);
         }
         return res._forceRed(this);
       };
       Red.prototype.isub = function isub(a, b) {
         this._verify2(a, b);
         var res = a.isub(b);
         if (res.cmpn(0) < 0) {
           res.iadd(this.m);
         }
         return res;
       };
       Red.prototype.shl = function shl(a, num) {
         this._verify1(a);
         return this.imod(a.ushln(num));
       };
       Red.prototype.imul = function imul(a, b) {
         this._verify2(a, b);
         return this.imod(a.imul(b));
       };
       Red.prototype.mul = function mul(a, b) {
         this._verify2(a, b);
         return this.imod(a.mul(b));
       };
       Red.prototype.isqr = function isqr(a) {
         return this.imul(a, a.clone());
       };
       Red.prototype.sqr = function sqr(a) {
         return this.mul(a, a);
       };
       Red.prototype.sqrt = function sqrt(a) {
         if (a.isZero())
           return a.clone();
         var mod3 = this.m.andln(3);
         assert(mod3 % 2 === 1);
         if (mod3 === 3) {
           var pow = this.m.add(new BN(1)).iushrn(2);
           return this.pow(a, pow);
         }
         var q = this.m.subn(1);
         var s = 0;
         while (!q.isZero() && q.andln(1) === 0) {
           s++;
           q.iushrn(1);
         }
         assert(!q.isZero());
         var one = new BN(1).toRed(this);
         var nOne = one.redNeg();
         var lpow = this.m.subn(1).iushrn(1);
         var z = this.m.bitLength();
         z = new BN(2 * z * z).toRed(this);
         while (this.pow(z, lpow).cmp(nOne) !== 0) {
           z.redIAdd(nOne);
         }
         var c = this.pow(z, q);
         var r = this.pow(a, q.addn(1).iushrn(1));
         var t = this.pow(a, q);
         var m = s;
         while (t.cmp(one) !== 0) {
           var tmp = t;
           for (var i = 0; tmp.cmp(one) !== 0; i++) {
             tmp = tmp.redSqr();
           }
           assert(i < m);
           var b = this.pow(c, new BN(1).iushln(m - i - 1));
           r = r.redMul(b);
           c = b.redSqr();
           t = t.redMul(c);
           m = i;
         }
         return r;
       };
       Red.prototype.invm = function invm(a) {
         var inv = a._invmp(this.m);
         if (inv.negative !== 0) {
           inv.negative = 0;
           return this.imod(inv).redNeg();
         } else {
           return this.imod(inv);
         }
       };
       Red.prototype.pow = function pow(a, num) {
         if (num.isZero())
           return new BN(1).toRed(this);
         if (num.cmpn(1) === 0)
           return a.clone();
         var windowSize = 4;
         var wnd = new Array(1 << windowSize);
         wnd[0] = new BN(1).toRed(this);
         wnd[1] = a;
         for (var i = 2; i < wnd.length; i++) {
           wnd[i] = this.mul(wnd[i - 1], a);
         }
         var res = wnd[0];
         var current = 0;
         var currentLen = 0;
         var start = num.bitLength() % 26;
         if (start === 0) {
           start = 26;
         }
         for (i = num.length - 1; i >= 0; i--) {
           var word = num.words[i];
           for (var j = start - 1; j >= 0; j--) {
             var bit = word >> j & 1;
             if (res !== wnd[0]) {
               res = this.sqr(res);
             }
             if (bit === 0 && current === 0) {
               currentLen = 0;
               continue;
             }
             current <<= 1;
             current |= bit;
             currentLen++;
             if (currentLen !== windowSize && (i !== 0 || j !== 0))
               continue;
             res = this.mul(res, wnd[current]);
             currentLen = 0;
             current = 0;
           }
           start = 26;
         }
         return res;
       };
       Red.prototype.convertTo = function convertTo(num) {
         var r = num.umod(this.m);
         return r === num ? r.clone() : r;
       };
       Red.prototype.convertFrom = function convertFrom(num) {
         var res = num.clone();
         res.red = null;
         return res;
       };
       BN.mont = function mont(num) {
         return new Mont(num);
       };
       function Mont(m) {
         Red.call(this, m);
         this.shift = this.m.bitLength();
         if (this.shift % 26 !== 0) {
           this.shift += 26 - this.shift % 26;
         }
         this.r = new BN(1).iushln(this.shift);
         this.r2 = this.imod(this.r.sqr());
         this.rinv = this.r._invmp(this.m);
         this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
         this.minv = this.minv.umod(this.r);
         this.minv = this.r.sub(this.minv);
       }
       inherits(Mont, Red);
       Mont.prototype.convertTo = function convertTo(num) {
         return this.imod(num.ushln(this.shift));
       };
       Mont.prototype.convertFrom = function convertFrom(num) {
         var r = this.imod(num.mul(this.rinv));
         r.red = null;
         return r;
       };
       Mont.prototype.imul = function imul(a, b) {
         if (a.isZero() || b.isZero()) {
           a.words[0] = 0;
           a.length = 1;
           return a;
         }
         var t = a.imul(b);
         var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
         var u = t.isub(c).iushrn(this.shift);
         var res = u;
         if (u.cmp(this.m) >= 0) {
           res = u.isub(this.m);
         } else if (u.cmpn(0) < 0) {
           res = u.iadd(this.m);
         }
         return res._forceRed(this);
       };
       Mont.prototype.mul = function mul(a, b) {
         if (a.isZero() || b.isZero())
           return new BN(0)._forceRed(this);
         var t = a.mul(b);
         var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
         var u = t.isub(c).iushrn(this.shift);
         var res = u;
         if (u.cmp(this.m) >= 0) {
           res = u.isub(this.m);
         } else if (u.cmpn(0) < 0) {
           res = u.iadd(this.m);
         }
         return res._forceRed(this);
       };
       Mont.prototype.invm = function invm(a) {
         var res = this.imod(a._invmp(this.m).mul(this.r2));
         return res._forceRed(this);
       };
     })(typeof module2 === "undefined" || module2, exports);
   }
 });
 
 // node_modules/bittorrent-tracker/lib/client/udp-tracker.js
 var require_udp_tracker = __commonJS({
   "node_modules/bittorrent-tracker/lib/client/udp-tracker.js"(exports, module2) {
     var arrayRemove = require_unordered_array_remove();
     var BN = require_bn();
     var clone = require_clone();
     var compact2string = require_compact2string();
     var debug = require_src()("bittorrent-tracker:udp-tracker");
     var dgram = require("dgram");
     var randombytes2 = require_randombytes();
     var Socks = require_build();
     var common = require_common2();
     var Tracker = require_tracker();
     var UDPTracker = class extends Tracker {
       constructor(client, announceUrl) {
         super(client, announceUrl);
         debug("new udp tracker %s", announceUrl);
         this.cleanupFns = [];
         this.maybeDestroyCleanup = null;
       }
       announce(opts) {
         if (this.destroyed)
           return;
         this._request(opts);
       }
       scrape(opts) {
         if (this.destroyed)
           return;
         opts._scrape = true;
         this._request(opts);
       }
       destroy(cb) {
         const self = this;
         if (this.destroyed)
           return cb(null);
         this.destroyed = true;
         clearInterval(this.interval);
         let timeout;
         if (this.cleanupFns.length === 0)
           return destroyCleanup();
         timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT);
         this.maybeDestroyCleanup = () => {
           if (this.cleanupFns.length === 0)
             destroyCleanup();
         };
         function destroyCleanup() {
           if (timeout) {
             clearTimeout(timeout);
             timeout = null;
           }
           self.maybeDestroyCleanup = null;
           self.cleanupFns.slice(0).forEach((cleanup) => {
             cleanup();
           });
           self.cleanupFns = [];
           cb(null);
         }
       }
       _request(opts) {
         const self = this;
         if (!opts)
           opts = {};
         let { hostname, port } = common.parseUrl(this.announceUrl);
         if (port === "")
           port = 80;
         let timeout;
         let proxySocket;
         let socket;
         let relay;
         let transactionId = genTransactionId();
         const proxyOpts = this.client._proxyOpts && clone(this.client._proxyOpts.socksProxy);
         if (proxyOpts) {
           if (!proxyOpts.proxy)
             proxyOpts.proxy = {};
           proxyOpts.proxy.command = "associate";
           if (!proxyOpts.target) {
             proxyOpts.target = {
               host: "0.0.0.0",
               port: 0
             };
           }
           if (proxyOpts.proxy.type === 5) {
             Socks.createConnection(proxyOpts, onGotConnection);
           } else {
             debug("Ignoring Socks proxy for UDP request because type 5 is required");
             onGotConnection(null);
           }
         } else {
           onGotConnection(null);
         }
         this.cleanupFns.push(cleanup);
         function onGotConnection(err, s, info) {
           if (err)
             return onError(err);
           proxySocket = s;
           socket = dgram.createSocket("udp4");
           relay = info;
           timeout = setTimeout(() => {
             if (opts.event === "stopped")
               cleanup();
             else
               onError(new Error(`tracker request timed out (${opts.event})`));
             timeout = null;
           }, common.REQUEST_TIMEOUT);
           if (timeout.unref)
             timeout.unref();
           send(Buffer.concat([
             common.CONNECTION_ID,
             common.toUInt32(common.ACTIONS.CONNECT),
             transactionId
           ]), relay);
           socket.once("error", onError);
           socket.on("message", onSocketMessage);
         }
         function cleanup() {
           if (timeout) {
             clearTimeout(timeout);
             timeout = null;
           }
           if (socket) {
             arrayRemove(self.cleanupFns, self.cleanupFns.indexOf(cleanup));
             socket.removeListener("error", onError);
             socket.removeListener("message", onSocketMessage);
             socket.on("error", noop2);
             try {
               socket.close();
             } catch (err) {
             }
             socket = null;
             if (proxySocket) {
               try {
                 proxySocket.close();
               } catch (err) {
               }
               proxySocket = null;
             }
           }
           if (self.maybeDestroyCleanup)
             self.maybeDestroyCleanup();
         }
         function onError(err) {
           cleanup();
           if (self.destroyed)
             return;
           try {
             if (err.message)
               err.message += ` (${self.announceUrl})`;
           } catch (ignoredErr) {
           }
           self.client.emit("warning", err);
         }
         function onSocketMessage(msg) {
           if (proxySocket)
             msg = msg.slice(10);
           if (msg.length < 8 || msg.readUInt32BE(4) !== transactionId.readUInt32BE(0)) {
             return onError(new Error("tracker sent invalid transaction id"));
           }
           const action = msg.readUInt32BE(0);
           debug("UDP response %s, action %s", self.announceUrl, action);
           switch (action) {
             case 0: {
               if (msg.length < 16)
                 return onError(new Error("invalid udp handshake"));
               if (opts._scrape)
                 scrape(msg.slice(8, 16));
               else
                 announce(msg.slice(8, 16), opts);
               break;
             }
             case 1: {
               cleanup();
               if (self.destroyed)
                 return;
               if (msg.length < 20)
                 return onError(new Error("invalid announce message"));
               const interval = msg.readUInt32BE(8);
               if (interval)
                 self.setInterval(interval * 1e3);
               self.client.emit("update", {
                 announce: self.announceUrl,
                 complete: msg.readUInt32BE(16),
                 incomplete: msg.readUInt32BE(12)
               });
               let addrs;
               try {
                 addrs = compact2string.multi(msg.slice(20));
               } catch (err) {
                 return self.client.emit("warning", err);
               }
               addrs.forEach((addr) => {
                 self.client.emit("peer", addr);
               });
               break;
             }
             case 2: {
               cleanup();
               if (self.destroyed)
                 return;
               if (msg.length < 20 || (msg.length - 8) % 12 !== 0) {
                 return onError(new Error("invalid scrape message"));
               }
               const infoHashes = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? opts.infoHash.map((infoHash) => infoHash.toString("hex")) : [opts.infoHash && opts.infoHash.toString("hex") || self.client.infoHash];
               for (let i = 0, len = (msg.length - 8) / 12; i < len; i += 1) {
                 self.client.emit("scrape", {
                   announce: self.announceUrl,
                   infoHash: infoHashes[i],
                   complete: msg.readUInt32BE(8 + i * 12),
                   downloaded: msg.readUInt32BE(12 + i * 12),
                   incomplete: msg.readUInt32BE(16 + i * 12)
                 });
               }
               break;
             }
             case 3: {
               cleanup();
               if (self.destroyed)
                 return;
               if (msg.length < 8)
                 return onError(new Error("invalid error message"));
               self.client.emit("warning", new Error(msg.slice(8).toString()));
               break;
             }
             default:
               onError(new Error("tracker sent invalid action"));
               break;
           }
         }
         function send(message, proxyInfo) {
           if (proxyInfo) {
             const pack = Socks.createUDPFrame({ host: hostname, port }, message);
             socket.send(pack, 0, pack.length, proxyInfo.port, proxyInfo.host);
           } else {
             socket.send(message, 0, message.length, port, hostname);
           }
         }
         function announce(connectionId, opts2) {
           transactionId = genTransactionId();
           send(Buffer.concat([
             connectionId,
             common.toUInt32(common.ACTIONS.ANNOUNCE),
             transactionId,
             self.client._infoHashBuffer,
             self.client._peerIdBuffer,
             toUInt64(opts2.downloaded),
             opts2.left != null ? toUInt64(opts2.left) : Buffer.from("FFFFFFFFFFFFFFFF", "hex"),
             toUInt64(opts2.uploaded),
             common.toUInt32(common.EVENTS[opts2.event] || 0),
             common.toUInt32(0),
             common.toUInt32(0),
             common.toUInt32(opts2.numwant),
             toUInt16(self.client._port)
           ]), relay);
         }
         function scrape(connectionId) {
           transactionId = genTransactionId();
           const infoHash = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? Buffer.concat(opts.infoHash) : opts.infoHash || self.client._infoHashBuffer;
           send(Buffer.concat([
             connectionId,
             common.toUInt32(common.ACTIONS.SCRAPE),
             transactionId,
             infoHash
           ]), relay);
         }
       }
     };
     UDPTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 60 * 1e3;
     function genTransactionId() {
       return randombytes2(4);
     }
     function toUInt16(n) {
       const buf = Buffer.allocUnsafe(2);
       buf.writeUInt16BE(n, 0);
       return buf;
     }
     var MAX_UINT = 4294967295;
     function toUInt64(n) {
       if (n > MAX_UINT || typeof n === "string") {
         const bytes = new BN(n).toArray();
         while (bytes.length < 8) {
           bytes.unshift(0);
         }
         return Buffer.from(bytes);
       }
       return Buffer.concat([common.toUInt32(0), common.toUInt32(n)]);
     }
     function noop2() {
     }
     module2.exports = UDPTracker;
   }
 });
 
 // node_modules/ws/lib/constants.js
 var require_constants2 = __commonJS({
   "node_modules/ws/lib/constants.js"(exports, module2) {
     "use strict";
     module2.exports = {
       BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
       GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
       kStatusCode: Symbol("status-code"),
       kWebSocket: Symbol("websocket"),
       EMPTY_BUFFER: Buffer.alloc(0),
       NOOP: () => {
       }
     };
   }
 });
 
 // node_modules/bufferutil/fallback.js
 var require_fallback = __commonJS({
   "node_modules/bufferutil/fallback.js"(exports, module2) {
     "use strict";
     var mask = (source, mask2, output, offset, length) => {
       for (var i = 0; i < length; i++) {
         output[offset + i] = source[i] ^ mask2[i & 3];
       }
     };
     var unmask = (buffer, mask2) => {
       const length = buffer.length;
       for (var i = 0; i < length; i++) {
         buffer[i] ^= mask2[i & 3];
       }
     };
     module2.exports = { mask, unmask };
   }
 });
 
 // node_modules/bufferutil/index.js
 var require_bufferutil = __commonJS({
   "node_modules/bufferutil/index.js"(exports, module2) {
     "use strict";
     try {
       module2.exports = require_node_gyp_build()(__dirname);
     } catch (e) {
       module2.exports = require_fallback();
     }
   }
 });
 
 // node_modules/ws/lib/buffer-util.js
 var require_buffer_util = __commonJS({
   "node_modules/ws/lib/buffer-util.js"(exports, module2) {
     "use strict";
     var { EMPTY_BUFFER } = require_constants2();
     function concat(list, totalLength) {
       if (list.length === 0)
         return EMPTY_BUFFER;
       if (list.length === 1)
         return list[0];
       const target = Buffer.allocUnsafe(totalLength);
       let offset = 0;
       for (let i = 0; i < list.length; i++) {
         const buf = list[i];
         target.set(buf, offset);
         offset += buf.length;
       }
       if (offset < totalLength)
         return target.slice(0, offset);
       return target;
     }
     function _mask(source, mask, output, offset, length) {
       for (let i = 0; i < length; i++) {
         output[offset + i] = source[i] ^ mask[i & 3];
       }
     }
     function _unmask(buffer, mask) {
       const length = buffer.length;
       for (let i = 0; i < length; i++) {
         buffer[i] ^= mask[i & 3];
       }
     }
     function toArrayBuffer(buf) {
       if (buf.byteLength === buf.buffer.byteLength) {
         return buf.buffer;
       }
       return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
     }
     function toBuffer(data) {
       toBuffer.readOnly = true;
       if (Buffer.isBuffer(data))
         return data;
       let buf;
       if (data instanceof ArrayBuffer) {
         buf = Buffer.from(data);
       } else if (ArrayBuffer.isView(data)) {
         buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
       } else {
         buf = Buffer.from(data);
         toBuffer.readOnly = false;
       }
       return buf;
     }
     try {
       const bufferUtil = require_bufferutil();
       const bu = bufferUtil.BufferUtil || bufferUtil;
       module2.exports = {
         concat,
         mask(source, mask, output, offset, length) {
           if (length < 48)
             _mask(source, mask, output, offset, length);
           else
             bu.mask(source, mask, output, offset, length);
         },
         toArrayBuffer,
         toBuffer,
         unmask(buffer, mask) {
           if (buffer.length < 32)
             _unmask(buffer, mask);
           else
             bu.unmask(buffer, mask);
         }
       };
     } catch (e) {
       module2.exports = {
         concat,
         mask: _mask,
         toArrayBuffer,
         toBuffer,
         unmask: _unmask
       };
     }
   }
 });
 
 // node_modules/ws/lib/limiter.js
 var require_limiter2 = __commonJS({
   "node_modules/ws/lib/limiter.js"(exports, module2) {
     "use strict";
     var kDone = Symbol("kDone");
     var kRun = Symbol("kRun");
     var Limiter = class {
       constructor(concurrency) {
         this[kDone] = () => {
           this.pending--;
           this[kRun]();
         };
         this.concurrency = concurrency || Infinity;
         this.jobs = [];
         this.pending = 0;
       }
       add(job) {
         this.jobs.push(job);
         this[kRun]();
       }
       [kRun]() {
         if (this.pending === this.concurrency)
           return;
         if (this.jobs.length) {
           const job = this.jobs.shift();
           this.pending++;
           job(this[kDone]);
         }
       }
     };
     module2.exports = Limiter;
   }
 });
 
 // node_modules/ws/lib/permessage-deflate.js
 var require_permessage_deflate = __commonJS({
   "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
     "use strict";
     var zlib = require("zlib");
     var bufferUtil = require_buffer_util();
     var Limiter = require_limiter2();
     var { kStatusCode, NOOP } = require_constants2();
     var TRAILER = Buffer.from([0, 0, 255, 255]);
     var kPerMessageDeflate = Symbol("permessage-deflate");
     var kTotalLength = Symbol("total-length");
     var kCallback = Symbol("callback");
     var kBuffers = Symbol("buffers");
     var kError = Symbol("error");
     var zlibLimiter;
     var PerMessageDeflate = class {
       constructor(options, isServer, maxPayload) {
         this._maxPayload = maxPayload | 0;
         this._options = options || {};
         this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
         this._isServer = !!isServer;
         this._deflate = null;
         this._inflate = null;
         this.params = null;
         if (!zlibLimiter) {
           const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
           zlibLimiter = new Limiter(concurrency);
         }
       }
       static get extensionName() {
         return "permessage-deflate";
       }
       offer() {
         const params = {};
         if (this._options.serverNoContextTakeover) {
           params.server_no_context_takeover = true;
         }
         if (this._options.clientNoContextTakeover) {
           params.client_no_context_takeover = true;
         }
         if (this._options.serverMaxWindowBits) {
           params.server_max_window_bits = this._options.serverMaxWindowBits;
         }
         if (this._options.clientMaxWindowBits) {
           params.client_max_window_bits = this._options.clientMaxWindowBits;
         } else if (this._options.clientMaxWindowBits == null) {
           params.client_max_window_bits = true;
         }
         return params;
       }
       accept(configurations) {
         configurations = this.normalizeParams(configurations);
         this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
         return this.params;
       }
       cleanup() {
         if (this._inflate) {
           this._inflate.close();
           this._inflate = null;
         }
         if (this._deflate) {
           const callback = this._deflate[kCallback];
           this._deflate.close();
           this._deflate = null;
           if (callback) {
             callback(
               new Error(
                 "The deflate stream was closed while data was being processed"
               )
             );
           }
         }
       }
       acceptAsServer(offers) {
         const opts = this._options;
         const accepted = offers.find((params) => {
           if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
             return false;
           }
           return true;
         });
         if (!accepted) {
           throw new Error("None of the extension offers can be accepted");
         }
         if (opts.serverNoContextTakeover) {
           accepted.server_no_context_takeover = true;
         }
         if (opts.clientNoContextTakeover) {
           accepted.client_no_context_takeover = true;
         }
         if (typeof opts.serverMaxWindowBits === "number") {
           accepted.server_max_window_bits = opts.serverMaxWindowBits;
         }
         if (typeof opts.clientMaxWindowBits === "number") {
           accepted.client_max_window_bits = opts.clientMaxWindowBits;
         } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
           delete accepted.client_max_window_bits;
         }
         return accepted;
       }
       acceptAsClient(response) {
         const params = response[0];
         if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
           throw new Error('Unexpected parameter "client_no_context_takeover"');
         }
         if (!params.client_max_window_bits) {
           if (typeof this._options.clientMaxWindowBits === "number") {
             params.client_max_window_bits = this._options.clientMaxWindowBits;
           }
         } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
           throw new Error(
             'Unexpected or invalid parameter "client_max_window_bits"'
           );
         }
         return params;
       }
       normalizeParams(configurations) {
         configurations.forEach((params) => {
           Object.keys(params).forEach((key) => {
             let value = params[key];
             if (value.length > 1) {
               throw new Error(`Parameter "${key}" must have only a single value`);
             }
             value = value[0];
             if (key === "client_max_window_bits") {
               if (value !== true) {
                 const num = +value;
                 if (!Number.isInteger(num) || num < 8 || num > 15) {
                   throw new TypeError(
                     `Invalid value for parameter "${key}": ${value}`
                   );
                 }
                 value = num;
               } else if (!this._isServer) {
                 throw new TypeError(
                   `Invalid value for parameter "${key}": ${value}`
                 );
               }
             } else if (key === "server_max_window_bits") {
               const num = +value;
               if (!Number.isInteger(num) || num < 8 || num > 15) {
                 throw new TypeError(
                   `Invalid value for parameter "${key}": ${value}`
                 );
               }
               value = num;
             } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
               if (value !== true) {
                 throw new TypeError(
                   `Invalid value for parameter "${key}": ${value}`
                 );
               }
             } else {
               throw new Error(`Unknown parameter "${key}"`);
             }
             params[key] = value;
           });
         });
         return configurations;
       }
       decompress(data, fin, callback) {
         zlibLimiter.add((done) => {
           this._decompress(data, fin, (err, result) => {
             done();
             callback(err, result);
           });
         });
       }
       compress(data, fin, callback) {
         zlibLimiter.add((done) => {
           this._compress(data, fin, (err, result) => {
             done();
             callback(err, result);
           });
         });
       }
       _decompress(data, fin, callback) {
         const endpoint = this._isServer ? "client" : "server";
         if (!this._inflate) {
           const key = `${endpoint}_max_window_bits`;
           const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
           this._inflate = zlib.createInflateRaw({
             ...this._options.zlibInflateOptions,
             windowBits
           });
           this._inflate[kPerMessageDeflate] = this;
           this._inflate[kTotalLength] = 0;
           this._inflate[kBuffers] = [];
           this._inflate.on("error", inflateOnError);
           this._inflate.on("data", inflateOnData);
         }
         this._inflate[kCallback] = callback;
         this._inflate.write(data);
         if (fin)
           this._inflate.write(TRAILER);
         this._inflate.flush(() => {
           const err = this._inflate[kError];
           if (err) {
             this._inflate.close();
             this._inflate = null;
             callback(err);
             return;
           }
           const data2 = bufferUtil.concat(
             this._inflate[kBuffers],
             this._inflate[kTotalLength]
           );
           if (this._inflate._readableState.endEmitted) {
             this._inflate.close();
             this._inflate = null;
           } else {
             this._inflate[kTotalLength] = 0;
             this._inflate[kBuffers] = [];
             if (fin && this.params[`${endpoint}_no_context_takeover`]) {
               this._inflate.reset();
             }
           }
           callback(null, data2);
         });
       }
       _compress(data, fin, callback) {
         const endpoint = this._isServer ? "server" : "client";
         if (!this._deflate) {
           const key = `${endpoint}_max_window_bits`;
           const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
           this._deflate = zlib.createDeflateRaw({
             ...this._options.zlibDeflateOptions,
             windowBits
           });
           this._deflate[kTotalLength] = 0;
           this._deflate[kBuffers] = [];
           this._deflate.on("error", NOOP);
           this._deflate.on("data", deflateOnData);
         }
         this._deflate[kCallback] = callback;
         this._deflate.write(data);
         this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
           if (!this._deflate) {
             return;
           }
           let data2 = bufferUtil.concat(
             this._deflate[kBuffers],
             this._deflate[kTotalLength]
           );
           if (fin)
             data2 = data2.slice(0, data2.length - 4);
           this._deflate[kCallback] = null;
           this._deflate[kTotalLength] = 0;
           this._deflate[kBuffers] = [];
           if (fin && this.params[`${endpoint}_no_context_takeover`]) {
             this._deflate.reset();
           }
           callback(null, data2);
         });
       }
     };
     module2.exports = PerMessageDeflate;
     function deflateOnData(chunk) {
       this[kBuffers].push(chunk);
       this[kTotalLength] += chunk.length;
     }
     function inflateOnData(chunk) {
       this[kTotalLength] += chunk.length;
       if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
         this[kBuffers].push(chunk);
         return;
       }
       this[kError] = new RangeError("Max payload size exceeded");
       this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
       this[kError][kStatusCode] = 1009;
       this.removeListener("data", inflateOnData);
       this.reset();
     }
     function inflateOnError(err) {
       this[kPerMessageDeflate]._inflate = null;
       err[kStatusCode] = 1007;
       this[kCallback](err);
     }
   }
 });
 
 // node_modules/utf-8-validate/fallback.js
 var require_fallback2 = __commonJS({
   "node_modules/utf-8-validate/fallback.js"(exports, module2) {
     "use strict";
     function isValidUTF8(buf) {
       const len = buf.length;
       let i = 0;
       while (i < len) {
         if ((buf[i] & 128) === 0) {
           i++;
         } else if ((buf[i] & 224) === 192) {
           if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
             return false;
           }
           i += 2;
         } else if ((buf[i] & 240) === 224) {
           if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
             return false;
           }
           i += 3;
         } else if ((buf[i] & 248) === 240) {
           if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
             return false;
           }
           i += 4;
         } else {
           return false;
         }
       }
       return true;
     }
     module2.exports = isValidUTF8;
   }
 });
 
 // node_modules/utf-8-validate/index.js
 var require_utf_8_validate = __commonJS({
   "node_modules/utf-8-validate/index.js"(exports, module2) {
     "use strict";
     try {
       module2.exports = require_node_gyp_build()(__dirname);
     } catch (e) {
       module2.exports = require_fallback2();
     }
   }
 });
 
 // node_modules/ws/lib/validation.js
 var require_validation = __commonJS({
   "node_modules/ws/lib/validation.js"(exports, module2) {
     "use strict";
     function isValidStatusCode(code) {
       return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
     }
     function _isValidUTF8(buf) {
       const len = buf.length;
       let i = 0;
       while (i < len) {
         if ((buf[i] & 128) === 0) {
           i++;
         } else if ((buf[i] & 224) === 192) {
           if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
             return false;
           }
           i += 2;
         } else if ((buf[i] & 240) === 224) {
           if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
             return false;
           }
           i += 3;
         } else if ((buf[i] & 248) === 240) {
           if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
             return false;
           }
           i += 4;
         } else {
           return false;
         }
       }
       return true;
     }
     try {
       let isValidUTF8 = require_utf_8_validate();
       if (typeof isValidUTF8 === "object") {
         isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
       }
       module2.exports = {
         isValidStatusCode,
         isValidUTF8(buf) {
           return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
         }
       };
     } catch (e) {
       module2.exports = {
         isValidStatusCode,
         isValidUTF8: _isValidUTF8
       };
     }
   }
 });
 
 // node_modules/ws/lib/receiver.js
 var require_receiver = __commonJS({
   "node_modules/ws/lib/receiver.js"(exports, module2) {
     "use strict";
     var { Writable } = require("stream");
     var PerMessageDeflate = require_permessage_deflate();
     var {
       BINARY_TYPES,
       EMPTY_BUFFER,
       kStatusCode,
       kWebSocket
     } = require_constants2();
     var { concat, toArrayBuffer, unmask } = require_buffer_util();
     var { isValidStatusCode, isValidUTF8 } = require_validation();
     var GET_INFO = 0;
     var GET_PAYLOAD_LENGTH_16 = 1;
     var GET_PAYLOAD_LENGTH_64 = 2;
     var GET_MASK = 3;
     var GET_DATA = 4;
     var INFLATING = 5;
     var Receiver = class extends Writable {
       constructor(binaryType, extensions, isServer, maxPayload) {
         super();
         this._binaryType = binaryType || BINARY_TYPES[0];
         this[kWebSocket] = void 0;
         this._extensions = extensions || {};
         this._isServer = !!isServer;
         this._maxPayload = maxPayload | 0;
         this._bufferedBytes = 0;
         this._buffers = [];
         this._compressed = false;
         this._payloadLength = 0;
         this._mask = void 0;
         this._fragmented = 0;
         this._masked = false;
         this._fin = false;
         this._opcode = 0;
         this._totalPayloadLength = 0;
         this._messageLength = 0;
         this._fragments = [];
         this._state = GET_INFO;
         this._loop = false;
       }
       _write(chunk, encoding, cb) {
         if (this._opcode === 8 && this._state == GET_INFO)
           return cb();
         this._bufferedBytes += chunk.length;
         this._buffers.push(chunk);
         this.startLoop(cb);
       }
       consume(n) {
         this._bufferedBytes -= n;
         if (n === this._buffers[0].length)
           return this._buffers.shift();
         if (n < this._buffers[0].length) {
           const buf = this._buffers[0];
           this._buffers[0] = buf.slice(n);
           return buf.slice(0, n);
         }
         const dst = Buffer.allocUnsafe(n);
         do {
           const buf = this._buffers[0];
           const offset = dst.length - n;
           if (n >= buf.length) {
             dst.set(this._buffers.shift(), offset);
           } else {
             dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
             this._buffers[0] = buf.slice(n);
           }
           n -= buf.length;
         } while (n > 0);
         return dst;
       }
       startLoop(cb) {
         let err;
         this._loop = true;
         do {
           switch (this._state) {
             case GET_INFO:
               err = this.getInfo();
               break;
             case GET_PAYLOAD_LENGTH_16:
               err = this.getPayloadLength16();
               break;
             case GET_PAYLOAD_LENGTH_64:
               err = this.getPayloadLength64();
               break;
             case GET_MASK:
               this.getMask();
               break;
             case GET_DATA:
               err = this.getData(cb);
               break;
             default:
               this._loop = false;
               return;
           }
         } while (this._loop);
         cb(err);
       }
       getInfo() {
         if (this._bufferedBytes < 2) {
           this._loop = false;
           return;
         }
         const buf = this.consume(2);
         if ((buf[0] & 48) !== 0) {
           this._loop = false;
           return error(
             RangeError,
             "RSV2 and RSV3 must be clear",
             true,
             1002,
             "WS_ERR_UNEXPECTED_RSV_2_3"
           );
         }
         const compressed = (buf[0] & 64) === 64;
         if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
           this._loop = false;
           return error(
             RangeError,
             "RSV1 must be clear",
             true,
             1002,
             "WS_ERR_UNEXPECTED_RSV_1"
           );
         }
         this._fin = (buf[0] & 128) === 128;
         this._opcode = buf[0] & 15;
         this._payloadLength = buf[1] & 127;
         if (this._opcode === 0) {
           if (compressed) {
             this._loop = false;
             return error(
               RangeError,
               "RSV1 must be clear",
               true,
               1002,
               "WS_ERR_UNEXPECTED_RSV_1"
             );
           }
           if (!this._fragmented) {
             this._loop = false;
             return error(
               RangeError,
               "invalid opcode 0",
               true,
               1002,
               "WS_ERR_INVALID_OPCODE"
             );
           }
           this._opcode = this._fragmented;
         } else if (this._opcode === 1 || this._opcode === 2) {
           if (this._fragmented) {
             this._loop = false;
             return error(
               RangeError,
               `invalid opcode ${this._opcode}`,
               true,
               1002,
               "WS_ERR_INVALID_OPCODE"
             );
           }
           this._compressed = compressed;
         } else if (this._opcode > 7 && this._opcode < 11) {
           if (!this._fin) {
             this._loop = false;
             return error(
               RangeError,
               "FIN must be set",
               true,
               1002,
               "WS_ERR_EXPECTED_FIN"
             );
           }
           if (compressed) {
             this._loop = false;
             return error(
               RangeError,
               "RSV1 must be clear",
               true,
               1002,
               "WS_ERR_UNEXPECTED_RSV_1"
             );
           }
           if (this._payloadLength > 125) {
             this._loop = false;
             return error(
               RangeError,
               `invalid payload length ${this._payloadLength}`,
               true,
               1002,
               "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
             );
           }
         } else {
           this._loop = false;
           return error(
             RangeError,
             `invalid opcode ${this._opcode}`,
             true,
             1002,
             "WS_ERR_INVALID_OPCODE"
           );
         }
         if (!this._fin && !this._fragmented)
           this._fragmented = this._opcode;
         this._masked = (buf[1] & 128) === 128;
         if (this._isServer) {
           if (!this._masked) {
             this._loop = false;
             return error(
               RangeError,
               "MASK must be set",
               true,
               1002,
               "WS_ERR_EXPECTED_MASK"
             );
           }
         } else if (this._masked) {
           this._loop = false;
           return error(
             RangeError,
             "MASK must be clear",
             true,
             1002,
             "WS_ERR_UNEXPECTED_MASK"
           );
         }
         if (this._payloadLength === 126)
           this._state = GET_PAYLOAD_LENGTH_16;
         else if (this._payloadLength === 127)
           this._state = GET_PAYLOAD_LENGTH_64;
         else
           return this.haveLength();
       }
       getPayloadLength16() {
         if (this._bufferedBytes < 2) {
           this._loop = false;
           return;
         }
         this._payloadLength = this.consume(2).readUInt16BE(0);
         return this.haveLength();
       }
       getPayloadLength64() {
         if (this._bufferedBytes < 8) {
           this._loop = false;
           return;
         }
         const buf = this.consume(8);
         const num = buf.readUInt32BE(0);
         if (num > Math.pow(2, 53 - 32) - 1) {
           this._loop = false;
           return error(
             RangeError,
             "Unsupported WebSocket frame: payload length > 2^53 - 1",
             false,
             1009,
             "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
           );
         }
         this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
         return this.haveLength();
       }
       haveLength() {
         if (this._payloadLength && this._opcode < 8) {
           this._totalPayloadLength += this._payloadLength;
           if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
             this._loop = false;
             return error(
               RangeError,
               "Max payload size exceeded",
               false,
               1009,
               "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
             );
           }
         }
         if (this._masked)
           this._state = GET_MASK;
         else
           this._state = GET_DATA;
       }
       getMask() {
         if (this._bufferedBytes < 4) {
           this._loop = false;
           return;
         }
         this._mask = this.consume(4);
         this._state = GET_DATA;
       }
       getData(cb) {
         let data = EMPTY_BUFFER;
         if (this._payloadLength) {
           if (this._bufferedBytes < this._payloadLength) {
             this._loop = false;
             return;
           }
           data = this.consume(this._payloadLength);
           if (this._masked)
             unmask(data, this._mask);
         }
         if (this._opcode > 7)
           return this.controlMessage(data);
         if (this._compressed) {
           this._state = INFLATING;
           this.decompress(data, cb);
           return;
         }
         if (data.length) {
           this._messageLength = this._totalPayloadLength;
           this._fragments.push(data);
         }
         return this.dataMessage();
       }
       decompress(data, cb) {
         const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
         perMessageDeflate.decompress(data, this._fin, (err, buf) => {
           if (err)
             return cb(err);
           if (buf.length) {
             this._messageLength += buf.length;
             if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
               return cb(
                 error(
                   RangeError,
                   "Max payload size exceeded",
                   false,
                   1009,
                   "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                 )
               );
             }
             this._fragments.push(buf);
           }
           const er = this.dataMessage();
           if (er)
             return cb(er);
           this.startLoop(cb);
         });
       }
       dataMessage() {
         if (this._fin) {
           const messageLength = this._messageLength;
           const fragments = this._fragments;
           this._totalPayloadLength = 0;
           this._messageLength = 0;
           this._fragmented = 0;
           this._fragments = [];
           if (this._opcode === 2) {
             let data;
             if (this._binaryType === "nodebuffer") {
               data = concat(fragments, messageLength);
             } else if (this._binaryType === "arraybuffer") {
               data = toArrayBuffer(concat(fragments, messageLength));
             } else {
               data = fragments;
             }
             this.emit("message", data);
           } else {
             const buf = concat(fragments, messageLength);
             if (!isValidUTF8(buf)) {
               this._loop = false;
               return error(
                 Error,
                 "invalid UTF-8 sequence",
                 true,
                 1007,
                 "WS_ERR_INVALID_UTF8"
               );
             }
             this.emit("message", buf.toString());
           }
         }
         this._state = GET_INFO;
       }
       controlMessage(data) {
         if (this._opcode === 8) {
           this._loop = false;
           if (data.length === 0) {
             this.emit("conclude", 1005, "");
             this.end();
           } else if (data.length === 1) {
             return error(
               RangeError,
               "invalid payload length 1",
               true,
               1002,
               "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
             );
           } else {
             const code = data.readUInt16BE(0);
             if (!isValidStatusCode(code)) {
               return error(
                 RangeError,
                 `invalid status code ${code}`,
                 true,
                 1002,
                 "WS_ERR_INVALID_CLOSE_CODE"
               );
             }
             const buf = data.slice(2);
             if (!isValidUTF8(buf)) {
               return error(
                 Error,
                 "invalid UTF-8 sequence",
                 true,
                 1007,
                 "WS_ERR_INVALID_UTF8"
               );
             }
             this.emit("conclude", code, buf.toString());
             this.end();
           }
         } else if (this._opcode === 9) {
           this.emit("ping", data);
         } else {
           this.emit("pong", data);
         }
         this._state = GET_INFO;
       }
     };
     module2.exports = Receiver;
     function error(ErrorCtor, message, prefix, statusCode, errorCode) {
       const err = new ErrorCtor(
         prefix ? `Invalid WebSocket frame: ${message}` : message
       );
       Error.captureStackTrace(err, error);
       err.code = errorCode;
       err[kStatusCode] = statusCode;
       return err;
     }
   }
 });
 
 // node_modules/ws/lib/sender.js
 var require_sender = __commonJS({
   "node_modules/ws/lib/sender.js"(exports, module2) {
     "use strict";
     var net = require("net");
     var tls = require("tls");
     var { randomFillSync } = require("crypto");
     var PerMessageDeflate = require_permessage_deflate();
     var { EMPTY_BUFFER } = require_constants2();
     var { isValidStatusCode } = require_validation();
     var { mask: applyMask, toBuffer } = require_buffer_util();
     var mask = Buffer.alloc(4);
     var Sender = class {
       constructor(socket, extensions) {
         this._extensions = extensions || {};
         this._socket = socket;
         this._firstFragment = true;
         this._compress = false;
         this._bufferedBytes = 0;
         this._deflating = false;
         this._queue = [];
       }
       static frame(data, options) {
         const merge = options.mask && options.readOnly;
         let offset = options.mask ? 6 : 2;
         let payloadLength = data.length;
         if (data.length >= 65536) {
           offset += 8;
           payloadLength = 127;
         } else if (data.length > 125) {
           offset += 2;
           payloadLength = 126;
         }
         const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
         target[0] = options.fin ? options.opcode | 128 : options.opcode;
         if (options.rsv1)
           target[0] |= 64;
         target[1] = payloadLength;
         if (payloadLength === 126) {
           target.writeUInt16BE(data.length, 2);
         } else if (payloadLength === 127) {
           target.writeUInt32BE(0, 2);
           target.writeUInt32BE(data.length, 6);
         }
         if (!options.mask)
           return [target, data];
         randomFillSync(mask, 0, 4);
         target[1] |= 128;
         target[offset - 4] = mask[0];
         target[offset - 3] = mask[1];
         target[offset - 2] = mask[2];
         target[offset - 1] = mask[3];
         if (merge) {
           applyMask(data, mask, target, offset, data.length);
           return [target];
         }
         applyMask(data, mask, data, 0, data.length);
         return [target, data];
       }
       close(code, data, mask2, cb) {
         let buf;
         if (code === void 0) {
           buf = EMPTY_BUFFER;
         } else if (typeof code !== "number" || !isValidStatusCode(code)) {
           throw new TypeError("First argument must be a valid error code number");
         } else if (data === void 0 || data === "") {
           buf = Buffer.allocUnsafe(2);
           buf.writeUInt16BE(code, 0);
         } else {
           const length = Buffer.byteLength(data);
           if (length > 123) {
             throw new RangeError("The message must not be greater than 123 bytes");
           }
           buf = Buffer.allocUnsafe(2 + length);
           buf.writeUInt16BE(code, 0);
           buf.write(data, 2);
         }
         if (this._deflating) {
           this.enqueue([this.doClose, buf, mask2, cb]);
         } else {
           this.doClose(buf, mask2, cb);
         }
       }
       doClose(data, mask2, cb) {
         this.sendFrame(
           Sender.frame(data, {
             fin: true,
             rsv1: false,
             opcode: 8,
             mask: mask2,
             readOnly: false
           }),
           cb
         );
       }
       ping(data, mask2, cb) {
         const buf = toBuffer(data);
         if (buf.length > 125) {
           throw new RangeError("The data size must not be greater than 125 bytes");
         }
         if (this._deflating) {
           this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
         } else {
           this.doPing(buf, mask2, toBuffer.readOnly, cb);
         }
       }
       doPing(data, mask2, readOnly, cb) {
         this.sendFrame(
           Sender.frame(data, {
             fin: true,
             rsv1: false,
             opcode: 9,
             mask: mask2,
             readOnly
           }),
           cb
         );
       }
       pong(data, mask2, cb) {
         const buf = toBuffer(data);
         if (buf.length > 125) {
           throw new RangeError("The data size must not be greater than 125 bytes");
         }
         if (this._deflating) {
           this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
         } else {
           this.doPong(buf, mask2, toBuffer.readOnly, cb);
         }
       }
       doPong(data, mask2, readOnly, cb) {
         this.sendFrame(
           Sender.frame(data, {
             fin: true,
             rsv1: false,
             opcode: 10,
             mask: mask2,
             readOnly
           }),
           cb
         );
       }
       send(data, options, cb) {
         const buf = toBuffer(data);
         const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
         let opcode = options.binary ? 2 : 1;
         let rsv1 = options.compress;
         if (this._firstFragment) {
           this._firstFragment = false;
           if (rsv1 && perMessageDeflate) {
             rsv1 = buf.length >= perMessageDeflate._threshold;
           }
           this._compress = rsv1;
         } else {
           rsv1 = false;
           opcode = 0;
         }
         if (options.fin)
           this._firstFragment = true;
         if (perMessageDeflate) {
           const opts = {
             fin: options.fin,
             rsv1,
             opcode,
             mask: options.mask,
             readOnly: toBuffer.readOnly
           };
           if (this._deflating) {
             this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
           } else {
             this.dispatch(buf, this._compress, opts, cb);
           }
         } else {
           this.sendFrame(
             Sender.frame(buf, {
               fin: options.fin,
               rsv1: false,
               opcode,
               mask: options.mask,
               readOnly: toBuffer.readOnly
             }),
             cb
           );
         }
       }
       dispatch(data, compress, options, cb) {
         if (!compress) {
           this.sendFrame(Sender.frame(data, options), cb);
           return;
         }
         const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
         this._bufferedBytes += data.length;
         this._deflating = true;
         perMessageDeflate.compress(data, options.fin, (_, buf) => {
           if (this._socket.destroyed) {
             const err = new Error(
               "The socket was closed while data was being compressed"
             );
             if (typeof cb === "function")
               cb(err);
             for (let i = 0; i < this._queue.length; i++) {
               const callback = this._queue[i][4];
               if (typeof callback === "function")
                 callback(err);
             }
             return;
           }
           this._bufferedBytes -= data.length;
           this._deflating = false;
           options.readOnly = false;
           this.sendFrame(Sender.frame(buf, options), cb);
           this.dequeue();
         });
       }
       dequeue() {
         while (!this._deflating && this._queue.length) {
           const params = this._queue.shift();
           this._bufferedBytes -= params[1].length;
           Reflect.apply(params[0], this, params.slice(1));
         }
       }
       enqueue(params) {
         this._bufferedBytes += params[1].length;
         this._queue.push(params);
       }
       sendFrame(list, cb) {
         if (list.length === 2) {
           this._socket.cork();
           this._socket.write(list[0]);
           this._socket.write(list[1], cb);
           this._socket.uncork();
         } else {
           this._socket.write(list[0], cb);
         }
       }
     };
     module2.exports = Sender;
   }
 });
 
 // node_modules/ws/lib/event-target.js
 var require_event_target = __commonJS({
   "node_modules/ws/lib/event-target.js"(exports, module2) {
     "use strict";
     var Event = class {
       constructor(type, target) {
         this.target = target;
         this.type = type;
       }
     };
     var MessageEvent = class extends Event {
       constructor(data, target) {
         super("message", target);
         this.data = data;
       }
     };
     var CloseEvent = class extends Event {
       constructor(code, reason, target) {
         super("close", target);
         this.wasClean = target._closeFrameReceived && target._closeFrameSent;
         this.reason = reason;
         this.code = code;
       }
     };
     var OpenEvent = class extends Event {
       constructor(target) {
         super("open", target);
       }
     };
     var ErrorEvent = class extends Event {
       constructor(error, target) {
         super("error", target);
         this.message = error.message;
         this.error = error;
       }
     };
     var EventTarget = {
       addEventListener(type, listener, options) {
         if (typeof listener !== "function")
           return;
         function onMessage(data) {
           listener.call(this, new MessageEvent(data, this));
         }
         function onClose(code, message) {
           listener.call(this, new CloseEvent(code, message, this));
         }
         function onError(error) {
           listener.call(this, new ErrorEvent(error, this));
         }
         function onOpen() {
           listener.call(this, new OpenEvent(this));
         }
         const method = options && options.once ? "once" : "on";
         if (type === "message") {
           onMessage._listener = listener;
           this[method](type, onMessage);
         } else if (type === "close") {
           onClose._listener = listener;
           this[method](type, onClose);
         } else if (type === "error") {
           onError._listener = listener;
           this[method](type, onError);
         } else if (type === "open") {
           onOpen._listener = listener;
           this[method](type, onOpen);
         } else {
           this[method](type, listener);
         }
       },
       removeEventListener(type, listener) {
         const listeners = this.listeners(type);
         for (let i = 0; i < listeners.length; i++) {
           if (listeners[i] === listener || listeners[i]._listener === listener) {
             this.removeListener(type, listeners[i]);
           }
         }
       }
     };
     module2.exports = EventTarget;
   }
 });
 
 // node_modules/ws/lib/extension.js
 var require_extension = __commonJS({
   "node_modules/ws/lib/extension.js"(exports, module2) {
     "use strict";
     var tokenChars = [
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       1,
       0,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       1,
       1,
       0,
       1,
       1,
       0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       1,
       0,
       1,
       0
     ];
     function push(dest, name, elem) {
       if (dest[name] === void 0)
         dest[name] = [elem];
       else
         dest[name].push(elem);
     }
     function parse(header) {
       const offers = /* @__PURE__ */ Object.create(null);
       if (header === void 0 || header === "")
         return offers;
       let params = /* @__PURE__ */ Object.create(null);
       let mustUnescape = false;
       let isEscaping = false;
       let inQuotes = false;
       let extensionName;
       let paramName;
       let start = -1;
       let end = -1;
       let i = 0;
       for (; i < header.length; i++) {
         const code = header.charCodeAt(i);
         if (extensionName === void 0) {
           if (end === -1 && tokenChars[code] === 1) {
             if (start === -1)
               start = i;
           } else if (code === 32 || code === 9) {
             if (end === -1 && start !== -1)
               end = i;
           } else if (code === 59 || code === 44) {
             if (start === -1) {
               throw new SyntaxError(`Unexpected character at index ${i}`);
             }
             if (end === -1)
               end = i;
             const name = header.slice(start, end);
             if (code === 44) {
               push(offers, name, params);
               params = /* @__PURE__ */ Object.create(null);
             } else {
               extensionName = name;
             }
             start = end = -1;
           } else {
             throw new SyntaxError(`Unexpected character at index ${i}`);
           }
         } else if (paramName === void 0) {
           if (end === -1 && tokenChars[code] === 1) {
             if (start === -1)
               start = i;
           } else if (code === 32 || code === 9) {
             if (end === -1 && start !== -1)
               end = i;
           } else if (code === 59 || code === 44) {
             if (start === -1) {
               throw new SyntaxError(`Unexpected character at index ${i}`);
             }
             if (end === -1)
               end = i;
             push(params, header.slice(start, end), true);
             if (code === 44) {
               push(offers, extensionName, params);
               params = /* @__PURE__ */ Object.create(null);
               extensionName = void 0;
             }
             start = end = -1;
           } else if (code === 61 && start !== -1 && end === -1) {
             paramName = header.slice(start, i);
             start = end = -1;
           } else {
             throw new SyntaxError(`Unexpected character at index ${i}`);
           }
         } else {
           if (isEscaping) {
             if (tokenChars[code] !== 1) {
               throw new SyntaxError(`Unexpected character at index ${i}`);
             }
             if (start === -1)
               start = i;
             else if (!mustUnescape)
               mustUnescape = true;
             isEscaping = false;
           } else if (inQuotes) {
             if (tokenChars[code] === 1) {
               if (start === -1)
                 start = i;
             } else if (code === 34 && start !== -1) {
               inQuotes = false;
               end = i;
             } else if (code === 92) {
               isEscaping = true;
             } else {
               throw new SyntaxError(`Unexpected character at index ${i}`);
             }
           } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
             inQuotes = true;
           } else if (end === -1 && tokenChars[code] === 1) {
             if (start === -1)
               start = i;
           } else if (start !== -1 && (code === 32 || code === 9)) {
             if (end === -1)
               end = i;
           } else if (code === 59 || code === 44) {
             if (start === -1) {
               throw new SyntaxError(`Unexpected character at index ${i}`);
             }
             if (end === -1)
               end = i;
             let value = header.slice(start, end);
             if (mustUnescape) {
               value = value.replace(/\\/g, "");
               mustUnescape = false;
             }
             push(params, paramName, value);
             if (code === 44) {
               push(offers, extensionName, params);
               params = /* @__PURE__ */ Object.create(null);
               extensionName = void 0;
             }
             paramName = void 0;
             start = end = -1;
           } else {
             throw new SyntaxError(`Unexpected character at index ${i}`);
           }
         }
       }
       if (start === -1 || inQuotes) {
         throw new SyntaxError("Unexpected end of input");
       }
       if (end === -1)
         end = i;
       const token = header.slice(start, end);
       if (extensionName === void 0) {
         push(offers, token, params);
       } else {
         if (paramName === void 0) {
           push(params, token, true);
         } else if (mustUnescape) {
           push(params, paramName, token.replace(/\\/g, ""));
         } else {
           push(params, paramName, token);
         }
         push(offers, extensionName, params);
       }
       return offers;
     }
     function format(extensions) {
       return Object.keys(extensions).map((extension) => {
         let configurations = extensions[extension];
         if (!Array.isArray(configurations))
           configurations = [configurations];
         return configurations.map((params) => {
           return [extension].concat(
             Object.keys(params).map((k) => {
               let values = params[k];
               if (!Array.isArray(values))
                 values = [values];
               return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
             })
           ).join("; ");
         }).join(", ");
       }).join(", ");
     }
     module2.exports = { format, parse };
   }
 });
 
 // node_modules/ws/lib/websocket.js
 var require_websocket = __commonJS({
   "node_modules/ws/lib/websocket.js"(exports, module2) {
     "use strict";
     var EventEmitter = require("events");
     var https = require("https");
     var http = require("http");
     var net = require("net");
     var tls = require("tls");
     var { randomBytes, createHash } = require("crypto");
     var { Readable } = require("stream");
     var { URL: URL2 } = require("url");
     var PerMessageDeflate = require_permessage_deflate();
     var Receiver = require_receiver();
     var Sender = require_sender();
     var {
       BINARY_TYPES,
       EMPTY_BUFFER,
       GUID,
       kStatusCode,
       kWebSocket,
       NOOP
     } = require_constants2();
     var { addEventListener, removeEventListener } = require_event_target();
     var { format, parse } = require_extension();
     var { toBuffer } = require_buffer_util();
     var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
     var protocolVersions = [8, 13];
     var closeTimeout = 30 * 1e3;
     var WebSocket2 = class extends EventEmitter {
       constructor(address, protocols, options) {
         super();
         this._binaryType = BINARY_TYPES[0];
         this._closeCode = 1006;
         this._closeFrameReceived = false;
         this._closeFrameSent = false;
         this._closeMessage = "";
         this._closeTimer = null;
         this._extensions = {};
         this._protocol = "";
         this._readyState = WebSocket2.CONNECTING;
         this._receiver = null;
         this._sender = null;
         this._socket = null;
         if (address !== null) {
           this._bufferedAmount = 0;
           this._isServer = false;
           this._redirects = 0;
           if (Array.isArray(protocols)) {
             protocols = protocols.join(", ");
           } else if (typeof protocols === "object" && protocols !== null) {
             options = protocols;
             protocols = void 0;
           }
           initAsClient(this, address, protocols, options);
         } else {
           this._isServer = true;
         }
       }
       get binaryType() {
         return this._binaryType;
       }
       set binaryType(type) {
         if (!BINARY_TYPES.includes(type))
           return;
         this._binaryType = type;
         if (this._receiver)
           this._receiver._binaryType = type;
       }
       get bufferedAmount() {
         if (!this._socket)
           return this._bufferedAmount;
         return this._socket._writableState.length + this._sender._bufferedBytes;
       }
       get extensions() {
         return Object.keys(this._extensions).join();
       }
       get onclose() {
         return void 0;
       }
       set onclose(listener) {
       }
       get onerror() {
         return void 0;
       }
       set onerror(listener) {
       }
       get onopen() {
         return void 0;
       }
       set onopen(listener) {
       }
       get onmessage() {
         return void 0;
       }
       set onmessage(listener) {
       }
       get protocol() {
         return this._protocol;
       }
       get readyState() {
         return this._readyState;
       }
       get url() {
         return this._url;
       }
       setSocket(socket, head, maxPayload) {
         const receiver = new Receiver(
           this.binaryType,
           this._extensions,
           this._isServer,
           maxPayload
         );
         this._sender = new Sender(socket, this._extensions);
         this._receiver = receiver;
         this._socket = socket;
         receiver[kWebSocket] = this;
         socket[kWebSocket] = this;
         receiver.on("conclude", receiverOnConclude);
         receiver.on("drain", receiverOnDrain);
         receiver.on("error", receiverOnError);
         receiver.on("message", receiverOnMessage);
         receiver.on("ping", receiverOnPing);
         receiver.on("pong", receiverOnPong);
         socket.setTimeout(0);
         socket.setNoDelay();
         if (head.length > 0)
           socket.unshift(head);
         socket.on("close", socketOnClose);
         socket.on("data", socketOnData);
         socket.on("end", socketOnEnd);
         socket.on("error", socketOnError);
         this._readyState = WebSocket2.OPEN;
         this.emit("open");
       }
       emitClose() {
         if (!this._socket) {
           this._readyState = WebSocket2.CLOSED;
           this.emit("close", this._closeCode, this._closeMessage);
           return;
         }
         if (this._extensions[PerMessageDeflate.extensionName]) {
           this._extensions[PerMessageDeflate.extensionName].cleanup();
         }
         this._receiver.removeAllListeners();
         this._readyState = WebSocket2.CLOSED;
         this.emit("close", this._closeCode, this._closeMessage);
       }
       close(code, data) {
         if (this.readyState === WebSocket2.CLOSED)
           return;
         if (this.readyState === WebSocket2.CONNECTING) {
           const msg = "WebSocket was closed before the connection was established";
           return abortHandshake(this, this._req, msg);
         }
         if (this.readyState === WebSocket2.CLOSING) {
           if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
             this._socket.end();
           }
           return;
         }
         this._readyState = WebSocket2.CLOSING;
         this._sender.close(code, data, !this._isServer, (err) => {
           if (err)
             return;
           this._closeFrameSent = true;
           if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
             this._socket.end();
           }
         });
         this._closeTimer = setTimeout(
           this._socket.destroy.bind(this._socket),
           closeTimeout
         );
       }
       ping(data, mask, cb) {
         if (this.readyState === WebSocket2.CONNECTING) {
           throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
         }
         if (typeof data === "function") {
           cb = data;
           data = mask = void 0;
         } else if (typeof mask === "function") {
           cb = mask;
           mask = void 0;
         }
         if (typeof data === "number")
           data = data.toString();
         if (this.readyState !== WebSocket2.OPEN) {
           sendAfterClose(this, data, cb);
           return;
         }
         if (mask === void 0)
           mask = !this._isServer;
         this._sender.ping(data || EMPTY_BUFFER, mask, cb);
       }
       pong(data, mask, cb) {
         if (this.readyState === WebSocket2.CONNECTING) {
           throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
         }
         if (typeof data === "function") {
           cb = data;
           data = mask = void 0;
         } else if (typeof mask === "function") {
           cb = mask;
           mask = void 0;
         }
         if (typeof data === "number")
           data = data.toString();
         if (this.readyState !== WebSocket2.OPEN) {
           sendAfterClose(this, data, cb);
           return;
         }
         if (mask === void 0)
           mask = !this._isServer;
         this._sender.pong(data || EMPTY_BUFFER, mask, cb);
       }
       send(data, options, cb) {
         if (this.readyState === WebSocket2.CONNECTING) {
           throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
         }
         if (typeof options === "function") {
           cb = options;
           options = {};
         }
         if (typeof data === "number")
           data = data.toString();
         if (this.readyState !== WebSocket2.OPEN) {
           sendAfterClose(this, data, cb);
           return;
         }
         const opts = {
           binary: typeof data !== "string",
           mask: !this._isServer,
           compress: true,
           fin: true,
           ...options
         };
         if (!this._extensions[PerMessageDeflate.extensionName]) {
           opts.compress = false;
         }
         this._sender.send(data || EMPTY_BUFFER, opts, cb);
       }
       terminate() {
         if (this.readyState === WebSocket2.CLOSED)
           return;
         if (this.readyState === WebSocket2.CONNECTING) {
           const msg = "WebSocket was closed before the connection was established";
           return abortHandshake(this, this._req, msg);
         }
         if (this._socket) {
           this._readyState = WebSocket2.CLOSING;
           this._socket.destroy();
         }
       }
     };
     Object.defineProperty(WebSocket2, "CONNECTING", {
       enumerable: true,
       value: readyStates.indexOf("CONNECTING")
     });
     Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
       enumerable: true,
       value: readyStates.indexOf("CONNECTING")
     });
     Object.defineProperty(WebSocket2, "OPEN", {
       enumerable: true,
       value: readyStates.indexOf("OPEN")
     });
     Object.defineProperty(WebSocket2.prototype, "OPEN", {
       enumerable: true,
       value: readyStates.indexOf("OPEN")
     });
     Object.defineProperty(WebSocket2, "CLOSING", {
       enumerable: true,
       value: readyStates.indexOf("CLOSING")
     });
     Object.defineProperty(WebSocket2.prototype, "CLOSING", {
       enumerable: true,
       value: readyStates.indexOf("CLOSING")
     });
     Object.defineProperty(WebSocket2, "CLOSED", {
       enumerable: true,
       value: readyStates.indexOf("CLOSED")
     });
     Object.defineProperty(WebSocket2.prototype, "CLOSED", {
       enumerable: true,
       value: readyStates.indexOf("CLOSED")
     });
     [
       "binaryType",
       "bufferedAmount",
       "extensions",
       "protocol",
       "readyState",
       "url"
     ].forEach((property) => {
       Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
     });
     ["open", "error", "close", "message"].forEach((method) => {
       Object.defineProperty(WebSocket2.prototype, `on${method}`, {
         enumerable: true,
         get() {
           const listeners = this.listeners(method);
           for (let i = 0; i < listeners.length; i++) {
             if (listeners[i]._listener)
               return listeners[i]._listener;
           }
           return void 0;
         },
         set(listener) {
           const listeners = this.listeners(method);
           for (let i = 0; i < listeners.length; i++) {
             if (listeners[i]._listener)
               this.removeListener(method, listeners[i]);
           }
           this.addEventListener(method, listener);
         }
       });
     });
     WebSocket2.prototype.addEventListener = addEventListener;
     WebSocket2.prototype.removeEventListener = removeEventListener;
     module2.exports = WebSocket2;
     function initAsClient(websocket, address, protocols, options) {
       const opts = {
         protocolVersion: protocolVersions[1],
         maxPayload: 100 * 1024 * 1024,
         perMessageDeflate: true,
         followRedirects: false,
         maxRedirects: 10,
         ...options,
         createConnection: void 0,
         socketPath: void 0,
         hostname: void 0,
         protocol: void 0,
         timeout: void 0,
         method: void 0,
         host: void 0,
         path: void 0,
         port: void 0
       };
       if (!protocolVersions.includes(opts.protocolVersion)) {
         throw new RangeError(
           `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
         );
       }
       let parsedUrl;
       if (address instanceof URL2) {
         parsedUrl = address;
         websocket._url = address.href;
       } else {
         parsedUrl = new URL2(address);
         websocket._url = address;
       }
       const isUnixSocket = parsedUrl.protocol === "ws+unix:";
       if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
         const err = new Error(`Invalid URL: ${websocket.url}`);
         if (websocket._redirects === 0) {
           throw err;
         } else {
           emitErrorAndClose(websocket, err);
           return;
         }
       }
       const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
       const defaultPort = isSecure ? 443 : 80;
       const key = randomBytes(16).toString("base64");
       const get = isSecure ? https.get : http.get;
       let perMessageDeflate;
       opts.createConnection = isSecure ? tlsConnect : netConnect;
       opts.defaultPort = opts.defaultPort || defaultPort;
       opts.port = parsedUrl.port || defaultPort;
       opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
       opts.headers = {
         "Sec-WebSocket-Version": opts.protocolVersion,
         "Sec-WebSocket-Key": key,
         Connection: "Upgrade",
         Upgrade: "websocket",
         ...opts.headers
       };
       opts.path = parsedUrl.pathname + parsedUrl.search;
       opts.timeout = opts.handshakeTimeout;
       if (opts.perMessageDeflate) {
         perMessageDeflate = new PerMessageDeflate(
           opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
           false,
           opts.maxPayload
         );
         opts.headers["Sec-WebSocket-Extensions"] = format({
           [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
         });
       }
       if (protocols) {
         opts.headers["Sec-WebSocket-Protocol"] = protocols;
       }
       if (opts.origin) {
         if (opts.protocolVersion < 13) {
           opts.headers["Sec-WebSocket-Origin"] = opts.origin;
         } else {
           opts.headers.Origin = opts.origin;
         }
       }
       if (parsedUrl.username || parsedUrl.password) {
         opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
       }
       if (isUnixSocket) {
         const parts = opts.path.split(":");
         opts.socketPath = parts[0];
         opts.path = parts[1];
       }
       if (opts.followRedirects) {
         if (websocket._redirects === 0) {
           websocket._originalUnixSocket = isUnixSocket;
           websocket._originalSecure = isSecure;
           websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
           const headers = options && options.headers;
           options = { ...options, headers: {} };
           if (headers) {
             for (const [key2, value] of Object.entries(headers)) {
               options.headers[key2.toLowerCase()] = value;
             }
           }
         } else {
           const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
           if (!isSameHost || websocket._originalSecure && !isSecure) {
             delete opts.headers.authorization;
             delete opts.headers.cookie;
             if (!isSameHost)
               delete opts.headers.host;
             opts.auth = void 0;
           }
         }
         if (opts.auth && !options.headers.authorization) {
           options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
         }
       }
       let req = websocket._req = get(opts);
       if (opts.timeout) {
         req.on("timeout", () => {
           abortHandshake(websocket, req, "Opening handshake has timed out");
         });
       }
       req.on("error", (err) => {
         if (req === null || req.aborted)
           return;
         req = websocket._req = null;
         emitErrorAndClose(websocket, err);
       });
       req.on("response", (res) => {
         const location = res.headers.location;
         const statusCode = res.statusCode;
         if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
           if (++websocket._redirects > opts.maxRedirects) {
             abortHandshake(websocket, req, "Maximum redirects exceeded");
             return;
           }
           req.abort();
           let addr;
           try {
             addr = new URL2(location, address);
           } catch (err) {
             emitErrorAndClose(websocket, err);
             return;
           }
           initAsClient(websocket, addr, protocols, options);
         } else if (!websocket.emit("unexpected-response", req, res)) {
           abortHandshake(
             websocket,
             req,
             `Unexpected server response: ${res.statusCode}`
           );
         }
       });
       req.on("upgrade", (res, socket, head) => {
         websocket.emit("upgrade", res);
         if (websocket.readyState !== WebSocket2.CONNECTING)
           return;
         req = websocket._req = null;
         if (res.headers.upgrade.toLowerCase() !== "websocket") {
           abortHandshake(websocket, socket, "Invalid Upgrade header");
           return;
         }
         const digest = createHash("sha1").update(key + GUID).digest("base64");
         if (res.headers["sec-websocket-accept"] !== digest) {
           abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
           return;
         }
         const serverProt = res.headers["sec-websocket-protocol"];
         const protList = (protocols || "").split(/, */);
         let protError;
         if (!protocols && serverProt) {
           protError = "Server sent a subprotocol but none was requested";
         } else if (protocols && !serverProt) {
           protError = "Server sent no subprotocol";
         } else if (serverProt && !protList.includes(serverProt)) {
           protError = "Server sent an invalid subprotocol";
         }
         if (protError) {
           abortHandshake(websocket, socket, protError);
           return;
         }
         if (serverProt)
           websocket._protocol = serverProt;
         const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
         if (secWebSocketExtensions !== void 0) {
           if (!perMessageDeflate) {
             const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
             abortHandshake(websocket, socket, message);
             return;
           }
           let extensions;
           try {
             extensions = parse(secWebSocketExtensions);
           } catch (err) {
             const message = "Invalid Sec-WebSocket-Extensions header";
             abortHandshake(websocket, socket, message);
             return;
           }
           const extensionNames = Object.keys(extensions);
           if (extensionNames.length) {
             if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
               const message = "Server indicated an extension that was not requested";
               abortHandshake(websocket, socket, message);
               return;
             }
             try {
               perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
             } catch (err) {
               const message = "Invalid Sec-WebSocket-Extensions header";
               abortHandshake(websocket, socket, message);
               return;
             }
             websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
           }
         }
         websocket.setSocket(socket, head, opts.maxPayload);
       });
     }
     function emitErrorAndClose(websocket, err) {
       websocket._readyState = WebSocket2.CLOSING;
       websocket.emit("error", err);
       websocket.emitClose();
     }
     function netConnect(options) {
       options.path = options.socketPath;
       return net.connect(options);
     }
     function tlsConnect(options) {
       options.path = void 0;
       if (!options.servername && options.servername !== "") {
         options.servername = net.isIP(options.host) ? "" : options.host;
       }
       return tls.connect(options);
     }
     function abortHandshake(websocket, stream, message) {
       websocket._readyState = WebSocket2.CLOSING;
       const err = new Error(message);
       Error.captureStackTrace(err, abortHandshake);
       if (stream.setHeader) {
         stream.abort();
         if (stream.socket && !stream.socket.destroyed) {
           stream.socket.destroy();
         }
         stream.once("abort", websocket.emitClose.bind(websocket));
         websocket.emit("error", err);
       } else {
         stream.destroy(err);
         stream.once("error", websocket.emit.bind(websocket, "error"));
         stream.once("close", websocket.emitClose.bind(websocket));
       }
     }
     function sendAfterClose(websocket, data, cb) {
       if (data) {
         const length = toBuffer(data).length;
         if (websocket._socket)
           websocket._sender._bufferedBytes += length;
         else
           websocket._bufferedAmount += length;
       }
       if (cb) {
         const err = new Error(
           `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
         );
         cb(err);
       }
     }
     function receiverOnConclude(code, reason) {
       const websocket = this[kWebSocket];
       websocket._closeFrameReceived = true;
       websocket._closeMessage = reason;
       websocket._closeCode = code;
       if (websocket._socket[kWebSocket] === void 0)
         return;
       websocket._socket.removeListener("data", socketOnData);
       process.nextTick(resume, websocket._socket);
       if (code === 1005)
         websocket.close();
       else
         websocket.close(code, reason);
     }
     function receiverOnDrain() {
       this[kWebSocket]._socket.resume();
     }
     function receiverOnError(err) {
       const websocket = this[kWebSocket];
       if (websocket._socket[kWebSocket] !== void 0) {
         websocket._socket.removeListener("data", socketOnData);
         process.nextTick(resume, websocket._socket);
         websocket.close(err[kStatusCode]);
       }
       websocket.emit("error", err);
     }
     function receiverOnFinish() {
       this[kWebSocket].emitClose();
     }
     function receiverOnMessage(data) {
       this[kWebSocket].emit("message", data);
     }
     function receiverOnPing(data) {
       const websocket = this[kWebSocket];
       websocket.pong(data, !websocket._isServer, NOOP);
       websocket.emit("ping", data);
     }
     function receiverOnPong(data) {
       this[kWebSocket].emit("pong", data);
     }
     function resume(stream) {
       stream.resume();
     }
     function socketOnClose() {
       const websocket = this[kWebSocket];
       this.removeListener("close", socketOnClose);
       this.removeListener("data", socketOnData);
       this.removeListener("end", socketOnEnd);
       websocket._readyState = WebSocket2.CLOSING;
       let chunk;
       if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
         websocket._receiver.write(chunk);
       }
       websocket._receiver.end();
       this[kWebSocket] = void 0;
       clearTimeout(websocket._closeTimer);
       if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
         websocket.emitClose();
       } else {
         websocket._receiver.on("error", receiverOnFinish);
         websocket._receiver.on("finish", receiverOnFinish);
       }
     }
     function socketOnData(chunk) {
       if (!this[kWebSocket]._receiver.write(chunk)) {
         this.pause();
       }
     }
     function socketOnEnd() {
       const websocket = this[kWebSocket];
       websocket._readyState = WebSocket2.CLOSING;
       websocket._receiver.end();
       this.end();
     }
     function socketOnError() {
       const websocket = this[kWebSocket];
       this.removeListener("error", socketOnError);
       this.on("error", NOOP);
       if (websocket) {
         websocket._readyState = WebSocket2.CLOSING;
         this.destroy();
       }
     }
   }
 });
 
 // node_modules/ws/lib/stream.js
 var require_stream2 = __commonJS({
   "node_modules/ws/lib/stream.js"(exports, module2) {
     "use strict";
     var { Duplex } = require("stream");
     function emitClose(stream) {
       stream.emit("close");
     }
     function duplexOnEnd() {
       if (!this.destroyed && this._writableState.finished) {
         this.destroy();
       }
     }
     function duplexOnError(err) {
       this.removeListener("error", duplexOnError);
       this.destroy();
       if (this.listenerCount("error") === 0) {
         this.emit("error", err);
       }
     }
     function createWebSocketStream(ws, options) {
       let resumeOnReceiverDrain = true;
       let terminateOnDestroy = true;
       function receiverOnDrain() {
         if (resumeOnReceiverDrain)
           ws._socket.resume();
       }
       if (ws.readyState === ws.CONNECTING) {
         ws.once("open", function open() {
           ws._receiver.removeAllListeners("drain");
           ws._receiver.on("drain", receiverOnDrain);
         });
       } else {
         ws._receiver.removeAllListeners("drain");
         ws._receiver.on("drain", receiverOnDrain);
       }
       const duplex = new Duplex({
         ...options,
         autoDestroy: false,
         emitClose: false,
         objectMode: false,
         writableObjectMode: false
       });
       ws.on("message", function message(msg) {
         if (!duplex.push(msg)) {
           resumeOnReceiverDrain = false;
           ws._socket.pause();
         }
       });
       ws.once("error", function error(err) {
         if (duplex.destroyed)
           return;
         terminateOnDestroy = false;
         duplex.destroy(err);
       });
       ws.once("close", function close() {
         if (duplex.destroyed)
           return;
         duplex.push(null);
       });
       duplex._destroy = function(err, callback) {
         if (ws.readyState === ws.CLOSED) {
           callback(err);
           process.nextTick(emitClose, duplex);
           return;
         }
         let called = false;
         ws.once("error", function error(err2) {
           called = true;
           callback(err2);
         });
         ws.once("close", function close() {
           if (!called)
             callback(err);
           process.nextTick(emitClose, duplex);
         });
         if (terminateOnDestroy)
           ws.terminate();
       };
       duplex._final = function(callback) {
         if (ws.readyState === ws.CONNECTING) {
           ws.once("open", function open() {
             duplex._final(callback);
           });
           return;
         }
         if (ws._socket === null)
           return;
         if (ws._socket._writableState.finished) {
           callback();
           if (duplex._readableState.endEmitted)
             duplex.destroy();
         } else {
           ws._socket.once("finish", function finish() {
             callback();
           });
           ws.close();
         }
       };
       duplex._read = function() {
         if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
           resumeOnReceiverDrain = true;
           if (!ws._receiver._writableState.needDrain)
             ws._socket.resume();
         }
       };
       duplex._write = function(chunk, encoding, callback) {
         if (ws.readyState === ws.CONNECTING) {
           ws.once("open", function open() {
             duplex._write(chunk, encoding, callback);
           });
           return;
         }
         ws.send(chunk, callback);
       };
       duplex.on("end", duplexOnEnd);
       duplex.on("error", duplexOnError);
       return duplex;
     }
     module2.exports = createWebSocketStream;
   }
 });
 
 // node_modules/ws/lib/websocket-server.js
 var require_websocket_server = __commonJS({
   "node_modules/ws/lib/websocket-server.js"(exports, module2) {
     "use strict";
     var EventEmitter = require("events");
     var http = require("http");
     var https = require("https");
     var net = require("net");
     var tls = require("tls");
     var { createHash } = require("crypto");
     var PerMessageDeflate = require_permessage_deflate();
     var WebSocket2 = require_websocket();
     var { format, parse } = require_extension();
     var { GUID, kWebSocket } = require_constants2();
     var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
     var RUNNING = 0;
     var CLOSING = 1;
     var CLOSED = 2;
     var WebSocketServer = class extends EventEmitter {
       constructor(options, callback) {
         super();
         options = {
           maxPayload: 100 * 1024 * 1024,
           perMessageDeflate: false,
           handleProtocols: null,
           clientTracking: true,
           verifyClient: null,
           noServer: false,
           backlog: null,
           server: null,
           host: null,
           path: null,
           port: null,
           ...options
         };
         if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
           throw new TypeError(
             'One and only one of the "port", "server", or "noServer" options must be specified'
           );
         }
         if (options.port != null) {
           this._server = http.createServer((req, res) => {
             const body = http.STATUS_CODES[426];
             res.writeHead(426, {
               "Content-Length": body.length,
               "Content-Type": "text/plain"
             });
             res.end(body);
           });
           this._server.listen(
             options.port,
             options.host,
             options.backlog,
             callback
           );
         } else if (options.server) {
           this._server = options.server;
         }
         if (this._server) {
           const emitConnection = this.emit.bind(this, "connection");
           this._removeListeners = addListeners(this._server, {
             listening: this.emit.bind(this, "listening"),
             error: this.emit.bind(this, "error"),
             upgrade: (req, socket, head) => {
               this.handleUpgrade(req, socket, head, emitConnection);
             }
           });
         }
         if (options.perMessageDeflate === true)
           options.perMessageDeflate = {};
         if (options.clientTracking)
           this.clients = /* @__PURE__ */ new Set();
         this.options = options;
         this._state = RUNNING;
       }
       address() {
         if (this.options.noServer) {
           throw new Error('The server is operating in "noServer" mode');
         }
         if (!this._server)
           return null;
         return this._server.address();
       }
       close(cb) {
         if (cb)
           this.once("close", cb);
         if (this._state === CLOSED) {
           process.nextTick(emitClose, this);
           return;
         }
         if (this._state === CLOSING)
           return;
         this._state = CLOSING;
         if (this.clients) {
           for (const client of this.clients)
             client.terminate();
         }
         const server = this._server;
         if (server) {
           this._removeListeners();
           this._removeListeners = this._server = null;
           if (this.options.port != null) {
             server.close(emitClose.bind(void 0, this));
             return;
           }
         }
         process.nextTick(emitClose, this);
       }
       shouldHandle(req) {
         if (this.options.path) {
           const index = req.url.indexOf("?");
           const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
           if (pathname !== this.options.path)
             return false;
         }
         return true;
       }
       handleUpgrade(req, socket, head, cb) {
         socket.on("error", socketOnError);
         const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
         const version = +req.headers["sec-websocket-version"];
         const extensions = {};
         if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
           return abortHandshake(socket, 400);
         }
         if (this.options.perMessageDeflate) {
           const perMessageDeflate = new PerMessageDeflate(
             this.options.perMessageDeflate,
             true,
             this.options.maxPayload
           );
           try {
             const offers = parse(req.headers["sec-websocket-extensions"]);
             if (offers[PerMessageDeflate.extensionName]) {
               perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
               extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
             }
           } catch (err) {
             return abortHandshake(socket, 400);
           }
         }
         if (this.options.verifyClient) {
           const info = {
             origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
             secure: !!(req.socket.authorized || req.socket.encrypted),
             req
           };
           if (this.options.verifyClient.length === 2) {
             this.options.verifyClient(info, (verified, code, message, headers) => {
               if (!verified) {
                 return abortHandshake(socket, code || 401, message, headers);
               }
               this.completeUpgrade(key, extensions, req, socket, head, cb);
             });
             return;
           }
           if (!this.options.verifyClient(info))
             return abortHandshake(socket, 401);
         }
         this.completeUpgrade(key, extensions, req, socket, head, cb);
       }
       completeUpgrade(key, extensions, req, socket, head, cb) {
         if (!socket.readable || !socket.writable)
           return socket.destroy();
         if (socket[kWebSocket]) {
           throw new Error(
             "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
           );
         }
         if (this._state > RUNNING)
           return abortHandshake(socket, 503);
         const digest = createHash("sha1").update(key + GUID).digest("base64");
         const headers = [
           "HTTP/1.1 101 Switching Protocols",
           "Upgrade: websocket",
           "Connection: Upgrade",
           `Sec-WebSocket-Accept: ${digest}`
         ];
         const ws = new WebSocket2(null);
         let protocol = req.headers["sec-websocket-protocol"];
         if (protocol) {
           protocol = protocol.split(",").map(trim);
           if (this.options.handleProtocols) {
             protocol = this.options.handleProtocols(protocol, req);
           } else {
             protocol = protocol[0];
           }
           if (protocol) {
             headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
             ws._protocol = protocol;
           }
         }
         if (extensions[PerMessageDeflate.extensionName]) {
           const params = extensions[PerMessageDeflate.extensionName].params;
           const value = format({
             [PerMessageDeflate.extensionName]: [params]
           });
           headers.push(`Sec-WebSocket-Extensions: ${value}`);
           ws._extensions = extensions;
         }
         this.emit("headers", headers, req);
         socket.write(headers.concat("\r\n").join("\r\n"));
         socket.removeListener("error", socketOnError);
         ws.setSocket(socket, head, this.options.maxPayload);
         if (this.clients) {
           this.clients.add(ws);
           ws.on("close", () => this.clients.delete(ws));
         }
         cb(ws, req);
       }
     };
     module2.exports = WebSocketServer;
     function addListeners(server, map) {
       for (const event of Object.keys(map))
         server.on(event, map[event]);
       return function removeListeners() {
         for (const event of Object.keys(map)) {
           server.removeListener(event, map[event]);
         }
       };
     }
     function emitClose(server) {
       server._state = CLOSED;
       server.emit("close");
     }
     function socketOnError() {
       this.destroy();
     }
     function abortHandshake(socket, code, message, headers) {
       if (socket.writable) {
         message = message || http.STATUS_CODES[code];
         headers = {
           Connection: "close",
           "Content-Type": "text/html",
           "Content-Length": Buffer.byteLength(message),
           ...headers
         };
         socket.write(
           `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
 ` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
         );
       }
       socket.removeListener("error", socketOnError);
       socket.destroy();
     }
     function trim(str) {
       return str.trim();
     }
   }
 });
 
 // node_modules/ws/index.js
 var require_ws = __commonJS({
   "node_modules/ws/index.js"(exports, module2) {
     "use strict";
     var WebSocket2 = require_websocket();
     WebSocket2.createWebSocketStream = require_stream2();
     WebSocket2.Server = require_websocket_server();
     WebSocket2.Receiver = require_receiver();
     WebSocket2.Sender = require_sender();
     module2.exports = WebSocket2;
   }
 });
 
 // node_modules/simple-websocket/index.js
 var require_simple_websocket = __commonJS({
   "node_modules/simple-websocket/index.js"(exports, module2) {
     var debug = require_src()("simple-websocket");
     var randombytes2 = require_randombytes();
     var stream = require_readable();
     var queueMicrotask3 = require_queue_microtask();
     var ws = require_ws();
     var _WebSocket = typeof ws !== "function" ? WebSocket : ws;
     var MAX_BUFFERED_AMOUNT = 64 * 1024;
     var Socket = class extends stream.Duplex {
       constructor(opts = {}) {
         if (typeof opts === "string") {
           opts = { url: opts };
         }
         opts = Object.assign({
           allowHalfOpen: false
         }, opts);
         super(opts);
         if (opts.url == null && opts.socket == null) {
           throw new Error("Missing required `url` or `socket` option");
         }
         if (opts.url != null && opts.socket != null) {
           throw new Error("Must specify either `url` or `socket` option, not both");
         }
         this._id = randombytes2(4).toString("hex").slice(0, 7);
         this._debug("new websocket: %o", opts);
         this.connected = false;
         this.destroyed = false;
         this._chunk = null;
         this._cb = null;
         this._interval = null;
         if (opts.socket) {
           this.url = opts.socket.url;
           this._ws = opts.socket;
           this.connected = opts.socket.readyState === _WebSocket.OPEN;
         } else {
           this.url = opts.url;
           try {
             if (typeof ws === "function") {
               this._ws = new _WebSocket(opts.url, null, {
                 ...opts,
                 encoding: void 0
               });
             } else {
               this._ws = new _WebSocket(opts.url);
             }
           } catch (err) {
             queueMicrotask3(() => this.destroy(err));
             return;
           }
         }
         this._ws.binaryType = "arraybuffer";
         if (opts.socket && this.connected) {
           queueMicrotask3(() => this._handleOpen());
         } else {
           this._ws.onopen = () => this._handleOpen();
         }
         this._ws.onmessage = (event) => this._handleMessage(event);
         this._ws.onclose = () => this._handleClose();
         this._ws.onerror = (err) => this._handleError(err);
         this._handleFinishBound = () => this._handleFinish();
         this.once("finish", this._handleFinishBound);
       }
       send(chunk) {
         this._ws.send(chunk);
       }
       destroy(err) {
         this._destroy(err, () => {
         });
       }
       _destroy(err, cb) {
         if (this.destroyed)
           return;
         this._debug("destroy (error: %s)", err && (err.message || err));
         this.readable = this.writable = false;
         if (!this._readableState.ended)
           this.push(null);
         if (!this._writableState.finished)
           this.end();
         this.connected = false;
         this.destroyed = true;
         clearInterval(this._interval);
         this._interval = null;
         this._chunk = null;
         this._cb = null;
         if (this._handleFinishBound) {
           this.removeListener("finish", this._handleFinishBound);
         }
         this._handleFinishBound = null;
         if (this._ws) {
           const ws2 = this._ws;
           const onClose = () => {
             ws2.onclose = null;
           };
           if (ws2.readyState === _WebSocket.CLOSED) {
             onClose();
           } else {
             try {
               ws2.onclose = onClose;
               ws2.close();
             } catch (err2) {
               onClose();
             }
           }
           ws2.onopen = null;
           ws2.onmessage = null;
           ws2.onerror = () => {
           };
         }
         this._ws = null;
         if (err)
           this.emit("error", err);
         this.emit("close");
         cb();
       }
       _read() {
       }
       _write(chunk, encoding, cb) {
         if (this.destroyed)
           return cb(new Error("cannot write after socket is destroyed"));
         if (this.connected) {
           try {
             this.send(chunk);
           } catch (err) {
             return this.destroy(err);
           }
           if (typeof ws !== "function" && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
             this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount);
             this._cb = cb;
           } else {
             cb(null);
           }
         } else {
           this._debug("write before connect");
           this._chunk = chunk;
           this._cb = cb;
         }
       }
       _handleOpen() {
         if (this.connected || this.destroyed)
           return;
         this.connected = true;
         if (this._chunk) {
           try {
             this.send(this._chunk);
           } catch (err) {
             return this.destroy(err);
           }
           this._chunk = null;
           this._debug('sent chunk from "write before connect"');
           const cb = this._cb;
           this._cb = null;
           cb(null);
         }
         if (typeof ws !== "function") {
           this._interval = setInterval(() => this._onInterval(), 150);
           if (this._interval.unref)
             this._interval.unref();
         }
         this._debug("connect");
         this.emit("connect");
       }
       _handleMessage(event) {
         if (this.destroyed)
           return;
         let data = event.data;
         if (data instanceof ArrayBuffer)
           data = Buffer.from(data);
         this.push(data);
       }
       _handleClose() {
         if (this.destroyed)
           return;
         this._debug("on close");
         this.destroy();
       }
       _handleError(_) {
         this.destroy(new Error(`Error connecting to ${this.url}`));
       }
       _handleFinish() {
         if (this.destroyed)
           return;
         const destroySoon = () => {
           setTimeout(() => this.destroy(), 1e3);
         };
         if (this.connected) {
           destroySoon();
         } else {
           this.once("connect", destroySoon);
         }
       }
       _onInterval() {
         if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
           return;
         }
         this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
         const cb = this._cb;
         this._cb = null;
         cb(null);
       }
       _debug() {
         const args = [].slice.call(arguments);
         args[0] = "[" + this._id + "] " + args[0];
         debug.apply(null, args);
       }
     };
     Socket.WEBSOCKET_SUPPORT = !!_WebSocket;
     module2.exports = Socket;
   }
 });
 
 // node_modules/bittorrent-tracker/lib/client/websocket-tracker.js
 var require_websocket_tracker = __commonJS({
   "node_modules/bittorrent-tracker/lib/client/websocket-tracker.js"(exports, module2) {
     var clone = require_clone();
     var debug = require_src()("bittorrent-tracker:websocket-tracker");
     var Peer = require_simple_peer();
     var randombytes2 = require_randombytes();
     var Socket = require_simple_websocket();
     var Socks = require_build();
     var common = require_common2();
     var Tracker = require_tracker();
     var socketPool = {};
     var RECONNECT_MINIMUM = 10 * 1e3;
     var RECONNECT_MAXIMUM = 60 * 60 * 1e3;
     var RECONNECT_VARIANCE = 5 * 60 * 1e3;
     var OFFER_TIMEOUT = 50 * 1e3;
     var WebSocketTracker = class extends Tracker {
       constructor(client, announceUrl) {
         super(client, announceUrl);
         debug("new websocket tracker %s", announceUrl);
         this.peers = {};
         this.socket = null;
         this.reconnecting = false;
         this.retries = 0;
         this.reconnectTimer = null;
         this.expectingResponse = false;
         this._openSocket();
       }
       announce(opts) {
         if (this.destroyed || this.reconnecting)
           return;
         if (!this.socket.connected) {
           this.socket.once("connect", () => {
             this.announce(opts);
           });
           return;
         }
         const params = Object.assign({}, opts, {
           action: "announce",
           info_hash: this.client._infoHashBinary,
           peer_id: this.client._peerIdBinary
         });
         if (this._trackerId)
           params.trackerid = this._trackerId;
         if (opts.event === "stopped" || opts.event === "completed") {
           this._send(params);
         } else {
           const numwant = Math.min(opts.numwant, 5);
           this._generateOffers(numwant, (offers) => {
             params.numwant = numwant;
             params.offers = offers;
             this._send(params);
           });
         }
       }
       scrape(opts) {
         if (this.destroyed || this.reconnecting)
           return;
         if (!this.socket.connected) {
           this.socket.once("connect", () => {
             this.scrape(opts);
           });
           return;
         }
         const infoHashes = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? opts.infoHash.map((infoHash) => infoHash.toString("binary")) : opts.infoHash && opts.infoHash.toString("binary") || this.client._infoHashBinary;
         const params = {
           action: "scrape",
           info_hash: infoHashes
         };
         this._send(params);
       }
       destroy(cb = noop2) {
         if (this.destroyed)
           return cb(null);
         this.destroyed = true;
         clearInterval(this.interval);
         clearTimeout(this.reconnectTimer);
         for (const peerId in this.peers) {
           const peer = this.peers[peerId];
           clearTimeout(peer.trackerTimeout);
           peer.destroy();
         }
         this.peers = null;
         if (this.socket) {
           this.socket.removeListener("connect", this._onSocketConnectBound);
           this.socket.removeListener("data", this._onSocketDataBound);
           this.socket.removeListener("close", this._onSocketCloseBound);
           this.socket.removeListener("error", this._onSocketErrorBound);
           this.socket = null;
         }
         this._onSocketConnectBound = null;
         this._onSocketErrorBound = null;
         this._onSocketDataBound = null;
         this._onSocketCloseBound = null;
         if (socketPool[this.announceUrl]) {
           socketPool[this.announceUrl].consumers -= 1;
         }
         if (socketPool[this.announceUrl].consumers > 0)
           return cb();
         let socket = socketPool[this.announceUrl];
         delete socketPool[this.announceUrl];
         socket.on("error", noop2);
         socket.once("close", cb);
         let timeout;
         if (!this.expectingResponse)
           return destroyCleanup();
         timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT);
         socket.once("data", destroyCleanup);
         function destroyCleanup() {
           if (timeout) {
             clearTimeout(timeout);
             timeout = null;
           }
           socket.removeListener("data", destroyCleanup);
           socket.destroy();
           socket = null;
         }
       }
       _openSocket() {
         this.destroyed = false;
         if (!this.peers)
           this.peers = {};
         this._onSocketConnectBound = () => {
           this._onSocketConnect();
         };
         this._onSocketErrorBound = (err) => {
           this._onSocketError(err);
         };
         this._onSocketDataBound = (data) => {
           this._onSocketData(data);
         };
         this._onSocketCloseBound = () => {
           this._onSocketClose();
         };
         this.socket = socketPool[this.announceUrl];
         if (this.socket) {
           socketPool[this.announceUrl].consumers += 1;
           if (this.socket.connected) {
             this._onSocketConnectBound();
           }
         } else {
           const parsedUrl = new URL(this.announceUrl);
           let agent;
           if (this.client._proxyOpts) {
             agent = parsedUrl.protocol === "wss:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent;
             if (!agent && this.client._proxyOpts.socksProxy) {
               agent = new Socks.Agent(clone(this.client._proxyOpts.socksProxy), parsedUrl.protocol === "wss:");
             }
           }
           this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent });
           this.socket.consumers = 1;
           this.socket.once("connect", this._onSocketConnectBound);
         }
         this.socket.on("data", this._onSocketDataBound);
         this.socket.once("close", this._onSocketCloseBound);
         this.socket.once("error", this._onSocketErrorBound);
       }
       _onSocketConnect() {
         if (this.destroyed)
           return;
         if (this.reconnecting) {
           this.reconnecting = false;
           this.retries = 0;
           this.announce(this.client._defaultAnnounceOpts());
         }
       }
       _onSocketData(data) {
         if (this.destroyed)
           return;
         this.expectingResponse = false;
         try {
           data = JSON.parse(data);
         } catch (err) {
           this.client.emit("warning", new Error("Invalid tracker response"));
           return;
         }
         if (data.action === "announce") {
           this._onAnnounceResponse(data);
         } else if (data.action === "scrape") {
           this._onScrapeResponse(data);
         } else {
           this._onSocketError(new Error(`invalid action in WS response: ${data.action}`));
         }
       }
       _onAnnounceResponse(data) {
         if (data.info_hash !== this.client._infoHashBinary) {
           debug(
             "ignoring websocket data from %s for %s (looking for %s: reused socket)",
             this.announceUrl,
             common.binaryToHex(data.info_hash),
             this.client.infoHash
           );
           return;
         }
         if (data.peer_id && data.peer_id === this.client._peerIdBinary) {
           return;
         }
         debug(
           "received %s from %s for %s",
           JSON.stringify(data),
           this.announceUrl,
           this.client.infoHash
         );
         const failure = data["failure reason"];
         if (failure)
           return this.client.emit("warning", new Error(failure));
         const warning = data["warning message"];
         if (warning)
           this.client.emit("warning", new Error(warning));
         const interval = data.interval || data["min interval"];
         if (interval)
           this.setInterval(interval * 1e3);
         const trackerId = data["tracker id"];
         if (trackerId) {
           this._trackerId = trackerId;
         }
         if (data.complete != null) {
           const response = Object.assign({}, data, {
             announce: this.announceUrl,
             infoHash: common.binaryToHex(data.info_hash)
           });
           this.client.emit("update", response);
         }
         let peer;
         if (data.offer && data.peer_id) {
           debug("creating peer (from remote offer)");
           peer = this._createPeer();
           peer.id = common.binaryToHex(data.peer_id);
           peer.once("signal", (answer) => {
             const params = {
               action: "announce",
               info_hash: this.client._infoHashBinary,
               peer_id: this.client._peerIdBinary,
               to_peer_id: data.peer_id,
               answer,
               offer_id: data.offer_id
             };
             if (this._trackerId)
               params.trackerid = this._trackerId;
             this._send(params);
           });
           this.client.emit("peer", peer);
           peer.signal(data.offer);
         }
         if (data.answer && data.peer_id) {
           const offerId = common.binaryToHex(data.offer_id);
           peer = this.peers[offerId];
           if (peer) {
             peer.id = common.binaryToHex(data.peer_id);
             this.client.emit("peer", peer);
             peer.signal(data.answer);
             clearTimeout(peer.trackerTimeout);
             peer.trackerTimeout = null;
             delete this.peers[offerId];
           } else {
             debug(`got unexpected answer: ${JSON.stringify(data.answer)}`);
           }
         }
       }
       _onScrapeResponse(data) {
         data = data.files || {};
         const keys = Object.keys(data);
         if (keys.length === 0) {
           this.client.emit("warning", new Error("invalid scrape response"));
           return;
         }
         keys.forEach((infoHash) => {
           const response = Object.assign(data[infoHash], {
             announce: this.announceUrl,
             infoHash: common.binaryToHex(infoHash)
           });
           this.client.emit("scrape", response);
         });
       }
       _onSocketClose() {
         if (this.destroyed)
           return;
         this.destroy();
         this._startReconnectTimer();
       }
       _onSocketError(err) {
         if (this.destroyed)
           return;
         this.destroy();
         this.client.emit("warning", err);
         this._startReconnectTimer();
       }
       _startReconnectTimer() {
         const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM);
         this.reconnecting = true;
         clearTimeout(this.reconnectTimer);
         this.reconnectTimer = setTimeout(() => {
           this.retries++;
           this._openSocket();
         }, ms);
         if (this.reconnectTimer.unref)
           this.reconnectTimer.unref();
         debug("reconnecting socket in %s ms", ms);
       }
       _send(params) {
         if (this.destroyed)
           return;
         this.expectingResponse = true;
         const message = JSON.stringify(params);
         debug("send %s", message);
         this.socket.send(message);
       }
       _generateOffers(numwant, cb) {
         const self = this;
         const offers = [];
         debug("generating %s offers", numwant);
         for (let i = 0; i < numwant; ++i) {
           generateOffer();
         }
         checkDone();
         function generateOffer() {
           const offerId = randombytes2(20).toString("hex");
           debug("creating peer (from _generateOffers)");
           const peer = self.peers[offerId] = self._createPeer({ initiator: true });
           peer.once("signal", (offer) => {
             offers.push({
               offer,
               offer_id: common.hexToBinary(offerId)
             });
             checkDone();
           });
           peer.trackerTimeout = setTimeout(() => {
             debug("tracker timeout: destroying peer");
             peer.trackerTimeout = null;
             delete self.peers[offerId];
             peer.destroy();
           }, OFFER_TIMEOUT);
           if (peer.trackerTimeout.unref)
             peer.trackerTimeout.unref();
         }
         function checkDone() {
           if (offers.length === numwant) {
             debug("generated %s offers", numwant);
             cb(offers);
           }
         }
       }
       _createPeer(opts) {
         const self = this;
         opts = Object.assign({
           trickle: false,
           config: self.client._rtcConfig,
           wrtc: self.client._wrtc
         }, opts);
         const peer = new Peer(opts);
         peer.once("error", onError);
         peer.once("connect", onConnect);
         return peer;
         function onError(err) {
           self.client.emit("warning", new Error(`Connection error: ${err.message}`));
           peer.destroy();
         }
         function onConnect() {
           peer.removeListener("error", onError);
           peer.removeListener("connect", onConnect);
         }
       }
     };
     WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1e3;
     WebSocketTracker._socketPool = socketPool;
     function noop2() {
     }
     module2.exports = WebSocketTracker;
   }
 });
 
 // node_modules/bittorrent-tracker/client.js
 var require_client2 = __commonJS({
   "node_modules/bittorrent-tracker/client.js"(exports, module2) {
     var debug = require_src()("bittorrent-tracker:client");
     var EventEmitter = require("events");
     var once = require_once();
     var parallel2 = require_run_parallel();
     var Peer = require_simple_peer();
     var queueMicrotask3 = require_queue_microtask();
     var common = require_common2();
     var HTTPTracker = require_http_tracker();
     var UDPTracker = require_udp_tracker();
     var WebSocketTracker = require_websocket_tracker();
     var Client = class extends EventEmitter {
       constructor(opts = {}) {
         super();
         if (!opts.peerId)
           throw new Error("Option `peerId` is required");
         if (!opts.infoHash)
           throw new Error("Option `infoHash` is required");
         if (!opts.announce)
           throw new Error("Option `announce` is required");
         if (!process.browser && !opts.port)
           throw new Error("Option `port` is required");
         this.peerId = typeof opts.peerId === "string" ? opts.peerId : opts.peerId.toString("hex");
         this._peerIdBuffer = Buffer.from(this.peerId, "hex");
         this._peerIdBinary = this._peerIdBuffer.toString("binary");
         this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : opts.infoHash.toString("hex");
         this._infoHashBuffer = Buffer.from(this.infoHash, "hex");
         this._infoHashBinary = this._infoHashBuffer.toString("binary");
         debug("new client %s", this.infoHash);
         this.destroyed = false;
         this._port = opts.port;
         this._getAnnounceOpts = opts.getAnnounceOpts;
         this._rtcConfig = opts.rtcConfig;
         this._userAgent = opts.userAgent;
         this._proxyOpts = opts.proxyOpts;
         this._wrtc = typeof opts.wrtc === "function" ? opts.wrtc() : opts.wrtc;
         let announce = typeof opts.announce === "string" ? [opts.announce] : opts.announce == null ? [] : opts.announce;
         announce = announce.map((announceUrl) => {
           announceUrl = announceUrl.toString();
           if (announceUrl[announceUrl.length - 1] === "/") {
             announceUrl = announceUrl.substring(0, announceUrl.length - 1);
           }
           return announceUrl;
         });
         announce = Array.from(new Set(announce));
         const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT);
         const nextTickWarn = (err) => {
           queueMicrotask3(() => {
             this.emit("warning", err);
           });
         };
         this._trackers = announce.map((announceUrl) => {
           let parsedUrl;
           try {
             parsedUrl = common.parseUrl(announceUrl);
           } catch (err) {
             nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`));
             return null;
           }
           const port = parsedUrl.port;
           if (port < 0 || port > 65535) {
             nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`));
             return null;
           }
           const protocol = parsedUrl.protocol;
           if ((protocol === "http:" || protocol === "https:") && typeof HTTPTracker === "function") {
             return new HTTPTracker(this, announceUrl);
           } else if (protocol === "udp:" && typeof UDPTracker === "function") {
             return new UDPTracker(this, announceUrl);
           } else if ((protocol === "ws:" || protocol === "wss:") && webrtcSupport) {
             if (protocol === "ws:" && typeof window !== "undefined" && window.location.protocol === "https:") {
               nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`));
               return null;
             }
             return new WebSocketTracker(this, announceUrl);
           } else {
             nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`));
             return null;
           }
         }).filter(Boolean);
       }
       start(opts) {
         opts = this._defaultAnnounceOpts(opts);
         opts.event = "started";
         debug("send `start` %o", opts);
         this._announce(opts);
         this._trackers.forEach((tracker) => {
           tracker.setInterval();
         });
       }
       stop(opts) {
         opts = this._defaultAnnounceOpts(opts);
         opts.event = "stopped";
         debug("send `stop` %o", opts);
         this._announce(opts);
       }
       complete(opts) {
         if (!opts)
           opts = {};
         opts = this._defaultAnnounceOpts(opts);
         opts.event = "completed";
         debug("send `complete` %o", opts);
         this._announce(opts);
       }
       update(opts) {
         opts = this._defaultAnnounceOpts(opts);
         if (opts.event)
           delete opts.event;
         debug("send `update` %o", opts);
         this._announce(opts);
       }
       _announce(opts) {
         this._trackers.forEach((tracker) => {
           tracker.announce(opts);
         });
       }
       scrape(opts) {
         debug("send `scrape`");
         if (!opts)
           opts = {};
         this._trackers.forEach((tracker) => {
           tracker.scrape(opts);
         });
       }
       setInterval(intervalMs) {
         debug("setInterval %d", intervalMs);
         this._trackers.forEach((tracker) => {
           tracker.setInterval(intervalMs);
         });
       }
       destroy(cb) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         debug("destroy");
         const tasks = this._trackers.map((tracker) => (cb2) => {
           tracker.destroy(cb2);
         });
         parallel2(tasks, cb);
         this._trackers = [];
         this._getAnnounceOpts = null;
       }
       _defaultAnnounceOpts(opts = {}) {
         if (opts.numwant == null)
           opts.numwant = common.DEFAULT_ANNOUNCE_PEERS;
         if (opts.uploaded == null)
           opts.uploaded = 0;
         if (opts.downloaded == null)
           opts.downloaded = 0;
         if (this._getAnnounceOpts)
           opts = Object.assign({}, opts, this._getAnnounceOpts());
         return opts;
       }
     };
     Client.scrape = (opts, cb) => {
       cb = once(cb);
       if (!opts.infoHash)
         throw new Error("Option `infoHash` is required");
       if (!opts.announce)
         throw new Error("Option `announce` is required");
       const clientOpts = Object.assign({}, opts, {
         infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
         peerId: Buffer.from("01234567890123456789"),
         port: 6881
       });
       const client = new Client(clientOpts);
       client.once("error", cb);
       client.once("warning", cb);
       let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1;
       const results = {};
       client.on("scrape", (data) => {
         len -= 1;
         results[data.infoHash] = data;
         if (len === 0) {
           client.destroy();
           const keys = Object.keys(results);
           if (keys.length === 1) {
             cb(null, results[keys[0]]);
           } else {
             cb(null, results);
           }
         }
       });
       opts.infoHash = Array.isArray(opts.infoHash) ? opts.infoHash.map((infoHash) => Buffer.from(infoHash, "hex")) : Buffer.from(opts.infoHash, "hex");
       client.scrape({ infoHash: opts.infoHash });
       return client;
     };
     module2.exports = Client;
   }
 });
 
 // node_modules/bittorrent-lsd/index.js
 var require_bittorrent_lsd = __commonJS({
   "node_modules/bittorrent-lsd/index.js"(exports, module2) {
     var dgram = require("dgram");
     var EventEmitter = require("events").EventEmitter;
     var debug = require_src()("bittorrent-lsd");
     var ANNOUNCE_INTERVAL = 3e5;
     var LSD_HOST = "239.192.152.143";
     var LSD_PORT = 6771;
     var LSD = class extends EventEmitter {
       constructor(opts = {}) {
         super();
         if (!opts.peerId)
           throw new Error("Option `peerId` is required");
         if (!opts.infoHash)
           throw new Error("Option `infoHash` is required");
         if (!opts.port)
           throw new Error("Option `port` is required");
         this.peerId = typeof opts.peerId === "string" ? opts.peerId : opts.peerId.toString("hex");
         this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : opts.infoHash.toString("hex");
         this.port = typeof opts.port === "string" ? opts.port : opts.port.toString();
         this.cookie = `bittorrent-lsd-${this.peerId}`;
         this.destroyed = false;
         this.annouceIntervalId = null;
         this.server = dgram.createSocket({ type: "udp4", reuseAddr: true });
         const onListening = () => {
           debug("listening");
           try {
             this.server.addMembership(LSD_HOST);
           } catch (err) {
             this.emit("warning", err);
           }
         };
         const onMessage = (msg, rinfo) => {
           debug("message", msg.toString(), `${rinfo.address}:${rinfo.port}`);
           const parsedAnnounce = this._parseAnnounce(msg.toString());
           if (parsedAnnounce === null)
             return;
           if (parsedAnnounce.cookie === this.cookie)
             return;
           parsedAnnounce.infoHash.forEach((infoHash) => {
             this.emit("peer", `${rinfo.address}:${parsedAnnounce.port}`, infoHash);
           });
         };
         const onError = (err) => {
           this.emit("error", err);
         };
         this.server.on("listening", onListening);
         this.server.on("message", onMessage);
         this.server.on("error", onError);
       }
       _parseAnnounce(announce) {
         const checkHost = (host2) => {
           return /^(239.192.152.143|\[ff15::efc0:988f]):6771$/.test(host2);
         };
         const checkPort = (port2) => {
           return /^\d+$/.test(port2);
         };
         const checkInfoHash = (infoHash2) => {
           return /^[0-9a-fA-F]{40}$/.test(infoHash2);
         };
         debug("parse announce", announce);
         const sections = announce.split("\r\n");
         if (sections[0] !== "BT-SEARCH * HTTP/1.1") {
           this.emit("warning", "Invalid LSD announce (header)");
           return null;
         }
         const host = sections[1].split("Host: ")[1];
         if (!checkHost(host)) {
           this.emit("warning", "Invalid LSD announce (host)");
           return null;
         }
         const port = sections[2].split("Port: ")[1];
         if (!checkPort(port)) {
           this.emit("warning", "Invalid LSD announce (port)");
           return null;
         }
         const infoHash = sections.filter((section) => section.includes("Infohash: ")).map((section) => section.split("Infohash: ")[1]).filter((infoHash2) => checkInfoHash(infoHash2));
         if (infoHash.length === 0) {
           this.emit("warning", "Invalid LSD announce (infoHash)");
           return null;
         }
         const cookie = sections.filter((section) => section.includes("cookie: ")).map((section) => section.split("cookie: ")[1]).reduce((acc, cur) => cur, null);
         return {
           host,
           port,
           infoHash,
           cookie
         };
       }
       destroy(cb) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         debug("destroy");
         clearInterval(this.annouceIntervalId);
         this.server.close(cb);
       }
       start() {
         debug("start");
         this.server.bind(LSD_PORT);
         this._announce();
         this.annouceIntervalId = setInterval(() => {
           this._announce();
         }, ANNOUNCE_INTERVAL);
       }
       _announce() {
         debug("send announce");
         const host = `${LSD_HOST}:${LSD_PORT}`;
         const announce = `BT-SEARCH * HTTP/1.1\r
 Host: ${host}\r
 Port: ${this.port}\r
 Infohash: ${this.infoHash}\r
 cookie: ${this.cookie}\r
 \r
 \r
 `;
         this.server.send(announce, LSD_PORT, LSD_HOST);
       }
     };
     module2.exports = LSD;
   }
 });
 
 // node_modules/torrent-discovery/index.js
 var require_torrent_discovery = __commonJS({
   "node_modules/torrent-discovery/index.js"(exports, module2) {
     var debug = require_src()("torrent-discovery");
     var DHT = require_client();
     var EventEmitter = require("events").EventEmitter;
     var parallel2 = require_run_parallel();
     var Tracker = require_client2();
     var LSD = require_bittorrent_lsd();
     var Discovery = class extends EventEmitter {
       constructor(opts) {
         super();
         if (!opts.peerId)
           throw new Error("Option `peerId` is required");
         if (!opts.infoHash)
           throw new Error("Option `infoHash` is required");
         if (!process.browser && !opts.port)
           throw new Error("Option `port` is required");
         this.peerId = typeof opts.peerId === "string" ? opts.peerId : opts.peerId.toString("hex");
         this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : opts.infoHash.toString("hex");
         this._port = opts.port;
         this._userAgent = opts.userAgent;
         this.destroyed = false;
         this._announce = opts.announce || [];
         this._intervalMs = opts.intervalMs || 15 * 60 * 1e3;
         this._trackerOpts = null;
         this._dhtAnnouncing = false;
         this._dhtTimeout = false;
         this._internalDHT = false;
         this._onWarning = (err) => {
           this.emit("warning", err);
         };
         this._onError = (err) => {
           this.emit("error", err);
         };
         this._onDHTPeer = (peer, infoHash) => {
           if (infoHash.toString("hex") !== this.infoHash)
             return;
           this.emit("peer", `${peer.host}:${peer.port}`, "dht");
         };
         this._onTrackerPeer = (peer) => {
           this.emit("peer", peer, "tracker");
         };
         this._onTrackerAnnounce = () => {
           this.emit("trackerAnnounce");
         };
         this._onLSDPeer = (peer, infoHash) => {
           this.emit("peer", peer, "lsd");
         };
         const createDHT = (port, opts2) => {
           const dht = new DHT(opts2);
           dht.on("warning", this._onWarning);
           dht.on("error", this._onError);
           dht.listen(port);
           this._internalDHT = true;
           return dht;
         };
         if (opts.tracker === false) {
           this.tracker = null;
         } else if (opts.tracker && typeof opts.tracker === "object") {
           this._trackerOpts = Object.assign({}, opts.tracker);
           this.tracker = this._createTracker();
         } else {
           this.tracker = this._createTracker();
         }
         if (opts.dht === false || typeof DHT !== "function") {
           this.dht = null;
         } else if (opts.dht && typeof opts.dht.addNode === "function") {
           this.dht = opts.dht;
         } else if (opts.dht && typeof opts.dht === "object") {
           this.dht = createDHT(opts.dhtPort, opts.dht);
         } else {
           this.dht = createDHT(opts.dhtPort);
         }
         if (this.dht) {
           this.dht.on("peer", this._onDHTPeer);
           this._dhtAnnounce();
         }
         if (opts.lsd === false || typeof LSD !== "function") {
           this.lsd = null;
         } else {
           this.lsd = this._createLSD();
         }
       }
       updatePort(port) {
         if (port === this._port)
           return;
         this._port = port;
         if (this.dht)
           this._dhtAnnounce();
         if (this.tracker) {
           this.tracker.stop();
           this.tracker.destroy(() => {
             this.tracker = this._createTracker();
           });
         }
       }
       complete(opts) {
         if (this.tracker) {
           this.tracker.complete(opts);
         }
       }
       destroy(cb) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         clearTimeout(this._dhtTimeout);
         const tasks = [];
         if (this.tracker) {
           this.tracker.stop();
           this.tracker.removeListener("warning", this._onWarning);
           this.tracker.removeListener("error", this._onError);
           this.tracker.removeListener("peer", this._onTrackerPeer);
           this.tracker.removeListener("update", this._onTrackerAnnounce);
           tasks.push((cb2) => {
             this.tracker.destroy(cb2);
           });
         }
         if (this.dht) {
           this.dht.removeListener("peer", this._onDHTPeer);
         }
         if (this._internalDHT) {
           this.dht.removeListener("warning", this._onWarning);
           this.dht.removeListener("error", this._onError);
           tasks.push((cb2) => {
             this.dht.destroy(cb2);
           });
         }
         if (this.lsd) {
           this.lsd.removeListener("warning", this._onWarning);
           this.lsd.removeListener("error", this._onError);
           this.lsd.removeListener("peer", this._onLSDPeer);
           tasks.push((cb2) => {
             this.lsd.destroy(cb2);
           });
         }
         parallel2(tasks, cb);
         this.dht = null;
         this.tracker = null;
         this.lsd = null;
         this._announce = null;
       }
       _createTracker() {
         const opts = Object.assign({}, this._trackerOpts, {
           infoHash: this.infoHash,
           announce: this._announce,
           peerId: this.peerId,
           port: this._port,
           userAgent: this._userAgent
         });
         const tracker = new Tracker(opts);
         tracker.on("warning", this._onWarning);
         tracker.on("error", this._onError);
         tracker.on("peer", this._onTrackerPeer);
         tracker.on("update", this._onTrackerAnnounce);
         tracker.setInterval(this._intervalMs);
         tracker.start();
         return tracker;
       }
       _dhtAnnounce() {
         if (this._dhtAnnouncing)
           return;
         debug("dht announce");
         this._dhtAnnouncing = true;
         clearTimeout(this._dhtTimeout);
         this.dht.announce(this.infoHash, this._port, (err) => {
           this._dhtAnnouncing = false;
           debug("dht announce complete");
           if (err)
             this.emit("warning", err);
           this.emit("dhtAnnounce");
           if (!this.destroyed) {
             this._dhtTimeout = setTimeout(() => {
               this._dhtAnnounce();
             }, this._intervalMs + Math.floor(Math.random() * this._intervalMs / 5));
             if (this._dhtTimeout.unref)
               this._dhtTimeout.unref();
           }
         });
       }
       _createLSD() {
         const opts = Object.assign({}, {
           infoHash: this.infoHash,
           peerId: this.peerId,
           port: this._port
         });
         const lsd = new LSD(opts);
         lsd.on("warning", this._onWarning);
         lsd.on("error", this._onError);
         lsd.on("peer", this._onLSDPeer);
         lsd.start();
         return lsd;
       }
     };
     module2.exports = Discovery;
   }
 });
 
 // node_modules/random-access-storage/index.js
 var require_random_access_storage = __commonJS({
   "node_modules/random-access-storage/index.js"(exports, module2) {
     var events = require("events");
     var inherits = require_inherits();
     var queueTick = require_process_next_tick();
     var NOT_READABLE = defaultImpl(new Error("Not readable"));
     var NOT_WRITABLE = defaultImpl(new Error("Not writable"));
     var NOT_DELETABLE = defaultImpl(new Error("Not deletable"));
     var NOT_STATABLE = defaultImpl(new Error("Not statable"));
     var NO_OPEN_READABLE = defaultImpl(new Error("No readonly open"));
     var READ_OP = 0;
     var WRITE_OP = 1;
     var DEL_OP = 2;
     var STAT_OP = 3;
     var OPEN_OP = 4;
     var CLOSE_OP = 5;
     var DESTROY_OP = 6;
     module2.exports = RandomAccess;
     function RandomAccess(opts) {
       if (!(this instanceof RandomAccess))
         return new RandomAccess(opts);
       events.EventEmitter.call(this);
       this._queued = [];
       this._pending = 0;
       this._needsOpen = true;
       this.opened = false;
       this.closed = false;
       this.destroyed = false;
       if (opts) {
         if (opts.openReadonly)
           this._openReadonly = opts.openReadonly;
         if (opts.open)
           this._open = opts.open;
         if (opts.read)
           this._read = opts.read;
         if (opts.write)
           this._write = opts.write;
         if (opts.del)
           this._del = opts.del;
         if (opts.stat)
           this._stat = opts.stat;
         if (opts.close)
           this._close = opts.close;
         if (opts.destroy)
           this._destroy = opts.destroy;
       }
       this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE;
       this.readable = this._read !== NOT_READABLE;
       this.writable = this._write !== NOT_WRITABLE;
       this.deletable = this._del !== NOT_DELETABLE;
       this.statable = this._stat !== NOT_STATABLE;
     }
     inherits(RandomAccess, events.EventEmitter);
     RandomAccess.prototype.read = function(offset, size, cb) {
       this.run(new Request(this, READ_OP, offset, size, null, cb));
     };
     RandomAccess.prototype._read = NOT_READABLE;
     RandomAccess.prototype.write = function(offset, data, cb) {
       if (!cb)
         cb = noop2;
       openWritable(this);
       this.run(new Request(this, WRITE_OP, offset, data.length, data, cb));
     };
     RandomAccess.prototype._write = NOT_WRITABLE;
     RandomAccess.prototype.del = function(offset, size, cb) {
       if (!cb)
         cb = noop2;
       openWritable(this);
       this.run(new Request(this, DEL_OP, offset, size, null, cb));
     };
     RandomAccess.prototype._del = NOT_DELETABLE;
     RandomAccess.prototype.stat = function(cb) {
       this.run(new Request(this, STAT_OP, 0, 0, null, cb));
     };
     RandomAccess.prototype._stat = NOT_STATABLE;
     RandomAccess.prototype.open = function(cb) {
       if (!cb)
         cb = noop2;
       if (this.opened && !this._needsOpen)
         return queueTick(() => cb(null));
       queueAndRun(this, new Request(this, OPEN_OP, 0, 0, null, cb));
     };
     RandomAccess.prototype._open = defaultImpl(null);
     RandomAccess.prototype._openReadonly = NO_OPEN_READABLE;
     RandomAccess.prototype.close = function(cb) {
       if (!cb)
         cb = noop2;
       if (this.closed)
         return queueTick(() => cb(null));
       queueAndRun(this, new Request(this, CLOSE_OP, 0, 0, null, cb));
     };
     RandomAccess.prototype._close = defaultImpl(null);
     RandomAccess.prototype.destroy = function(cb) {
       if (!cb)
         cb = noop2;
       if (!this.closed)
         this.close(noop2);
       queueAndRun(this, new Request(this, DESTROY_OP, 0, 0, null, cb));
     };
     RandomAccess.prototype._destroy = defaultImpl(null);
     RandomAccess.prototype.run = function(req) {
       if (this._needsOpen)
         this.open(noop2);
       if (this._queued.length)
         this._queued.push(req);
       else
         req._run();
     };
     function noop2() {
     }
     function Request(self, type, offset, size, data, cb) {
       this.type = type;
       this.offset = offset;
       this.data = data;
       this.size = size;
       this.storage = self;
       this._sync = false;
       this._callback = cb;
       this._openError = null;
     }
     Request.prototype._maybeOpenError = function(err) {
       if (this.type !== OPEN_OP)
         return;
       var queued = this.storage._queued;
       for (var i = 0; i < queued.length; i++)
         queued[i]._openError = err;
     };
     Request.prototype._unqueue = function(err) {
       var ra = this.storage;
       var queued = ra._queued;
       if (!err) {
         switch (this.type) {
           case OPEN_OP:
             if (!ra.opened) {
               ra.opened = true;
               ra.emit("open");
             }
             break;
           case CLOSE_OP:
             if (!ra.closed) {
               ra.closed = true;
               ra.emit("close");
             }
             break;
           case DESTROY_OP:
             if (!ra.destroyed) {
               ra.destroyed = true;
               ra.emit("destroy");
             }
             break;
         }
       } else {
         this._maybeOpenError(err);
       }
       if (queued.length && queued[0] === this)
         queued.shift();
       if (!--ra._pending)
         drainQueue(ra);
     };
     Request.prototype.callback = function(err, val) {
       if (this._sync)
         return nextTick2(this, err, val);
       this._unqueue(err);
       this._callback(err, val);
     };
     Request.prototype._openAndNotClosed = function() {
       var ra = this.storage;
       if (ra.opened && !ra.closed)
         return true;
       if (!ra.opened)
         nextTick2(this, this._openError || new Error("Not opened"));
       else if (ra.closed)
         nextTick2(this, new Error("Closed"));
       return false;
     };
     Request.prototype._open = function() {
       var ra = this.storage;
       if (ra.opened && !ra._needsOpen)
         return nextTick2(this, null);
       if (ra.closed)
         return nextTick2(this, new Error("Closed"));
       ra._needsOpen = false;
       if (ra.preferReadonly)
         ra._openReadonly(this);
       else
         ra._open(this);
     };
     Request.prototype._run = function() {
       var ra = this.storage;
       ra._pending++;
       this._sync = true;
       switch (this.type) {
         case READ_OP:
           if (this._openAndNotClosed())
             ra._read(this);
           break;
         case WRITE_OP:
           if (this._openAndNotClosed())
             ra._write(this);
           break;
         case DEL_OP:
           if (this._openAndNotClosed())
             ra._del(this);
           break;
         case STAT_OP:
           if (this._openAndNotClosed())
             ra._stat(this);
           break;
         case OPEN_OP:
           this._open();
           break;
         case CLOSE_OP:
           if (ra.closed || !ra.opened)
             nextTick2(this, null);
           else
             ra._close(this);
           break;
         case DESTROY_OP:
           if (ra.destroyed)
             nextTick2(this, null);
           else
             ra._destroy(this);
           break;
       }
       this._sync = false;
     };
     function queueAndRun(self, req) {
       self._queued.push(req);
       if (!self._pending)
         req._run();
     }
     function drainQueue(self) {
       var queued = self._queued;
       while (queued.length > 0) {
         var blocking = queued[0].type > 3;
         if (!blocking || !self._pending)
           queued[0]._run();
         if (blocking)
           return;
         queued.shift();
       }
     }
     function openWritable(self) {
       if (self.preferReadonly) {
         self._needsOpen = true;
         self.preferReadonly = false;
       }
     }
     function defaultImpl(err) {
       return overridable;
       function overridable(req) {
         nextTick2(req, err);
       }
     }
     function nextTick2(req, err, val) {
       queueTick(() => req.callback(err, val));
     }
   }
 });
 
 // node_modules/mkdirp-classic/index.js
 var require_mkdirp_classic = __commonJS({
   "node_modules/mkdirp-classic/index.js"(exports, module2) {
     var path2 = require("path");
     var fs2 = require("fs");
     var _0777 = parseInt("0777", 8);
     module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
     function mkdirP(p, opts, f, made) {
       if (typeof opts === "function") {
         f = opts;
         opts = {};
       } else if (!opts || typeof opts !== "object") {
         opts = { mode: opts };
       }
       var mode = opts.mode;
       var xfs = opts.fs || fs2;
       if (mode === void 0) {
         mode = _0777 & ~process.umask();
       }
       if (!made)
         made = null;
       var cb = f || function() {
       };
       p = path2.resolve(p);
       xfs.mkdir(p, mode, function(er) {
         if (!er) {
           made = made || p;
           return cb(null, made);
         }
         switch (er.code) {
           case "ENOENT":
             mkdirP(path2.dirname(p), opts, function(er2, made2) {
               if (er2)
                 cb(er2, made2);
               else
                 mkdirP(p, opts, cb, made2);
             });
             break;
           default:
             xfs.stat(p, function(er2, stat) {
               if (er2 || !stat.isDirectory())
                 cb(er, made);
               else
                 cb(null, made);
             });
             break;
         }
       });
     }
     mkdirP.sync = function sync(p, opts, made) {
       if (!opts || typeof opts !== "object") {
         opts = { mode: opts };
       }
       var mode = opts.mode;
       var xfs = opts.fs || fs2;
       if (mode === void 0) {
         mode = _0777 & ~process.umask();
       }
       if (!made)
         made = null;
       p = path2.resolve(p);
       try {
         xfs.mkdirSync(p, mode);
         made = made || p;
       } catch (err0) {
         switch (err0.code) {
           case "ENOENT":
             made = sync(path2.dirname(p), opts, made);
             sync(p, opts, made);
             break;
           default:
             var stat;
             try {
               stat = xfs.statSync(p);
             } catch (err1) {
               throw err0;
             }
             if (!stat.isDirectory())
               throw err0;
             break;
         }
       }
       return made;
     };
   }
 });
 
 // node_modules/random-access-file/index.js
 var require_random_access_file = __commonJS({
   "node_modules/random-access-file/index.js"(exports, module2) {
     var inherits = require("util").inherits;
     var RandomAccess = require_random_access_storage();
     var fs2 = require("fs");
     var mkdirp = require_mkdirp_classic();
     var path2 = require("path");
     var constants = fs2.constants || require("constants");
     var READONLY = constants.O_RDONLY;
     var READWRITE = constants.O_RDWR | constants.O_CREAT;
     module2.exports = RandomAccessFile;
     function RandomAccessFile(filename, opts) {
       if (!(this instanceof RandomAccessFile))
         return new RandomAccessFile(filename, opts);
       RandomAccess.call(this);
       if (!opts)
         opts = {};
       if (opts.directory)
         filename = path2.join(opts.directory, path2.resolve("/", filename).replace(/^\w+:\\/, ""));
       this.directory = opts.directory || null;
       this.filename = filename;
       this.fd = 0;
       if (opts.writable || opts.truncate)
         this.preferReadonly = false;
       this._size = opts.size || opts.length || 0;
       this._truncate = !!opts.truncate || this._size > 0;
       this._rmdir = !!opts.rmdir;
       this._lock = opts.lock || noLock;
       this._sparse = opts.sparse || noLock;
       this._alloc = opts.alloc || Buffer.allocUnsafe;
     }
     inherits(RandomAccessFile, RandomAccess);
     RandomAccessFile.prototype._open = function(req) {
       var self = this;
       mkdirp(path2.dirname(this.filename), ondir);
       function ondir(err) {
         if (err)
           return req.callback(err);
         open(self, READWRITE, req);
       }
     };
     RandomAccessFile.prototype._openReadonly = function(req) {
       open(this, READONLY, req);
     };
     RandomAccessFile.prototype._write = function(req) {
       var data = req.data;
       var fd = this.fd;
       fs2.write(fd, data, 0, req.size, req.offset, onwrite);
       function onwrite(err, wrote) {
         if (err)
           return req.callback(err);
         req.size -= wrote;
         req.offset += wrote;
         if (!req.size)
           return req.callback(null);
         fs2.write(fd, data, data.length - req.size, req.size, req.offset, onwrite);
       }
     };
     RandomAccessFile.prototype._read = function(req) {
       var self = this;
       var data = req.data || this._alloc(req.size);
       var fd = this.fd;
       if (!req.size)
         return process.nextTick(readEmpty, req);
       fs2.read(fd, data, 0, req.size, req.offset, onread);
       function onread(err, read) {
         if (err)
           return req.callback(err);
         if (!read)
           return req.callback(createReadError(self.filename, req.offset, req.size));
         req.size -= read;
         req.offset += read;
         if (!req.size)
           return req.callback(null, data);
         fs2.read(fd, data, data.length - req.size, req.size, req.offset, onread);
       }
     };
     RandomAccessFile.prototype._del = function(req) {
       var fd = this.fd;
       fs2.fstat(fd, onstat);
       function onstat(err, st) {
         if (err)
           return req.callback(err);
         if (req.offset + req.size < st.size)
           return req.callback(null);
         fs2.ftruncate(fd, req.offset, ontruncate);
       }
       function ontruncate(err) {
         req.callback(err);
       }
     };
     RandomAccessFile.prototype._stat = function(req) {
       fs2.fstat(this.fd, onstat);
       function onstat(err, st) {
         req.callback(err, st);
       }
     };
     RandomAccessFile.prototype._close = function(req) {
       var self = this;
       fs2.close(this.fd, onclose);
       function onclose(err) {
         if (err)
           return req.callback(err);
         self.fd = 0;
         req.callback(null);
       }
     };
     RandomAccessFile.prototype._destroy = function(req) {
       var self = this;
       var root = this.directory && path2.resolve(path2.join(this.directory, "."));
       var dir = path2.resolve(path2.dirname(this.filename));
       fs2.unlink(this.filename, onunlink);
       function onunlink(err) {
         if (!self._rmdir || !root || dir === root)
           return req.callback(err);
         fs2.rmdir(dir, onrmdir);
       }
       function onrmdir(err) {
         dir = path2.join(dir, "..");
         if (err || dir === root)
           return req.callback(null);
         fs2.rmdir(dir, onrmdir);
       }
     };
     function open(self, mode, req) {
       if (self.fd)
         fs2.close(self.fd, oncloseold);
       else
         fs2.open(self.filename, mode, onopen);
       function onopen(err, fd) {
         if (err)
           return req.callback(err);
         self.fd = fd;
         if (!self._lock(self.fd))
           return req.callback(createLockError(self.filename));
         if (!self._sparse(self.fd))
           return req.callback(createSparseError(self.filename));
         if (!self._truncate || mode === READONLY)
           return req.callback(null);
         fs2.ftruncate(self.fd, self._size, ontruncate);
       }
       function oncloseold(err) {
         if (err)
           return onerrorafteropen(err);
         self.fd = 0;
         fs2.open(self.filename, mode, onopen);
       }
       function ontruncate(err) {
         if (err)
           return onerrorafteropen(err);
         req.callback(null);
       }
       function onerrorafteropen(err) {
         fs2.close(self.fd, function() {
           self.fd = 0;
           req.callback(err);
         });
       }
     }
     function readEmpty(req) {
       req.callback(null, Buffer.alloc(0));
     }
     function noLock(fd) {
       return true;
     }
     function createSparseError(path3) {
       var err = new Error("ENOTSPARSE: File could not be marked as sparse");
       err.code = "ENOTSPARSE";
       err.path = path3;
       return err;
     }
     function createLockError(path3) {
       var err = new Error("ELOCKED: File is locked");
       err.code = "ELOCKED";
       err.path = path3;
       return err;
     }
     function createReadError(path3, offset, size) {
       var err = new Error("Could not satisfy length");
       err.code = "EPARTIALREAD";
       err.path = path3;
       err.offset = offset;
       err.size = size;
       return err;
     }
   }
 });
 
 // node_modules/thunky/index.js
 var require_thunky = __commonJS({
   "node_modules/thunky/index.js"(exports, module2) {
     "use strict";
     var nextTick2 = nextTickArgs;
     process.nextTick(upgrade, 42);
     module2.exports = thunky2;
     function thunky2(fn) {
       var state = run;
       return thunk;
       function thunk(callback) {
         state(callback || noop2);
       }
       function run(callback) {
         var stack = [callback];
         state = wait;
         fn(done);
         function wait(callback2) {
           stack.push(callback2);
         }
         function done(err) {
           var args = arguments;
           state = isError(err) ? run : finished;
           while (stack.length)
             finished(stack.shift());
           function finished(callback2) {
             nextTick2(apply, callback2, args);
           }
         }
       }
     }
     function isError(err) {
       return Object.prototype.toString.call(err) === "[object Error]";
     }
     function noop2() {
     }
     function apply(callback, args) {
       callback.apply(null, args);
     }
     function upgrade(val) {
       if (val === 42)
         nextTick2 = process.nextTick;
     }
     function nextTickArgs(fn, a, b) {
       process.nextTick(function() {
         fn(a, b);
       });
     }
   }
 });
 
 // node_modules/webtorrent/node_modules/fs-chunk-store/index.js
 var require_fs_chunk_store = __commonJS({
   "node_modules/webtorrent/node_modules/fs-chunk-store/index.js"(exports, module2) {
     module2.exports = Storage2;
     var fs2 = require("fs");
     var os2 = require("os");
     var parallel2 = require_run_parallel();
     var path2 = require("path");
     var queueMicrotask3 = require_queue_microtask();
     var raf2 = require_random_access_file();
     var randombytes2 = require_randombytes();
     var thunky2 = require_thunky();
     var TMP2;
     try {
       TMP2 = fs2.statSync("/tmp") && "/tmp";
     } catch (err) {
       TMP2 = os2.tmpdir();
     }
     function Storage2(chunkLength, opts) {
       const self = this;
       if (!(self instanceof Storage2))
         return new Storage2(chunkLength, opts);
       if (!opts)
         opts = {};
       self.chunkLength = Number(chunkLength);
       if (!self.chunkLength)
         throw new Error("First argument must be a chunk length");
       self.name = opts.name || path2.join("fs-chunk-store", randombytes2(20).toString("hex"));
       self.addUID = opts.addUID;
       if (opts.files) {
         self.path = opts.path;
         if (!Array.isArray(opts.files)) {
           throw new Error("`files` option must be an array");
         }
         self.files = opts.files.map(function(file, i, files) {
           if (file.path == null)
             throw new Error("File is missing `path` property");
           if (file.length == null)
             throw new Error("File is missing `length` property");
           if (file.offset == null) {
             if (i === 0) {
               file.offset = 0;
             } else {
               const prevFile = files[i - 1];
               file.offset = prevFile.offset + prevFile.length;
             }
           }
           let newPath = file.path;
           if (self.path) {
             newPath = self.addUID ? path2.resolve(path2.join(self.path, self.name, file.path)) : path2.resolve(path2.join(self.path, file.path));
           }
           return { path: newPath, length: file.length, offset: file.offset };
         });
         self.length = self.files.reduce(function(sum, file) {
           return sum + file.length;
         }, 0);
         if (opts.length != null && opts.length !== self.length) {
           throw new Error("total `files` length is not equal to explicit `length` option");
         }
       } else {
         const len = Number(opts.length) || Infinity;
         self.files = [{
           offset: 0,
           path: path2.resolve(opts.path || path2.join(TMP2, self.name)),
           length: len
         }];
         self.length = len;
       }
       self.chunkMap = [];
       self.closed = false;
       self.files.forEach(function(file) {
         file.open = thunky2(function(cb) {
           if (self.closed)
             return cb(new Error("Storage is closed"));
           fs2.mkdir(path2.dirname(file.path), { recursive: true }, function(err) {
             if (err)
               return cb(err);
             if (self.closed)
               return cb(new Error("Storage is closed"));
             cb(null, raf2(file.path));
           });
         });
       });
       if (self.length !== Infinity) {
         self.lastChunkLength = self.length % self.chunkLength || self.chunkLength;
         self.lastChunkIndex = Math.ceil(self.length / self.chunkLength) - 1;
         self.files.forEach(function(file) {
           const fileStart = file.offset;
           const fileEnd = file.offset + file.length;
           const firstChunk = Math.floor(fileStart / self.chunkLength);
           const lastChunk = Math.floor((fileEnd - 1) / self.chunkLength);
           for (let p = firstChunk; p <= lastChunk; ++p) {
             const chunkStart = p * self.chunkLength;
             const chunkEnd = chunkStart + self.chunkLength;
             const from = fileStart < chunkStart ? 0 : fileStart - chunkStart;
             const to = fileEnd > chunkEnd ? self.chunkLength : fileEnd - chunkStart;
             const offset = fileStart > chunkStart ? 0 : chunkStart - fileStart;
             if (!self.chunkMap[p])
               self.chunkMap[p] = [];
             self.chunkMap[p].push({
               from,
               to,
               offset,
               file
             });
           }
         });
       }
     }
     Storage2.prototype.put = function(index, buf, cb) {
       const self = this;
       if (typeof cb !== "function")
         cb = noop2;
       if (self.closed)
         return nextTick2(cb, new Error("Storage is closed"));
       const isLastChunk = index === self.lastChunkIndex;
       if (isLastChunk && buf.length !== self.lastChunkLength) {
         return nextTick2(cb, new Error("Last chunk length must be " + self.lastChunkLength));
       }
       if (!isLastChunk && buf.length !== self.chunkLength) {
         return nextTick2(cb, new Error("Chunk length must be " + self.chunkLength));
       }
       if (self.length === Infinity) {
         self.files[0].open(function(err, file) {
           if (err)
             return cb(err);
           file.write(index * self.chunkLength, buf, cb);
         });
       } else {
         const targets = self.chunkMap[index];
         if (!targets)
           return nextTick2(cb, new Error("no files matching the request range"));
         const tasks = targets.map(function(target) {
           return function(cb2) {
             target.file.open(function(err, file) {
               if (err)
                 return cb2(err);
               file.write(target.offset, buf.slice(target.from, target.to), cb2);
             });
           };
         });
         parallel2(tasks, cb);
       }
     };
     Storage2.prototype.get = function(index, opts, cb) {
       const self = this;
       if (typeof opts === "function")
         return self.get(index, null, opts);
       if (self.closed)
         return nextTick2(cb, new Error("Storage is closed"));
       const chunkLength = index === self.lastChunkIndex ? self.lastChunkLength : self.chunkLength;
       const rangeFrom = opts && opts.offset || 0;
       const rangeTo = opts && opts.length ? rangeFrom + opts.length : chunkLength;
       if (rangeFrom < 0 || rangeFrom < 0 || rangeTo > chunkLength) {
         return nextTick2(cb, new Error("Invalid offset and/or length"));
       }
       if (self.length === Infinity) {
         if (rangeFrom === rangeTo)
           return nextTick2(cb, null, Buffer.from(0));
         self.files[0].open(function(err, file) {
           if (err)
             return cb(err);
           const offset = index * self.chunkLength + rangeFrom;
           file.read(offset, rangeTo - rangeFrom, cb);
         });
       } else {
         let targets = self.chunkMap[index];
         if (!targets)
           return nextTick2(cb, new Error("no files matching the request range"));
         if (opts) {
           targets = targets.filter(function(target) {
             return target.to > rangeFrom && target.from < rangeTo;
           });
           if (targets.length === 0) {
             return nextTick2(cb, new Error("no files matching the requested range"));
           }
         }
         if (rangeFrom === rangeTo)
           return nextTick2(cb, null, Buffer.from(0));
         const tasks = targets.map(function(target) {
           return function(cb2) {
             let from = target.from;
             let to = target.to;
             let offset = target.offset;
             if (opts) {
               if (to > rangeTo)
                 to = rangeTo;
               if (from < rangeFrom) {
                 offset += rangeFrom - from;
                 from = rangeFrom;
               }
             }
             target.file.open(function(err, file) {
               if (err)
                 return cb2(err);
               file.read(offset, to - from, cb2);
             });
           };
         });
         parallel2(tasks, function(err, buffers) {
           if (err)
             return cb(err);
           cb(null, Buffer.concat(buffers));
         });
       }
     };
     Storage2.prototype.close = function(cb) {
       const self = this;
       if (self.closed)
         return nextTick2(cb, new Error("Storage is closed"));
       self.closed = true;
       const tasks = self.files.map(function(file) {
         return function(cb2) {
           file.open(function(err, file2) {
             if (err)
               return cb2(null);
             file2.close(cb2);
           });
         };
       });
       parallel2(tasks, cb);
     };
     Storage2.prototype.destroy = function(cb) {
       const self = this;
       self.close(function() {
         if (self.addUID && self.path) {
           fs2.rm(path2.resolve(path2.join(self.path, self.name)), { recursive: true, maxBusyTries: 10 }, cb);
         } else {
           const tasks = self.files.map(function(file) {
             return function(cb2) {
               fs2.rm(file.path, { recursive: true, maxRetries: 10 }, (err) => {
                 err && err.code === "ENOENT" ? cb2() : cb2(err);
               });
             };
           });
           parallel2(tasks, cb);
         }
       });
     };
     function nextTick2(cb, err, val) {
       queueMicrotask3(function() {
         if (cb)
           cb(err, val);
       });
     }
     function noop2() {
     }
   }
 });
 
 // node_modules/immediate-chunk-store/index.js
 var require_immediate_chunk_store = __commonJS({
   "node_modules/immediate-chunk-store/index.js"(exports, module2) {
     var queueMicrotask3 = require_queue_microtask();
     var ImmediateStore = class {
       constructor(store) {
         this.store = store;
         this.chunkLength = store.chunkLength;
         if (!this.store || !this.store.get || !this.store.put) {
           throw new Error("First argument must be abstract-chunk-store compliant");
         }
         this.mem = [];
       }
       put(index, buf, cb = () => {
       }) {
         this.mem[index] = buf;
         this.store.put(index, buf, (err) => {
           this.mem[index] = null;
           cb(err);
         });
       }
       get(index, opts, cb = () => {
       }) {
         if (typeof opts === "function")
           return this.get(index, null, opts);
         let buf = this.mem[index];
         if (!buf) {
           return this.store.get(index, opts, cb);
         }
         if (!opts)
           opts = {};
         const offset = opts.offset || 0;
         const len = opts.length || buf.length - offset;
         if (offset !== 0 || len !== buf.length) {
           buf = buf.slice(offset, len + offset);
         }
         queueMicrotask3(() => cb(null, buf));
       }
       close(cb = () => {
       }) {
         this.store.close(cb);
       }
       destroy(cb = () => {
       }) {
         this.store.destroy(cb);
       }
     };
     module2.exports = ImmediateStore;
   }
 });
 
 // node_modules/lt_donthave/index.js
 var require_lt_donthave = __commonJS({
   "node_modules/lt_donthave/index.js"(exports, module2) {
     var arrayRemove = require_unordered_array_remove();
     var { EventEmitter } = require("events");
     var debug = require_src()("lt_donthave");
     module2.exports = () => {
       class ltDontHave extends EventEmitter {
         constructor(wire) {
           super();
           this._peerSupports = false;
           this._wire = wire;
         }
         onExtendedHandshake() {
           this._peerSupports = true;
         }
         onMessage(buf) {
           let index;
           try {
             index = buf.readUInt32BE();
           } catch (err) {
             return;
           }
           if (!this._wire.peerPieces.get(index))
             return;
           debug("got donthave %d", index);
           this._wire.peerPieces.set(index, false);
           this.emit("donthave", index);
           this._failRequests(index);
         }
         donthave(index) {
           if (!this._peerSupports)
             return;
           debug("donthave %d", index);
           const buf = Buffer.alloc(4);
           buf.writeUInt32BE(index);
           this._wire.extended("lt_donthave", buf);
         }
         _failRequests(index) {
           const requests = this._wire.requests;
           for (let i = 0; i < requests.length; i++) {
             const req = requests[i];
             if (req.piece === index) {
               arrayRemove(requests, i);
               i -= 1;
               this._wire._callback(req, new Error("peer sent donthave"), null);
             }
           }
         }
       }
       ltDontHave.prototype.name = "lt_donthave";
       return ltDontHave;
     };
   }
 });
 
 // node_modules/memory-chunk-store/index.js
 var require_memory_chunk_store = __commonJS({
   "node_modules/memory-chunk-store/index.js"(exports, module2) {
     module2.exports = Storage2;
     var queueMicrotask3 = require_queue_microtask();
     function Storage2(chunkLength, opts) {
       if (!(this instanceof Storage2))
         return new Storage2(chunkLength, opts);
       if (!opts)
         opts = {};
       this.chunkLength = Number(chunkLength);
       if (!this.chunkLength)
         throw new Error("First argument must be a chunk length");
       this.chunks = [];
       this.closed = false;
       this.length = Number(opts.length) || Infinity;
       if (this.length !== Infinity) {
         this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
         this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1;
       }
     }
     Storage2.prototype.put = function(index, buf, cb = () => {
     }) {
       if (this.closed)
         return queueMicrotask3(() => cb(new Error("Storage is closed")));
       const isLastChunk = index === this.lastChunkIndex;
       if (isLastChunk && buf.length !== this.lastChunkLength) {
         return queueMicrotask3(() => cb(new Error("Last chunk length must be " + this.lastChunkLength)));
       }
       if (!isLastChunk && buf.length !== this.chunkLength) {
         return queueMicrotask3(() => cb(new Error("Chunk length must be " + this.chunkLength)));
       }
       this.chunks[index] = buf;
       queueMicrotask3(() => cb(null));
     };
     Storage2.prototype.get = function(index, opts, cb = () => {
     }) {
       if (typeof opts === "function")
         return this.get(index, null, opts);
       if (this.closed)
         return queueMicrotask3(() => cb(new Error("Storage is closed")));
       let buf = this.chunks[index];
       if (!buf) {
         const err = new Error("Chunk not found");
         err.notFound = true;
         return queueMicrotask3(() => cb(err));
       }
       if (!opts)
         opts = {};
       const offset = opts.offset || 0;
       const len = opts.length || buf.length - offset;
       if (offset !== 0 || len !== buf.length) {
         buf = buf.slice(offset, len + offset);
       }
       queueMicrotask3(() => cb(null, buf));
     };
     Storage2.prototype.close = Storage2.prototype.destroy = function(cb = () => {
     }) {
       if (this.closed)
         return queueMicrotask3(() => cb(new Error("Storage is closed")));
       this.closed = true;
       this.chunks = null;
       queueMicrotask3(() => cb(null));
     };
   }
 });
 
 // node_modules/run-parallel-limit/index.js
 var require_run_parallel_limit = __commonJS({
   "node_modules/run-parallel-limit/index.js"(exports, module2) {
     module2.exports = runParallelLimit;
     var queueMicrotask3 = require_queue_microtask();
     function runParallelLimit(tasks, limit, cb) {
       if (typeof limit !== "number")
         throw new Error("second argument must be a Number");
       let results, len, pending, keys, isErrored;
       let isSync = true;
       let next;
       if (Array.isArray(tasks)) {
         results = [];
         pending = len = tasks.length;
       } else {
         keys = Object.keys(tasks);
         results = {};
         pending = len = keys.length;
       }
       function done(err) {
         function end() {
           if (cb)
             cb(err, results);
           cb = null;
         }
         if (isSync)
           queueMicrotask3(end);
         else
           end();
       }
       function each(i, err, result) {
         results[i] = result;
         if (err)
           isErrored = true;
         if (--pending === 0 || err) {
           done(err);
         } else if (!isErrored && next < len) {
           let key;
           if (keys) {
             key = keys[next];
             next += 1;
             tasks[key](function(err2, result2) {
               each(key, err2, result2);
             });
           } else {
             key = next;
             next += 1;
             tasks[key](function(err2, result2) {
               each(key, err2, result2);
             });
           }
         }
       }
       next = limit;
       if (!pending) {
         done(null);
       } else if (keys) {
         keys.some(function(key, i) {
           tasks[key](function(err, result) {
             each(key, err, result);
           });
           if (i === limit - 1)
             return true;
           return false;
         });
       } else {
         tasks.some(function(task, i) {
           task(function(err, result) {
             each(i, err, result);
           });
           if (i === limit - 1)
             return true;
           return false;
         });
       }
       isSync = false;
     }
   }
 });
 
 // node_modules/torrent-piece/index.js
 var require_torrent_piece = __commonJS({
   "node_modules/torrent-piece/index.js"(exports, module2) {
     var BLOCK_LENGTH = 1 << 14;
     var Piece = class {
       constructor(length) {
         this.length = length;
         this.missing = length;
         this.sources = null;
         this._chunks = Math.ceil(length / BLOCK_LENGTH);
         this._remainder = length % BLOCK_LENGTH || BLOCK_LENGTH;
         this._buffered = 0;
         this._buffer = null;
         this._cancellations = null;
         this._reservations = 0;
         this._flushed = false;
       }
       chunkLength(i) {
         return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH;
       }
       chunkLengthRemaining(i) {
         return this.length - i * BLOCK_LENGTH;
       }
       chunkOffset(i) {
         return i * BLOCK_LENGTH;
       }
       reserve() {
         if (!this.init())
           return -1;
         if (this._cancellations.length)
           return this._cancellations.pop();
         if (this._reservations < this._chunks)
           return this._reservations++;
         return -1;
       }
       reserveRemaining() {
         if (!this.init())
           return -1;
         if (this._cancellations.length || this._reservations < this._chunks) {
           let min = this._reservations;
           while (this._cancellations.length) {
             min = Math.min(min, this._cancellations.pop());
           }
           this._reservations = this._chunks;
           return min;
         }
         return -1;
       }
       cancel(i) {
         if (!this.init())
           return;
         this._cancellations.push(i);
       }
       cancelRemaining(i) {
         if (!this.init())
           return;
         this._reservations = i;
       }
       get(i) {
         if (!this.init())
           return null;
         return this._buffer[i];
       }
       set(i, data, source) {
         if (!this.init())
           return false;
         const len = data.length;
         const blocks = Math.ceil(len / BLOCK_LENGTH);
         for (let j = 0; j < blocks; j++) {
           if (!this._buffer[i + j]) {
             const offset = j * BLOCK_LENGTH;
             const splitData = data.slice(offset, offset + BLOCK_LENGTH);
             this._buffered++;
             this._buffer[i + j] = splitData;
             this.missing -= splitData.length;
             if (!this.sources.includes(source)) {
               this.sources.push(source);
             }
           }
         }
         return this._buffered === this._chunks;
       }
       flush() {
         if (!this._buffer || this._chunks !== this._buffered)
           return null;
         const buffer = Buffer.concat(this._buffer, this.length);
         this._buffer = null;
         this._cancellations = null;
         this.sources = null;
         this._flushed = true;
         return buffer;
       }
       init() {
         if (this._flushed)
           return false;
         if (this._buffer)
           return true;
         this._buffer = new Array(this._chunks);
         this._cancellations = [];
         this.sources = [];
         return true;
       }
     };
     Object.defineProperty(Piece, "BLOCK_LENGTH", { value: BLOCK_LENGTH });
     module2.exports = Piece;
   }
 });
 
 // node_modules/end-of-stream/index.js
 var require_end_of_stream2 = __commonJS({
   "node_modules/end-of-stream/index.js"(exports, module2) {
     var once = require_once();
     var noop2 = function() {
     };
     var isRequest = function(stream) {
       return stream.setHeader && typeof stream.abort === "function";
     };
     var isChildProcess = function(stream) {
       return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
     };
     var eos = function(stream, opts, callback) {
       if (typeof opts === "function")
         return eos(stream, null, opts);
       if (!opts)
         opts = {};
       callback = once(callback || noop2);
       var ws = stream._writableState;
       var rs = stream._readableState;
       var readable = opts.readable || opts.readable !== false && stream.readable;
       var writable = opts.writable || opts.writable !== false && stream.writable;
       var cancelled = false;
       var onlegacyfinish = function() {
         if (!stream.writable)
           onfinish();
       };
       var onfinish = function() {
         writable = false;
         if (!readable)
           callback.call(stream);
       };
       var onend = function() {
         readable = false;
         if (!writable)
           callback.call(stream);
       };
       var onexit = function(exitCode) {
         callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
       };
       var onerror = function(err) {
         callback.call(stream, err);
       };
       var onclose = function() {
         process.nextTick(onclosenexttick);
       };
       var onclosenexttick = function() {
         if (cancelled)
           return;
         if (readable && !(rs && (rs.ended && !rs.destroyed)))
           return callback.call(stream, new Error("premature close"));
         if (writable && !(ws && (ws.ended && !ws.destroyed)))
           return callback.call(stream, new Error("premature close"));
       };
       var onrequest = function() {
         stream.req.on("finish", onfinish);
       };
       if (isRequest(stream)) {
         stream.on("complete", onfinish);
         stream.on("abort", onclose);
         if (stream.req)
           onrequest();
         else
           stream.on("request", onrequest);
       } else if (writable && !ws) {
         stream.on("end", onlegacyfinish);
         stream.on("close", onlegacyfinish);
       }
       if (isChildProcess(stream))
         stream.on("exit", onexit);
       stream.on("end", onend);
       stream.on("finish", onfinish);
       if (opts.error !== false)
         stream.on("error", onerror);
       stream.on("close", onclose);
       return function() {
         cancelled = true;
         stream.removeListener("complete", onfinish);
         stream.removeListener("abort", onclose);
         stream.removeListener("request", onrequest);
         if (stream.req)
           stream.req.removeListener("finish", onfinish);
         stream.removeListener("end", onlegacyfinish);
         stream.removeListener("close", onlegacyfinish);
         stream.removeListener("finish", onfinish);
         stream.removeListener("exit", onexit);
         stream.removeListener("end", onend);
         stream.removeListener("error", onerror);
         stream.removeListener("close", onclose);
       };
     };
     module2.exports = eos;
   }
 });
 
 // node_modules/pump/index.js
 var require_pump = __commonJS({
   "node_modules/pump/index.js"(exports, module2) {
     var once = require_once();
     var eos = require_end_of_stream2();
     var fs2 = require("fs");
     var noop2 = function() {
     };
     var ancient = /^v?\.0/.test(process.version);
     var isFn = function(fn) {
       return typeof fn === "function";
     };
     var isFS = function(stream) {
       if (!ancient)
         return false;
       if (!fs2)
         return false;
       return (stream instanceof (fs2.ReadStream || noop2) || stream instanceof (fs2.WriteStream || noop2)) && isFn(stream.close);
     };
     var isRequest = function(stream) {
       return stream.setHeader && isFn(stream.abort);
     };
     var destroyer = function(stream, reading, writing, callback) {
       callback = once(callback);
       var closed = false;
       stream.on("close", function() {
         closed = true;
       });
       eos(stream, { readable: reading, writable: writing }, function(err) {
         if (err)
           return callback(err);
         closed = true;
         callback();
       });
       var destroyed = false;
       return function(err) {
         if (closed)
           return;
         if (destroyed)
           return;
         destroyed = true;
         if (isFS(stream))
           return stream.close(noop2);
         if (isRequest(stream))
           return stream.abort();
         if (isFn(stream.destroy))
           return stream.destroy();
         callback(err || new Error("stream was destroyed"));
       };
     };
     var call = function(fn) {
       fn();
     };
     var pipe = function(from, to) {
       return from.pipe(to);
     };
     var pump = function() {
       var streams = Array.prototype.slice.call(arguments);
       var callback = isFn(streams[streams.length - 1] || noop2) && streams.pop() || noop2;
       if (Array.isArray(streams[0]))
         streams = streams[0];
       if (streams.length < 2)
         throw new Error("pump requires two streams per minimum");
       var error;
       var destroys = streams.map(function(stream, i) {
         var reading = i < streams.length - 1;
         var writing = i > 0;
         return destroyer(stream, reading, writing, function(err) {
           if (!error)
             error = err;
           if (err)
             destroys.forEach(call);
           if (reading)
             return;
           destroys.forEach(call);
           callback(error);
         });
       });
       return streams.reduce(pipe);
     };
     module2.exports = pump;
   }
 });
 
 // node_modules/random-iterate/index.js
 var require_random_iterate = __commonJS({
   "node_modules/random-iterate/index.js"(exports, module2) {
     var iterate = function(list) {
       var offset = 0;
       return function() {
         if (offset === list.length)
           return null;
         var len = list.length - offset;
         var i = Math.random() * len | 0;
         var el = list[offset + i];
         var tmp = list[offset];
         list[offset] = el;
         list[offset + i] = tmp;
         offset++;
         return el;
       };
     };
     module2.exports = iterate;
   }
 });
 
 // node_modules/ut_metadata/index.js
 var require_ut_metadata = __commonJS({
   "node_modules/ut_metadata/index.js"(exports, module2) {
     var { EventEmitter } = require("events");
     var bencode = require_lib();
     var BitField = require_lib2().default;
     var debug = require_src()("ut_metadata");
     var sha1 = require_simple_sha1();
     var MAX_METADATA_SIZE = 1e7;
     var BITFIELD_GROW = 1e3;
     var PIECE_LENGTH = 1 << 14;
     module2.exports = (metadata) => {
       class utMetadata extends EventEmitter {
         constructor(wire) {
           super();
           this._wire = wire;
           this._fetching = false;
           this._metadataComplete = false;
           this._metadataSize = null;
           this._remainingRejects = null;
           this._bitfield = new BitField(0, { grow: BITFIELD_GROW });
           if (Buffer.isBuffer(metadata)) {
             this.setMetadata(metadata);
           }
         }
         onHandshake(infoHash, peerId, extensions) {
           this._infoHash = infoHash;
         }
         onExtendedHandshake(handshake) {
           if (!handshake.m || !handshake.m.ut_metadata) {
             return this.emit("warning", new Error("Peer does not support ut_metadata"));
           }
           if (!handshake.metadata_size) {
             return this.emit("warning", new Error("Peer does not have metadata"));
           }
           if (typeof handshake.metadata_size !== "number" || MAX_METADATA_SIZE < handshake.metadata_size || handshake.metadata_size <= 0) {
             return this.emit("warning", new Error("Peer gave invalid metadata size"));
           }
           this._metadataSize = handshake.metadata_size;
           this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH);
           this._remainingRejects = this._numPieces * 2;
           this._requestPieces();
         }
         onMessage(buf) {
           let dict;
           let trailer;
           try {
             const str = buf.toString();
             const trailerIndex = str.indexOf("ee") + 2;
             dict = bencode.decode(str.substring(0, trailerIndex));
             trailer = buf.slice(trailerIndex);
           } catch (err) {
             return;
           }
           switch (dict.msg_type) {
             case 0:
               this._onRequest(dict.piece);
               break;
             case 1:
               this._onData(dict.piece, trailer, dict.total_size);
               break;
             case 2:
               this._onReject(dict.piece);
               break;
           }
         }
         fetch() {
           if (this._metadataComplete) {
             return;
           }
           this._fetching = true;
           if (this._metadataSize) {
             this._requestPieces();
           }
         }
         cancel() {
           this._fetching = false;
         }
         setMetadata(metadata2) {
           if (this._metadataComplete)
             return true;
           debug("set metadata");
           try {
             const info = bencode.decode(metadata2).info;
             if (info) {
               metadata2 = bencode.encode(info);
             }
           } catch (err) {
           }
           if (this._infoHash && this._infoHash !== sha1.sync(metadata2)) {
             return false;
           }
           this.cancel();
           this.metadata = metadata2;
           this._metadataComplete = true;
           this._metadataSize = this.metadata.length;
           this._wire.extendedHandshake.metadata_size = this._metadataSize;
           this.emit("metadata", bencode.encode({
             info: bencode.decode(this.metadata)
           }));
           return true;
         }
         _send(dict, trailer) {
           let buf = bencode.encode(dict);
           if (Buffer.isBuffer(trailer)) {
             buf = Buffer.concat([buf, trailer]);
           }
           this._wire.extended("ut_metadata", buf);
         }
         _request(piece) {
           this._send({ msg_type: 0, piece });
         }
         _data(piece, buf, totalSize) {
           const msg = { msg_type: 1, piece };
           if (typeof totalSize === "number") {
             msg.total_size = totalSize;
           }
           this._send(msg, buf);
         }
         _reject(piece) {
           this._send({ msg_type: 2, piece });
         }
         _onRequest(piece) {
           if (!this._metadataComplete) {
             this._reject(piece);
             return;
           }
           const start = piece * PIECE_LENGTH;
           let end = start + PIECE_LENGTH;
           if (end > this._metadataSize) {
             end = this._metadataSize;
           }
           const buf = this.metadata.slice(start, end);
           this._data(piece, buf, this._metadataSize);
         }
         _onData(piece, buf, totalSize) {
           if (buf.length > PIECE_LENGTH || !this._fetching) {
             return;
           }
           buf.copy(this.metadata, piece * PIECE_LENGTH);
           this._bitfield.set(piece);
           this._checkDone();
         }
         _onReject(piece) {
           if (this._remainingRejects > 0 && this._fetching) {
             this._request(piece);
             this._remainingRejects -= 1;
           } else {
             this.emit("warning", new Error('Peer sent "reject" too much'));
           }
         }
         _requestPieces() {
           if (!this._fetching)
             return;
           this.metadata = Buffer.alloc(this._metadataSize);
           for (let piece = 0; piece < this._numPieces; piece++) {
             this._request(piece);
           }
         }
         _checkDone() {
           let done = true;
           for (let piece = 0; piece < this._numPieces; piece++) {
             if (!this._bitfield.get(piece)) {
               done = false;
               break;
             }
           }
           if (!done)
             return;
           const success = this.setMetadata(this.metadata);
           if (!success) {
             this._failedMetadata();
           }
         }
         _failedMetadata() {
           this._bitfield = new BitField(0, { grow: BITFIELD_GROW });
           this._remainingRejects -= this._numPieces;
           if (this._remainingRejects > 0) {
             this._requestPieces();
           } else {
             this.emit("warning", new Error("Peer sent invalid metadata"));
           }
         }
       }
       utMetadata.prototype.name = "ut_metadata";
       return utMetadata;
     };
   }
 });
 
 // node_modules/string2compact/index.js
 var require_string2compact = __commonJS({
   "node_modules/string2compact/index.js"(exports, module2) {
     var addrToIPPort = require_addr_to_ip_port();
     var ipaddr = require_ipaddr();
     module2.exports = (addrs) => {
       if (typeof addrs === "string") {
         addrs = [addrs];
       }
       return Buffer.concat(addrs.map((addr) => {
         const s = addrToIPPort(addr);
         if (s.length !== 2) {
           throw new Error("invalid address format, expecting: 10.10.10.5:128");
         }
         const ip = ipaddr.parse(s[0]);
         const ipBuf = Buffer.from(ip.toByteArray());
         const port = s[1];
         const portBuf = Buffer.allocUnsafe(2);
         portBuf.writeUInt16BE(port, 0);
         return Buffer.concat([ipBuf, portBuf]);
       }));
     };
     module2.exports.multi = module2.exports;
     module2.exports.multi6 = module2.exports;
   }
 });
 
 // node_modules/ut_pex/index.js
 var require_ut_pex = __commonJS({
   "node_modules/ut_pex/index.js"(exports, module2) {
     var EventEmitter = require("events").EventEmitter;
     var compact2string = require_compact2string();
     var string2compact = require_string2compact();
     var bencode = require_lib();
     var PEX_INTERVAL = 65e3;
     var PEX_MAX_PEERS = 50;
     var PEX_MIN_ALLOWED_INTERVAL = 6e4;
     var FLAGS = {
       prefersEncryption: 1,
       isSender: 2,
       supportsUtp: 4,
       supportsUtHolepunch: 8,
       isReachable: 16
     };
     module2.exports = () => {
       class utPex extends EventEmitter {
         constructor(wire) {
           super();
           this._wire = wire;
           this._intervalId = null;
           this._lastMessageTimestamp = 0;
           this.reset();
         }
         start() {
           clearInterval(this._intervalId);
           this._intervalId = setInterval(() => this._sendMessage(), PEX_INTERVAL);
           if (this._intervalId.unref)
             this._intervalId.unref();
         }
         stop() {
           clearInterval(this._intervalId);
           this._intervalId = null;
         }
         reset() {
           this._remoteAddedPeers = {};
           this._remoteDroppedPeers = {};
           this._localAddedPeers = {};
           this._localDroppedPeers = {};
           this.stop();
         }
         addPeer(peer, flags = {}) {
           this._addPeer(peer, this._encodeFlags(flags), 4);
         }
         addPeer6(peer, flags = {}) {
           this._addPeer(peer, this._encodeFlags(flags), 6);
         }
         _addPeer(peer, flags, version) {
           if (!peer.includes(":"))
             return;
           if (peer in this._remoteAddedPeers)
             return;
           if (peer in this._localDroppedPeers)
             delete this._localDroppedPeers[peer];
           this._localAddedPeers[peer] = { ip: version, flags };
         }
         dropPeer(peer) {
           this._dropPeer(peer, 4);
         }
         dropPeer6(peer) {
           this._dropPeer(peer, 6);
         }
         _dropPeer(peer, version) {
           if (!peer.includes(":"))
             return;
           if (peer in this._remoteDroppedPeers)
             return;
           if (peer in this._localAddedPeers)
             delete this._localAddedPeers[peer];
           this._localDroppedPeers[peer] = { ip: version };
         }
         onExtendedHandshake(handshake) {
           if (!handshake.m || !handshake.m.ut_pex) {
             return this.emit("warning", new Error("Peer does not support ut_pex"));
           }
         }
         onMessage(buf) {
           const currentMessageTimestamp = Date.now();
           if (currentMessageTimestamp - this._lastMessageTimestamp < PEX_MIN_ALLOWED_INTERVAL) {
             this.reset();
             this._wire.destroy();
             return this.emit("warning", new Error("Peer disconnected for sending PEX messages too frequently"));
           } else {
             this._lastMessageTimestamp = currentMessageTimestamp;
           }
           let message;
           try {
             message = bencode.decode(buf);
             if (message.added) {
               compact2string.multi(message.added).forEach((peer, idx) => {
                 delete this._remoteDroppedPeers[peer];
                 if (!(peer in this._remoteAddedPeers)) {
                   const flags = message["added.f"][idx];
                   this._remoteAddedPeers[peer] = { ip: 4, flags };
                   this.emit("peer", peer, this._decodeFlags(flags));
                 }
               });
             }
             if (message.added6) {
               compact2string.multi6(message.added6).forEach((peer, idx) => {
                 delete this._remoteDroppedPeers[peer];
                 if (!(peer in this._remoteAddedPeers)) {
                   const flags = message["added6.f"][idx];
                   this._remoteAddedPeers[peer] = { ip: 6, flags };
                   this.emit("peer", peer, this._decodeFlags(flags));
                 }
               });
             }
             if (message.dropped) {
               compact2string.multi(message.dropped).forEach((peer) => {
                 delete this._remoteAddedPeers[peer];
                 if (!(peer in this._remoteDroppedPeers)) {
                   this._remoteDroppedPeers[peer] = { ip: 4 };
                   this.emit("dropped", peer);
                 }
               });
             }
             if (message.dropped6) {
               compact2string.multi6(message.dropped6).forEach((peer) => {
                 delete this._remoteAddedPeers[peer];
                 if (!(peer in this._remoteDroppedPeers)) {
                   this._remoteDroppedPeers[peer] = { ip: 6 };
                   this.emit("dropped", peer);
                 }
               });
             }
           } catch (err) {
           }
         }
         _decodeFlags(flags) {
           return {
             prefersEncryption: !!(flags & FLAGS.prefersEncryption),
             isSender: !!(flags & FLAGS.isSender),
             supportsUtp: !!(flags & FLAGS.supportsUtp),
             supportsUtHolepunch: !!(flags & FLAGS.supportsUtHolepunch),
             isReachable: !!(flags & FLAGS.isReachable)
           };
         }
         _encodeFlags(flags) {
           return Object.keys(flags).reduce((acc, cur) => flags[cur] === true ? acc | FLAGS[cur] : acc, 0);
         }
         _sendMessage() {
           const localAdded = Object.keys(this._localAddedPeers).slice(0, PEX_MAX_PEERS);
           const localDropped = Object.keys(this._localDroppedPeers).slice(0, PEX_MAX_PEERS);
           const _isIPv4 = (peers, addr) => peers[addr].ip === 4;
           const _isIPv6 = (peers, addr) => peers[addr].ip === 6;
           const _flags = (peers, addr) => peers[addr].flags;
           const added = string2compact(
             localAdded.filter((k) => _isIPv4(this._localAddedPeers, k))
           );
           const added6 = string2compact(
             localAdded.filter((k) => _isIPv6(this._localAddedPeers, k))
           );
           const dropped = string2compact(
             localDropped.filter((k) => _isIPv4(this._localDroppedPeers, k))
           );
           const dropped6 = string2compact(
             localDropped.filter((k) => _isIPv6(this._localDroppedPeers, k))
           );
           const addedFlags = Buffer.from(
             localAdded.filter((k) => _isIPv4(this._localAddedPeers, k)).map((k) => _flags(this._localAddedPeers, k))
           );
           const added6Flags = Buffer.from(
             localAdded.filter((k) => _isIPv6(this._localAddedPeers, k)).map((k) => _flags(this._localAddedPeers, k))
           );
           localAdded.forEach((peer) => delete this._localAddedPeers[peer]);
           localDropped.forEach((peer) => delete this._localDroppedPeers[peer]);
           this._wire.extended("ut_pex", {
             added,
             "added.f": addedFlags,
             dropped,
             added6,
             "added6.f": added6Flags,
             dropped6
           });
         }
       }
       utPex.prototype.name = "ut_pex";
       return utPex;
     };
   }
 });
 
 // node_modules/render-media/lib/mime.json
 var require_mime = __commonJS({
   "node_modules/render-media/lib/mime.json"(exports, module2) {
     module2.exports = {
       ".3gp": "video/3gpp",
       ".aac": "audio/aac",
       ".aif": "audio/x-aiff",
       ".aiff": "audio/x-aiff",
       ".atom": "application/atom+xml",
       ".avi": "video/x-msvideo",
       ".bmp": "image/bmp",
       ".bz2": "application/x-bzip2",
       ".conf": "text/plain",
       ".css": "text/css",
       ".csv": "text/plain",
       ".diff": "text/x-diff",
       ".doc": "application/msword",
       ".flv": "video/x-flv",
       ".gif": "image/gif",
       ".gz": "application/x-gzip",
       ".htm": "text/html",
       ".html": "text/html",
       ".ico": "image/vnd.microsoft.icon",
       ".ics": "text/calendar",
       ".iso": "application/octet-stream",
       ".jar": "application/java-archive",
       ".jpeg": "image/jpeg",
       ".jpg": "image/jpeg",
       ".js": "application/javascript",
       ".json": "application/json",
       ".less": "text/css",
       ".log": "text/plain",
       ".m3u": "audio/x-mpegurl",
       ".m4a": "audio/x-m4a",
       ".m4b": "audio/mp4",
       ".m4p": "audio/mp4",
       ".m4v": "video/x-m4v",
       ".manifest": "text/cache-manifest",
       ".markdown": "text/x-markdown",
       ".mathml": "application/mathml+xml",
       ".md": "text/x-markdown",
       ".mid": "audio/midi",
       ".midi": "audio/midi",
       ".mov": "video/quicktime",
       ".mp3": "audio/mpeg",
       ".mp4": "video/mp4",
       ".mp4v": "video/mp4",
       ".mpeg": "video/mpeg",
       ".mpg": "video/mpeg",
       ".odp": "application/vnd.oasis.opendocument.presentation",
       ".ods": "application/vnd.oasis.opendocument.spreadsheet",
       ".odt": "application/vnd.oasis.opendocument.text",
       ".oga": "audio/ogg",
       ".ogg": "application/ogg",
       ".pdf": "application/pdf",
       ".png": "image/png",
       ".pps": "application/vnd.ms-powerpoint",
       ".ppt": "application/vnd.ms-powerpoint",
       ".ps": "application/postscript",
       ".psd": "image/vnd.adobe.photoshop",
       ".qt": "video/quicktime",
       ".rar": "application/x-rar-compressed",
       ".rdf": "application/rdf+xml",
       ".rss": "application/rss+xml",
       ".rtf": "application/rtf",
       ".svg": "image/svg+xml",
       ".svgz": "image/svg+xml",
       ".swf": "application/x-shockwave-flash",
       ".tar": "application/x-tar",
       ".tbz": "application/x-bzip-compressed-tar",
       ".text": "text/plain",
       ".tif": "image/tiff",
       ".tiff": "image/tiff",
       ".torrent": "application/x-bittorrent",
       ".ttf": "application/x-font-ttf",
       ".txt": "text/plain",
       ".wav": "audio/wav",
       ".webm": "video/webm",
       ".wma": "audio/x-ms-wma",
       ".wmv": "video/x-ms-wmv",
       ".xls": "application/vnd.ms-excel",
       ".xml": "application/xml",
       ".yaml": "text/yaml",
       ".yml": "text/yaml",
       ".zip": "application/zip"
     };
   }
 });
 
 // node_modules/is-ascii/index.js
 var require_is_ascii = __commonJS({
   "node_modules/is-ascii/index.js"(exports, module2) {
     var MAX_ASCII_CHAR_CODE = 127;
     module2.exports = function isAscii(str) {
       for (var i = 0, strLen = str.length; i < strLen; ++i) {
         if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE)
           return false;
       }
       return true;
     };
   }
 });
 
 // node_modules/to-arraybuffer/index.js
 var require_to_arraybuffer = __commonJS({
   "node_modules/to-arraybuffer/index.js"(exports, module2) {
     var Buffer2 = require("buffer").Buffer;
     module2.exports = function(buf) {
       if (buf instanceof Uint8Array) {
         if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
           return buf.buffer;
         } else if (typeof buf.buffer.slice === "function") {
           return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
         }
       }
       if (Buffer2.isBuffer(buf)) {
         var arrayCopy = new Uint8Array(buf.length);
         var len = buf.length;
         for (var i = 0; i < len; i++) {
           arrayCopy[i] = buf[i];
         }
         return arrayCopy.buffer;
       } else {
         throw new Error("Argument must be a Buffer");
       }
     };
   }
 });
 
 // node_modules/mediasource/index.js
 var require_mediasource = __commonJS({
   "node_modules/mediasource/index.js"(exports, module2) {
     module2.exports = MediaElementWrapper;
     var inherits = require_inherits();
     var stream = require_readable();
     var toArrayBuffer = require_to_arraybuffer();
     var MediaSource = typeof window !== "undefined" && window.MediaSource;
     var DEFAULT_BUFFER_DURATION = 60;
     function MediaElementWrapper(elem, opts) {
       var self = this;
       if (!(self instanceof MediaElementWrapper))
         return new MediaElementWrapper(elem, opts);
       if (!MediaSource)
         throw new Error("web browser lacks MediaSource support");
       if (!opts)
         opts = {};
       self._debug = opts.debug;
       self._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION;
       self._elem = elem;
       self._mediaSource = new MediaSource();
       self._streams = [];
       self.detailedError = null;
       self._errorHandler = function() {
         self._elem.removeEventListener("error", self._errorHandler);
         var streams = self._streams.slice();
         streams.forEach(function(stream2) {
           stream2.destroy(self._elem.error);
         });
       };
       self._elem.addEventListener("error", self._errorHandler);
       self._elem.src = window.URL.createObjectURL(self._mediaSource);
     }
     MediaElementWrapper.prototype.createWriteStream = function(obj) {
       var self = this;
       return new MediaSourceStream(self, obj);
     };
     MediaElementWrapper.prototype.error = function(err) {
       var self = this;
       if (!self.detailedError) {
         self.detailedError = err;
       }
       self._dumpDebugData();
       try {
         self._mediaSource.endOfStream("decode");
       } catch (err2) {
       }
       try {
         window.URL.revokeObjectURL(self._elem.src);
       } catch (err2) {
       }
     };
     MediaElementWrapper.prototype._dumpDebugData = function() {
       var self = this;
       if (self._debug) {
         self._debug = false;
         self._streams.forEach(function(stream2, i) {
           downloadBuffers(stream2._debugBuffers, "mediasource-stream-" + i);
         });
       }
     };
     inherits(MediaSourceStream, stream.Writable);
     function MediaSourceStream(wrapper, obj) {
       var self = this;
       stream.Writable.call(self);
       self._wrapper = wrapper;
       self._elem = wrapper._elem;
       self._mediaSource = wrapper._mediaSource;
       self._allStreams = wrapper._streams;
       self._allStreams.push(self);
       self._bufferDuration = wrapper._bufferDuration;
       self._sourceBuffer = null;
       self._debugBuffers = [];
       self._openHandler = function() {
         self._onSourceOpen();
       };
       self._flowHandler = function() {
         self._flow();
       };
       self._errorHandler = function(err) {
         if (!self.destroyed) {
           self.emit("error", err);
         }
       };
       if (typeof obj === "string") {
         self._type = obj;
         if (self._mediaSource.readyState === "open") {
           self._createSourceBuffer();
         } else {
           self._mediaSource.addEventListener("sourceopen", self._openHandler);
         }
       } else if (obj._sourceBuffer === null) {
         obj.destroy();
         self._type = obj._type;
         self._mediaSource.addEventListener("sourceopen", self._openHandler);
       } else if (obj._sourceBuffer) {
         obj.destroy();
         self._type = obj._type;
         self._sourceBuffer = obj._sourceBuffer;
         self._debugBuffers = obj._debugBuffers;
         self._sourceBuffer.addEventListener("updateend", self._flowHandler);
         self._sourceBuffer.addEventListener("error", self._errorHandler);
       } else {
         throw new Error("The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function");
       }
       self._elem.addEventListener("timeupdate", self._flowHandler);
       self.on("error", function(err) {
         self._wrapper.error(err);
       });
       self.on("finish", function() {
         if (self.destroyed)
           return;
         self._finished = true;
         if (self._allStreams.every(function(other) {
           return other._finished;
         })) {
           self._wrapper._dumpDebugData();
           try {
             self._mediaSource.endOfStream();
           } catch (err) {
           }
         }
       });
     }
     MediaSourceStream.prototype._onSourceOpen = function() {
       var self = this;
       if (self.destroyed)
         return;
       self._mediaSource.removeEventListener("sourceopen", self._openHandler);
       self._createSourceBuffer();
     };
     MediaSourceStream.prototype.destroy = function(err) {
       var self = this;
       if (self.destroyed)
         return;
       self.destroyed = true;
       self._allStreams.splice(self._allStreams.indexOf(self), 1);
       self._mediaSource.removeEventListener("sourceopen", self._openHandler);
       self._elem.removeEventListener("timeupdate", self._flowHandler);
       if (self._sourceBuffer) {
         self._sourceBuffer.removeEventListener("updateend", self._flowHandler);
         self._sourceBuffer.removeEventListener("error", self._errorHandler);
         if (self._mediaSource.readyState === "open") {
           self._sourceBuffer.abort();
         }
       }
       if (err)
         self.emit("error", err);
       self.emit("close");
     };
     MediaSourceStream.prototype._createSourceBuffer = function() {
       var self = this;
       if (self.destroyed)
         return;
       if (MediaSource.isTypeSupported(self._type)) {
         self._sourceBuffer = self._mediaSource.addSourceBuffer(self._type);
         self._sourceBuffer.addEventListener("updateend", self._flowHandler);
         self._sourceBuffer.addEventListener("error", self._errorHandler);
         if (self._cb) {
           var cb = self._cb;
           self._cb = null;
           cb();
         }
       } else {
         self.destroy(new Error("The provided type is not supported"));
       }
     };
     MediaSourceStream.prototype._write = function(chunk, encoding, cb) {
       var self = this;
       if (self.destroyed)
         return;
       if (!self._sourceBuffer) {
         self._cb = function(err) {
           if (err)
             return cb(err);
           self._write(chunk, encoding, cb);
         };
         return;
       }
       if (self._sourceBuffer.updating) {
         return cb(new Error("Cannot append buffer while source buffer updating"));
       }
       var arr = toArrayBuffer(chunk);
       if (self._wrapper._debug) {
         self._debugBuffers.push(arr);
       }
       try {
         self._sourceBuffer.appendBuffer(arr);
       } catch (err) {
         self.destroy(err);
         return;
       }
       self._cb = cb;
     };
     MediaSourceStream.prototype._flow = function() {
       var self = this;
       if (self.destroyed || !self._sourceBuffer || self._sourceBuffer.updating) {
         return;
       }
       if (self._mediaSource.readyState === "open") {
         if (self._getBufferDuration() > self._bufferDuration) {
           return;
         }
       }
       if (self._cb) {
         var cb = self._cb;
         self._cb = null;
         cb();
       }
     };
     var EPSILON = 0;
     MediaSourceStream.prototype._getBufferDuration = function() {
       var self = this;
       var buffered = self._sourceBuffer.buffered;
       var currentTime = self._elem.currentTime;
       var bufferEnd = -1;
       for (var i = 0; i < buffered.length; i++) {
         var start = buffered.start(i);
         var end = buffered.end(i) + EPSILON;
         if (start > currentTime) {
           break;
         } else if (bufferEnd >= 0 || currentTime <= end) {
           bufferEnd = end;
         }
       }
       var bufferedTime = bufferEnd - currentTime;
       if (bufferedTime < 0) {
         bufferedTime = 0;
       }
       return bufferedTime;
     };
     function downloadBuffers(bufs, name) {
       var a = document.createElement("a");
       a.href = window.URL.createObjectURL(new window.Blob(bufs));
       a.download = name;
       a.click();
     }
   }
 });
 
 // node_modules/stream-to-blob/index.js
 var require_stream_to_blob = __commonJS({
   "node_modules/stream-to-blob/index.js"(exports, module2) {
     module2.exports = streamToBlob;
     function streamToBlob(stream, mimeType) {
       if (mimeType != null && typeof mimeType !== "string") {
         throw new Error("Invalid mimetype, expected string.");
       }
       return new Promise((resolve, reject) => {
         const chunks = [];
         stream.on("data", (chunk) => chunks.push(chunk)).once("end", () => {
           const blob = mimeType != null ? new Blob(chunks, { type: mimeType }) : new Blob(chunks);
           resolve(blob);
         }).once("error", reject);
       });
     }
   }
 });
 
 // node_modules/stream-to-blob-url/index.js
 var require_stream_to_blob_url = __commonJS({
   "node_modules/stream-to-blob-url/index.js"(exports, module2) {
     module2.exports = getBlobURL;
     var getBlob = require_stream_to_blob();
     async function getBlobURL(stream, mimeType) {
       const blob = await getBlob(stream, mimeType);
       const url = URL.createObjectURL(blob);
       return url;
     }
   }
 });
 
 // node_modules/binary-search/index.js
 var require_binary_search = __commonJS({
   "node_modules/binary-search/index.js"(exports, module2) {
     module2.exports = function(haystack, needle, comparator, low, high) {
       var mid, cmp;
       if (low === void 0)
         low = 0;
       else {
         low = low | 0;
         if (low < 0 || low >= haystack.length)
           throw new RangeError("invalid lower bound");
       }
       if (high === void 0)
         high = haystack.length - 1;
       else {
         high = high | 0;
         if (high < low || high >= haystack.length)
           throw new RangeError("invalid upper bound");
       }
       while (low <= high) {
         mid = low + (high - low >>> 1);
         cmp = +comparator(haystack[mid], needle, mid, haystack);
         if (cmp < 0)
           low = mid + 1;
         else if (cmp > 0)
           high = mid - 1;
         else
           return mid;
       }
       return ~low;
     };
   }
 });
 
 // node_modules/next-event/index.js
 var require_next_event = __commonJS({
   "node_modules/next-event/index.js"(exports, module2) {
     module2.exports = nextEvent;
     function nextEvent(emitter, name) {
       var next = null;
       emitter.on(name, function(data) {
         if (!next)
           return;
         var fn = next;
         next = null;
         fn(data);
       });
       return function(once) {
         next = once;
       };
     }
   }
 });
 
 // node_modules/buffer-fill/index.js
 var require_buffer_fill = __commonJS({
   "node_modules/buffer-fill/index.js"(exports, module2) {
     var hasFullSupport = function() {
       try {
         if (!Buffer.isEncoding("latin1")) {
           return false;
         }
         var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
         buf.fill("ab", "ucs2");
         return buf.toString("hex") === "61006200";
       } catch (_) {
         return false;
       }
     }();
     function isSingleByte(val) {
       return val.length === 1 && val.charCodeAt(0) < 256;
     }
     function fillWithNumber(buffer, val, start, end) {
       if (start < 0 || end > buffer.length) {
         throw new RangeError("Out of range index");
       }
       start = start >>> 0;
       end = end === void 0 ? buffer.length : end >>> 0;
       if (end > start) {
         buffer.fill(val, start, end);
       }
       return buffer;
     }
     function fillWithBuffer(buffer, val, start, end) {
       if (start < 0 || end > buffer.length) {
         throw new RangeError("Out of range index");
       }
       if (end <= start) {
         return buffer;
       }
       start = start >>> 0;
       end = end === void 0 ? buffer.length : end >>> 0;
       var pos = start;
       var len = val.length;
       while (pos <= end - len) {
         val.copy(buffer, pos);
         pos += len;
       }
       if (pos !== end) {
         val.copy(buffer, pos, 0, end - pos);
       }
       return buffer;
     }
     function fill(buffer, val, start, end, encoding) {
       if (hasFullSupport) {
         return buffer.fill(val, start, end, encoding);
       }
       if (typeof val === "number") {
         return fillWithNumber(buffer, val, start, end);
       }
       if (typeof val === "string") {
         if (typeof start === "string") {
           encoding = start;
           start = 0;
           end = buffer.length;
         } else if (typeof end === "string") {
           encoding = end;
           end = buffer.length;
         }
         if (encoding !== void 0 && typeof encoding !== "string") {
           throw new TypeError("encoding must be a string");
         }
         if (encoding === "latin1") {
           encoding = "binary";
         }
         if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
           throw new TypeError("Unknown encoding: " + encoding);
         }
         if (val === "") {
           return fillWithNumber(buffer, 0, start, end);
         }
         if (isSingleByte(val)) {
           return fillWithNumber(buffer, val.charCodeAt(0), start, end);
         }
         val = new Buffer(val, encoding);
       }
       if (Buffer.isBuffer(val)) {
         return fillWithBuffer(buffer, val, start, end);
       }
       return fillWithNumber(buffer, 0, start, end);
     }
     module2.exports = fill;
   }
 });
 
 // node_modules/buffer-alloc-unsafe/index.js
 var require_buffer_alloc_unsafe = __commonJS({
   "node_modules/buffer-alloc-unsafe/index.js"(exports, module2) {
     function allocUnsafe(size) {
       if (typeof size !== "number") {
         throw new TypeError('"size" argument must be a number');
       }
       if (size < 0) {
         throw new RangeError('"size" argument must not be negative');
       }
       if (Buffer.allocUnsafe) {
         return Buffer.allocUnsafe(size);
       } else {
         return new Buffer(size);
       }
     }
     module2.exports = allocUnsafe;
   }
 });
 
 // node_modules/buffer-alloc/index.js
 var require_buffer_alloc = __commonJS({
   "node_modules/buffer-alloc/index.js"(exports, module2) {
     var bufferFill = require_buffer_fill();
     var allocUnsafe = require_buffer_alloc_unsafe();
     module2.exports = function alloc(size, fill, encoding) {
       if (typeof size !== "number") {
         throw new TypeError('"size" argument must be a number');
       }
       if (size < 0) {
         throw new RangeError('"size" argument must not be negative');
       }
       if (Buffer.alloc) {
         return Buffer.alloc(size, fill, encoding);
       }
       var buffer = allocUnsafe(size);
       if (size === 0) {
         return buffer;
       }
       if (fill === void 0) {
         return bufferFill(buffer, 0);
       }
       if (typeof encoding !== "string") {
         encoding = void 0;
       }
       return bufferFill(buffer, fill, encoding);
     };
   }
 });
 
 // node_modules/uint64be/index.js
 var require_uint64be = __commonJS({
   "node_modules/uint64be/index.js"(exports) {
     var bufferAlloc = require_buffer_alloc();
     var UINT_32_MAX = Math.pow(2, 32);
     exports.encodingLength = function() {
       return 8;
     };
     exports.encode = function(num, buf, offset) {
       if (!buf)
         buf = bufferAlloc(8);
       if (!offset)
         offset = 0;
       var top = Math.floor(num / UINT_32_MAX);
       var rem = num - top * UINT_32_MAX;
       buf.writeUInt32BE(top, offset);
       buf.writeUInt32BE(rem, offset + 4);
       return buf;
     };
     exports.decode = function(buf, offset) {
       if (!offset)
         offset = 0;
       var top = buf.readUInt32BE(offset);
       var rem = buf.readUInt32BE(offset + 4);
       return top * UINT_32_MAX + rem;
     };
     exports.encode.bytes = 8;
     exports.decode.bytes = 8;
   }
 });
 
 // node_modules/mp4-box-encoding/descriptor.js
 var require_descriptor = __commonJS({
   "node_modules/mp4-box-encoding/descriptor.js"(exports) {
     var tagToName = {
       3: "ESDescriptor",
       4: "DecoderConfigDescriptor",
       5: "DecoderSpecificInfo",
       6: "SLConfigDescriptor"
     };
     exports.Descriptor = {};
     exports.Descriptor.decode = function(buf, start, end) {
       var tag = buf.readUInt8(start);
       var ptr = start + 1;
       var lenByte;
       var len = 0;
       do {
         lenByte = buf.readUInt8(ptr++);
         len = len << 7 | lenByte & 127;
       } while (lenByte & 128);
       var obj;
       var tagName = tagToName[tag];
       if (exports[tagName]) {
         obj = exports[tagName].decode(buf, ptr, end);
       } else {
         obj = {
           buffer: Buffer.from(buf.slice(ptr, ptr + len))
         };
       }
       obj.tag = tag;
       obj.tagName = tagName;
       obj.length = ptr - start + len;
       obj.contentsLen = len;
       return obj;
     };
     exports.DescriptorArray = {};
     exports.DescriptorArray.decode = function(buf, start, end) {
       var ptr = start;
       var obj = {};
       while (ptr + 2 <= end) {
         var descriptor = exports.Descriptor.decode(buf, ptr, end);
         ptr += descriptor.length;
         var tagName = tagToName[descriptor.tag] || "Descriptor" + descriptor.tag;
         obj[tagName] = descriptor;
       }
       return obj;
     };
     exports.ESDescriptor = {};
     exports.ESDescriptor.decode = function(buf, start, end) {
       var flags = buf.readUInt8(start + 2);
       var ptr = start + 3;
       if (flags & 128) {
         ptr += 2;
       }
       if (flags & 64) {
         var len = buf.readUInt8(ptr);
         ptr += len + 1;
       }
       if (flags & 32) {
         ptr += 2;
       }
       return exports.DescriptorArray.decode(buf, ptr, end);
     };
     exports.DecoderConfigDescriptor = {};
     exports.DecoderConfigDescriptor.decode = function(buf, start, end) {
       var oti = buf.readUInt8(start);
       var obj = exports.DescriptorArray.decode(buf, start + 13, end);
       obj.oti = oti;
       return obj;
     };
   }
 });
 
 // node_modules/mp4-box-encoding/boxes.js
 var require_boxes = __commonJS({
   "node_modules/mp4-box-encoding/boxes.js"(exports) {
     var Box = require_mp4_box_encoding();
     var Descriptor = require_descriptor();
     var uint64be = require_uint64be();
     var TIME_OFFSET = 20828448e5;
     exports.fullBoxes = {};
     var fullBoxes = [
       "mvhd",
       "tkhd",
       "mdhd",
       "vmhd",
       "smhd",
       "stsd",
       "esds",
       "stsz",
       "stco",
       "co64",
       "stss",
       "stts",
       "ctts",
       "stsc",
       "dref",
       "elst",
       "hdlr",
       "mehd",
       "trex",
       "mfhd",
       "tfhd",
       "tfdt",
       "trun"
     ];
     fullBoxes.forEach(function(type) {
       exports.fullBoxes[type] = true;
     });
     exports.ftyp = {};
     exports.ftyp.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.ftyp.encodingLength(box));
       var brands = box.compatibleBrands || [];
       buf.write(box.brand, 0, 4, "ascii");
       buf.writeUInt32BE(box.brandVersion, 4);
       for (var i = 0; i < brands.length; i++)
         buf.write(brands[i], 8 + i * 4, 4, "ascii");
       exports.ftyp.encode.bytes = 8 + brands.length * 4;
       return buf;
     };
     exports.ftyp.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var brand = buf.toString("ascii", 0, 4);
       var version = buf.readUInt32BE(4);
       var compatibleBrands = [];
       for (var i = 8; i < buf.length; i += 4)
         compatibleBrands.push(buf.toString("ascii", i, i + 4));
       return {
         brand,
         brandVersion: version,
         compatibleBrands
       };
     };
     exports.ftyp.encodingLength = function(box) {
       return 8 + (box.compatibleBrands || []).length * 4;
     };
     exports.mvhd = {};
     exports.mvhd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(96);
       writeDate(box.ctime || new Date(), buf, 0);
       writeDate(box.mtime || new Date(), buf, 4);
       buf.writeUInt32BE(box.timeScale || 0, 8);
       buf.writeUInt32BE(box.duration || 0, 12);
       writeFixed32(box.preferredRate || 0, buf, 16);
       writeFixed16(box.preferredVolume || 0, buf, 20);
       writeReserved(buf, 22, 32);
       writeMatrix(box.matrix, buf, 32);
       buf.writeUInt32BE(box.previewTime || 0, 68);
       buf.writeUInt32BE(box.previewDuration || 0, 72);
       buf.writeUInt32BE(box.posterTime || 0, 76);
       buf.writeUInt32BE(box.selectionTime || 0, 80);
       buf.writeUInt32BE(box.selectionDuration || 0, 84);
       buf.writeUInt32BE(box.currentTime || 0, 88);
       buf.writeUInt32BE(box.nextTrackId || 0, 92);
       exports.mvhd.encode.bytes = 96;
       return buf;
     };
     exports.mvhd.decode = function(buf, offset) {
       buf = buf.slice(offset);
       return {
         ctime: readDate(buf, 0),
         mtime: readDate(buf, 4),
         timeScale: buf.readUInt32BE(8),
         duration: buf.readUInt32BE(12),
         preferredRate: readFixed32(buf, 16),
         preferredVolume: readFixed16(buf, 20),
         matrix: readMatrix(buf.slice(32, 68)),
         previewTime: buf.readUInt32BE(68),
         previewDuration: buf.readUInt32BE(72),
         posterTime: buf.readUInt32BE(76),
         selectionTime: buf.readUInt32BE(80),
         selectionDuration: buf.readUInt32BE(84),
         currentTime: buf.readUInt32BE(88),
         nextTrackId: buf.readUInt32BE(92)
       };
     };
     exports.mvhd.encodingLength = function(box) {
       return 96;
     };
     exports.tkhd = {};
     exports.tkhd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(80);
       writeDate(box.ctime || new Date(), buf, 0);
       writeDate(box.mtime || new Date(), buf, 4);
       buf.writeUInt32BE(box.trackId || 0, 8);
       writeReserved(buf, 12, 16);
       buf.writeUInt32BE(box.duration || 0, 16);
       writeReserved(buf, 20, 28);
       buf.writeUInt16BE(box.layer || 0, 28);
       buf.writeUInt16BE(box.alternateGroup || 0, 30);
       buf.writeUInt16BE(box.volume || 0, 32);
       writeMatrix(box.matrix, buf, 36);
       buf.writeUInt32BE(box.trackWidth || 0, 72);
       buf.writeUInt32BE(box.trackHeight || 0, 76);
       exports.tkhd.encode.bytes = 80;
       return buf;
     };
     exports.tkhd.decode = function(buf, offset) {
       buf = buf.slice(offset);
       return {
         ctime: readDate(buf, 0),
         mtime: readDate(buf, 4),
         trackId: buf.readUInt32BE(8),
         duration: buf.readUInt32BE(16),
         layer: buf.readUInt16BE(28),
         alternateGroup: buf.readUInt16BE(30),
         volume: buf.readUInt16BE(32),
         matrix: readMatrix(buf.slice(36, 72)),
         trackWidth: buf.readUInt32BE(72),
         trackHeight: buf.readUInt32BE(76)
       };
     };
     exports.tkhd.encodingLength = function(box) {
       return 80;
     };
     exports.mdhd = {};
     exports.mdhd.encode = function(box, buf, offset) {
       if (box.version === 1) {
         buf = buf ? buf.slice(offset) : Buffer.alloc(32);
         writeDate64(box.ctime || new Date(), buf, 0);
         writeDate64(box.mtime || new Date(), buf, 8);
         buf.writeUInt32BE(box.timeScale || 0, 16);
         buf.writeUIntBE(box.duration || 0, 20, 6);
         buf.writeUInt16BE(box.language || 0, 28);
         buf.writeUInt16BE(box.quality || 0, 30);
         exports.mdhd.encode.bytes = 32;
         return buf;
       }
       buf = buf ? buf.slice(offset) : Buffer.alloc(20);
       writeDate(box.ctime || new Date(), buf, 0);
       writeDate(box.mtime || new Date(), buf, 4);
       buf.writeUInt32BE(box.timeScale || 0, 8);
       buf.writeUInt32BE(box.duration || 0, 12);
       buf.writeUInt16BE(box.language || 0, 16);
       buf.writeUInt16BE(box.quality || 0, 18);
       exports.mdhd.encode.bytes = 20;
       return buf;
     };
     exports.mdhd.decode = function(buf, offset, end) {
       buf = buf.slice(offset);
       var version1 = end - offset !== 20;
       if (version1) {
         return {
           ctime: readDate64(buf, 0),
           mtime: readDate64(buf, 8),
           timeScale: buf.readUInt32BE(16),
           duration: buf.readUIntBE(20, 6),
           language: buf.readUInt16BE(28),
           quality: buf.readUInt16BE(30)
         };
       }
       return {
         ctime: readDate(buf, 0),
         mtime: readDate(buf, 4),
         timeScale: buf.readUInt32BE(8),
         duration: buf.readUInt32BE(12),
         language: buf.readUInt16BE(16),
         quality: buf.readUInt16BE(18)
       };
     };
     exports.mdhd.encodingLength = function(box) {
       if (box.version === 1)
         return 32;
       return 20;
     };
     exports.vmhd = {};
     exports.vmhd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(8);
       buf.writeUInt16BE(box.graphicsMode || 0, 0);
       var opcolor = box.opcolor || [0, 0, 0];
       buf.writeUInt16BE(opcolor[0], 2);
       buf.writeUInt16BE(opcolor[1], 4);
       buf.writeUInt16BE(opcolor[2], 6);
       exports.vmhd.encode.bytes = 8;
       return buf;
     };
     exports.vmhd.decode = function(buf, offset) {
       buf = buf.slice(offset);
       return {
         graphicsMode: buf.readUInt16BE(0),
         opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
       };
     };
     exports.vmhd.encodingLength = function(box) {
       return 8;
     };
     exports.smhd = {};
     exports.smhd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(4);
       buf.writeUInt16BE(box.balance || 0, 0);
       writeReserved(buf, 2, 4);
       exports.smhd.encode.bytes = 4;
       return buf;
     };
     exports.smhd.decode = function(buf, offset) {
       buf = buf.slice(offset);
       return {
         balance: buf.readUInt16BE(0)
       };
     };
     exports.smhd.encodingLength = function(box) {
       return 4;
     };
     exports.stsd = {};
     exports.stsd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stsd.encodingLength(box));
       var entries = box.entries || [];
       buf.writeUInt32BE(entries.length, 0);
       var ptr = 4;
       for (var i = 0; i < entries.length; i++) {
         var entry = entries[i];
         Box.encode(entry, buf, ptr);
         ptr += Box.encode.bytes;
       }
       exports.stsd.encode.bytes = ptr;
       return buf;
     };
     exports.stsd.decode = function(buf, offset, end) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       var ptr = 4;
       for (var i = 0; i < num; i++) {
         var entry = Box.decode(buf, ptr, end);
         entries[i] = entry;
         ptr += entry.length;
       }
       return {
         entries
       };
     };
     exports.stsd.encodingLength = function(box) {
       var totalSize = 4;
       if (!box.entries)
         return totalSize;
       for (var i = 0; i < box.entries.length; i++) {
         totalSize += Box.encodingLength(box.entries[i]);
       }
       return totalSize;
     };
     exports.avc1 = exports.VisualSampleEntry = {};
     exports.VisualSampleEntry.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.VisualSampleEntry.encodingLength(box));
       writeReserved(buf, 0, 6);
       buf.writeUInt16BE(box.dataReferenceIndex || 0, 6);
       writeReserved(buf, 8, 24);
       buf.writeUInt16BE(box.width || 0, 24);
       buf.writeUInt16BE(box.height || 0, 26);
       buf.writeUInt32BE(box.hResolution || 4718592, 28);
       buf.writeUInt32BE(box.vResolution || 4718592, 32);
       writeReserved(buf, 36, 40);
       buf.writeUInt16BE(box.frameCount || 1, 40);
       var compressorName = box.compressorName || "";
       var nameLen = Math.min(compressorName.length, 31);
       buf.writeUInt8(nameLen, 42);
       buf.write(compressorName, 43, nameLen, "utf8");
       buf.writeUInt16BE(box.depth || 24, 74);
       buf.writeInt16BE(-1, 76);
       var ptr = 78;
       var children = box.children || [];
       children.forEach(function(child) {
         Box.encode(child, buf, ptr);
         ptr += Box.encode.bytes;
       });
       exports.VisualSampleEntry.encode.bytes = ptr;
     };
     exports.VisualSampleEntry.decode = function(buf, offset, end) {
       buf = buf.slice(offset);
       var length = end - offset;
       var nameLen = Math.min(buf.readUInt8(42), 31);
       var box = {
         dataReferenceIndex: buf.readUInt16BE(6),
         width: buf.readUInt16BE(24),
         height: buf.readUInt16BE(26),
         hResolution: buf.readUInt32BE(28),
         vResolution: buf.readUInt32BE(32),
         frameCount: buf.readUInt16BE(40),
         compressorName: buf.toString("utf8", 43, 43 + nameLen),
         depth: buf.readUInt16BE(74),
         children: []
       };
       var ptr = 78;
       while (length - ptr >= 8) {
         var child = Box.decode(buf, ptr, length);
         box.children.push(child);
         box[child.type] = child;
         ptr += child.length;
       }
       return box;
     };
     exports.VisualSampleEntry.encodingLength = function(box) {
       var len = 78;
       var children = box.children || [];
       children.forEach(function(child) {
         len += Box.encodingLength(child);
       });
       return len;
     };
     exports.avcC = {};
     exports.avcC.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(box.buffer.length);
       box.buffer.copy(buf);
       exports.avcC.encode.bytes = box.buffer.length;
     };
     exports.avcC.decode = function(buf, offset, end) {
       buf = buf.slice(offset, end);
       return {
         mimeCodec: buf.toString("hex", 1, 4),
         buffer: Buffer.from(buf)
       };
     };
     exports.avcC.encodingLength = function(box) {
       return box.buffer.length;
     };
     exports.mp4a = exports.AudioSampleEntry = {};
     exports.AudioSampleEntry.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.AudioSampleEntry.encodingLength(box));
       writeReserved(buf, 0, 6);
       buf.writeUInt16BE(box.dataReferenceIndex || 0, 6);
       writeReserved(buf, 8, 16);
       buf.writeUInt16BE(box.channelCount || 2, 16);
       buf.writeUInt16BE(box.sampleSize || 16, 18);
       writeReserved(buf, 20, 24);
       buf.writeUInt32BE(box.sampleRate || 0, 24);
       var ptr = 28;
       var children = box.children || [];
       children.forEach(function(child) {
         Box.encode(child, buf, ptr);
         ptr += Box.encode.bytes;
       });
       exports.AudioSampleEntry.encode.bytes = ptr;
     };
     exports.AudioSampleEntry.decode = function(buf, offset, end) {
       buf = buf.slice(offset, end);
       var length = end - offset;
       var box = {
         dataReferenceIndex: buf.readUInt16BE(6),
         channelCount: buf.readUInt16BE(16),
         sampleSize: buf.readUInt16BE(18),
         sampleRate: buf.readUInt32BE(24),
         children: []
       };
       var ptr = 28;
       while (length - ptr >= 8) {
         var child = Box.decode(buf, ptr, length);
         box.children.push(child);
         box[child.type] = child;
         ptr += child.length;
       }
       return box;
     };
     exports.AudioSampleEntry.encodingLength = function(box) {
       var len = 28;
       var children = box.children || [];
       children.forEach(function(child) {
         len += Box.encodingLength(child);
       });
       return len;
     };
     exports.esds = {};
     exports.esds.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(box.buffer.length);
       box.buffer.copy(buf, 0);
       exports.esds.encode.bytes = box.buffer.length;
     };
     exports.esds.decode = function(buf, offset, end) {
       buf = buf.slice(offset, end);
       var desc = Descriptor.Descriptor.decode(buf, 0, buf.length);
       var esd = desc.tagName === "ESDescriptor" ? desc : {};
       var dcd = esd.DecoderConfigDescriptor || {};
       var oti = dcd.oti || 0;
       var dsi = dcd.DecoderSpecificInfo;
       var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 248) >> 3 : 0;
       var mimeCodec = null;
       if (oti) {
         mimeCodec = oti.toString(16);
         if (audioConfig) {
           mimeCodec += "." + audioConfig;
         }
       }
       return {
         mimeCodec,
         buffer: Buffer.from(buf.slice(0))
       };
     };
     exports.esds.encodingLength = function(box) {
       return box.buffer.length;
     };
     exports.stsz = {};
     exports.stsz.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stsz.encodingLength(box));
       buf.writeUInt32BE(0, 0);
       buf.writeUInt32BE(entries.length, 4);
       for (var i = 0; i < entries.length; i++) {
         buf.writeUInt32BE(entries[i], i * 4 + 8);
       }
       exports.stsz.encode.bytes = 8 + entries.length * 4;
       return buf;
     };
     exports.stsz.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var size = buf.readUInt32BE(0);
       var num = buf.readUInt32BE(4);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         if (size === 0) {
           entries[i] = buf.readUInt32BE(i * 4 + 8);
         } else {
           entries[i] = size;
         }
       }
       return {
         entries
       };
     };
     exports.stsz.encodingLength = function(box) {
       return 8 + box.entries.length * 4;
     };
     exports.stss = exports.stco = {};
     exports.stco.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stco.encodingLength(box));
       buf.writeUInt32BE(entries.length, 0);
       for (var i = 0; i < entries.length; i++) {
         buf.writeUInt32BE(entries[i], i * 4 + 4);
       }
       exports.stco.encode.bytes = 4 + entries.length * 4;
       return buf;
     };
     exports.stco.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         entries[i] = buf.readUInt32BE(i * 4 + 4);
       }
       return {
         entries
       };
     };
     exports.stco.encodingLength = function(box) {
       return 4 + box.entries.length * 4;
     };
     exports.co64 = {};
     exports.co64.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.co64.encodingLength(box));
       buf.writeUInt32BE(entries.length, 0);
       for (var i = 0; i < entries.length; i++) {
         uint64be.encode(entries[i], buf, i * 8 + 4);
       }
       exports.co64.encode.bytes = 4 + entries.length * 8;
       return buf;
     };
     exports.co64.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         entries[i] = uint64be.decode(buf, i * 8 + 4);
       }
       return {
         entries
       };
     };
     exports.co64.encodingLength = function(box) {
       return 4 + box.entries.length * 8;
     };
     exports.stts = {};
     exports.stts.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stts.encodingLength(box));
       buf.writeUInt32BE(entries.length, 0);
       for (var i = 0; i < entries.length; i++) {
         var ptr = i * 8 + 4;
         buf.writeUInt32BE(entries[i].count || 0, ptr);
         buf.writeUInt32BE(entries[i].duration || 0, ptr + 4);
       }
       exports.stts.encode.bytes = 4 + box.entries.length * 8;
       return buf;
     };
     exports.stts.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         var ptr = i * 8 + 4;
         entries[i] = {
           count: buf.readUInt32BE(ptr),
           duration: buf.readUInt32BE(ptr + 4)
         };
       }
       return {
         entries
       };
     };
     exports.stts.encodingLength = function(box) {
       return 4 + box.entries.length * 8;
     };
     exports.ctts = {};
     exports.ctts.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.ctts.encodingLength(box));
       buf.writeUInt32BE(entries.length, 0);
       for (var i = 0; i < entries.length; i++) {
         var ptr = i * 8 + 4;
         buf.writeUInt32BE(entries[i].count || 0, ptr);
         buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4);
       }
       exports.ctts.encode.bytes = 4 + entries.length * 8;
       return buf;
     };
     exports.ctts.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         var ptr = i * 8 + 4;
         entries[i] = {
           count: buf.readUInt32BE(ptr),
           compositionOffset: buf.readInt32BE(ptr + 4)
         };
       }
       return {
         entries
       };
     };
     exports.ctts.encodingLength = function(box) {
       return 4 + box.entries.length * 8;
     };
     exports.stsc = {};
     exports.stsc.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.stsc.encodingLength(box));
       buf.writeUInt32BE(entries.length, 0);
       for (var i = 0; i < entries.length; i++) {
         var ptr = i * 12 + 4;
         buf.writeUInt32BE(entries[i].firstChunk || 0, ptr);
         buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4);
         buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8);
       }
       exports.stsc.encode.bytes = 4 + entries.length * 12;
       return buf;
     };
     exports.stsc.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         var ptr = i * 12 + 4;
         entries[i] = {
           firstChunk: buf.readUInt32BE(ptr),
           samplesPerChunk: buf.readUInt32BE(ptr + 4),
           sampleDescriptionId: buf.readUInt32BE(ptr + 8)
         };
       }
       return {
         entries
       };
     };
     exports.stsc.encodingLength = function(box) {
       return 4 + box.entries.length * 12;
     };
     exports.dref = {};
     exports.dref.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.dref.encodingLength(box));
       var entries = box.entries || [];
       buf.writeUInt32BE(entries.length, 0);
       var ptr = 4;
       for (var i = 0; i < entries.length; i++) {
         var entry = entries[i];
         var size = (entry.buf ? entry.buf.length : 0) + 4 + 4;
         buf.writeUInt32BE(size, ptr);
         ptr += 4;
         buf.write(entry.type, ptr, 4, "ascii");
         ptr += 4;
         if (entry.buf) {
           entry.buf.copy(buf, ptr);
           ptr += entry.buf.length;
         }
       }
       exports.dref.encode.bytes = ptr;
       return buf;
     };
     exports.dref.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       var ptr = 4;
       for (var i = 0; i < num; i++) {
         var size = buf.readUInt32BE(ptr);
         var type = buf.toString("ascii", ptr + 4, ptr + 8);
         var tmp = buf.slice(ptr + 8, ptr + size);
         ptr += size;
         entries[i] = {
           type,
           buf: tmp
         };
       }
       return {
         entries
       };
     };
     exports.dref.encodingLength = function(box) {
       var totalSize = 4;
       if (!box.entries)
         return totalSize;
       for (var i = 0; i < box.entries.length; i++) {
         var buf = box.entries[i].buf;
         totalSize += (buf ? buf.length : 0) + 4 + 4;
       }
       return totalSize;
     };
     exports.elst = {};
     exports.elst.encode = function(box, buf, offset) {
       var entries = box.entries || [];
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.elst.encodingLength(box));
       buf.writeUInt32BE(entries.length, 0);
       for (var i = 0; i < entries.length; i++) {
         var ptr = i * 12 + 4;
         buf.writeUInt32BE(entries[i].trackDuration || 0, ptr);
         buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4);
         writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8);
       }
       exports.elst.encode.bytes = 4 + entries.length * 12;
       return buf;
     };
     exports.elst.decode = function(buf, offset) {
       buf = buf.slice(offset);
       var num = buf.readUInt32BE(0);
       var entries = new Array(num);
       for (var i = 0; i < num; i++) {
         var ptr = i * 12 + 4;
         entries[i] = {
           trackDuration: buf.readUInt32BE(ptr),
           mediaTime: buf.readInt32BE(ptr + 4),
           mediaRate: readFixed32(buf, ptr + 8)
         };
       }
       return {
         entries
       };
     };
     exports.elst.encodingLength = function(box) {
       return 4 + box.entries.length * 12;
     };
     exports.hdlr = {};
     exports.hdlr.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(exports.hdlr.encodingLength(box));
       var len = 21 + (box.name || "").length;
       buf.fill(0, 0, len);
       buf.write(box.handlerType || "", 4, 4, "ascii");
       writeString(box.name || "", buf, 20);
       exports.hdlr.encode.bytes = len;
       return buf;
     };
     exports.hdlr.decode = function(buf, offset, end) {
       buf = buf.slice(offset);
       return {
         handlerType: buf.toString("ascii", 4, 8),
         name: readString(buf, 20, end)
       };
     };
     exports.hdlr.encodingLength = function(box) {
       return 21 + (box.name || "").length;
     };
     exports.mehd = {};
     exports.mehd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(4);
       buf.writeUInt32BE(box.fragmentDuration || 0, 0);
       exports.mehd.encode.bytes = 4;
       return buf;
     };
     exports.mehd.decode = function(buf, offset) {
       buf = buf.slice(offset);
       return {
         fragmentDuration: buf.readUInt32BE(0)
       };
     };
     exports.mehd.encodingLength = function(box) {
       return 4;
     };
     exports.trex = {};
     exports.trex.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(20);
       buf.writeUInt32BE(box.trackId || 0, 0);
       buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4);
       buf.writeUInt32BE(box.defaultSampleDuration || 0, 8);
       buf.writeUInt32BE(box.defaultSampleSize || 0, 12);
       buf.writeUInt32BE(box.defaultSampleFlags || 0, 16);
       exports.trex.encode.bytes = 20;
       return buf;
     };
     exports.trex.decode = function(buf, offset) {
       buf = buf.slice(offset);
       return {
         trackId: buf.readUInt32BE(0),
         defaultSampleDescriptionIndex: buf.readUInt32BE(4),
         defaultSampleDuration: buf.readUInt32BE(8),
         defaultSampleSize: buf.readUInt32BE(12),
         defaultSampleFlags: buf.readUInt32BE(16)
       };
     };
     exports.trex.encodingLength = function(box) {
       return 20;
     };
     exports.mfhd = {};
     exports.mfhd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(4);
       buf.writeUInt32BE(box.sequenceNumber || 0, 0);
       exports.mfhd.encode.bytes = 4;
       return buf;
     };
     exports.mfhd.decode = function(buf, offset) {
       return {
         sequenceNumber: buf.readUInt32BE(0)
       };
     };
     exports.mfhd.encodingLength = function(box) {
       return 4;
     };
     exports.tfhd = {};
     exports.tfhd.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(4);
       buf.writeUInt32BE(box.trackId, 0);
       exports.tfhd.encode.bytes = 4;
       return buf;
     };
     exports.tfhd.decode = function(buf, offset) {
     };
     exports.tfhd.encodingLength = function(box) {
       return 4;
     };
     exports.tfdt = {};
     exports.tfdt.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(4);
       buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0);
       exports.tfdt.encode.bytes = 4;
       return buf;
     };
     exports.tfdt.decode = function(buf, offset) {
     };
     exports.tfdt.encodingLength = function(box) {
       return 4;
     };
     exports.trun = {};
     exports.trun.encode = function(box, buf, offset) {
       buf = buf ? buf.slice(offset) : Buffer.alloc(8 + box.entries.length * 16);
       buf.writeUInt32BE(box.entries.length, 0);
       buf.writeInt32BE(box.dataOffset, 4);
       var ptr = 8;
       for (var i = 0; i < box.entries.length; i++) {
         var entry = box.entries[i];
         buf.writeUInt32BE(entry.sampleDuration, ptr);
         ptr += 4;
         buf.writeUInt32BE(entry.sampleSize, ptr);
         ptr += 4;
         buf.writeUInt32BE(entry.sampleFlags, ptr);
         ptr += 4;
         if ((box.version || 0) === 0) {
           buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr);
         } else {
           buf.writeInt32BE(entry.sampleCompositionTimeOffset, ptr);
         }
         ptr += 4;
       }
       exports.trun.encode.bytes = ptr;
     };
     exports.trun.decode = function(buf, offset) {
     };
     exports.trun.encodingLength = function(box) {
       return 8 + box.entries.length * 16;
     };
     exports.mdat = {};
     exports.mdat.encode = function(box, buf, offset) {
       if (box.buffer) {
         box.buffer.copy(buf, offset);
         exports.mdat.encode.bytes = box.buffer.length;
       } else {
         exports.mdat.encode.bytes = exports.mdat.encodingLength(box);
       }
     };
     exports.mdat.decode = function(buf, start, end) {
       return {
         buffer: Buffer.from(buf.slice(start, end))
       };
     };
     exports.mdat.encodingLength = function(box) {
       return box.buffer ? box.buffer.length : box.contentLength;
     };
     function writeReserved(buf, offset, end) {
       for (var i = offset; i < end; i++)
         buf[i] = 0;
     }
     function writeDate(date, buf, offset) {
       buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1e3), offset);
     }
     function writeDate64(date, buf, offset) {
       buf.writeUIntBE(Math.floor((date.getTime() + TIME_OFFSET) / 1e3), offset, 6);
     }
     function writeFixed32(num, buf, offset) {
       buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset);
       buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2);
     }
     function writeFixed16(num, buf, offset) {
       buf[offset] = Math.floor(num) % 256;
       buf[offset + 1] = Math.floor(num * 256) % 256;
     }
     function writeMatrix(list, buf, offset) {
       if (!list)
         list = [0, 0, 0, 0, 0, 0, 0, 0, 0];
       for (var i = 0; i < list.length; i++) {
         writeFixed32(list[i], buf, offset + i * 4);
       }
     }
     function writeString(str, buf, offset) {
       var strBuffer = Buffer.from(str, "utf8");
       strBuffer.copy(buf, offset);
       buf[offset + strBuffer.length] = 0;
     }
     function readMatrix(buf) {
       var list = new Array(buf.length / 4);
       for (var i = 0; i < list.length; i++)
         list[i] = readFixed32(buf, i * 4);
       return list;
     }
     function readDate64(buf, offset) {
       return new Date(buf.readUIntBE(offset, 6) * 1e3 - TIME_OFFSET);
     }
     function readDate(buf, offset) {
       return new Date(buf.readUInt32BE(offset) * 1e3 - TIME_OFFSET);
     }
     function readFixed32(buf, offset) {
       return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256);
     }
     function readFixed16(buf, offset) {
       return buf[offset] + buf[offset + 1] / 256;
     }
     function readString(buf, offset, length) {
       var i;
       for (i = 0; i < length; i++) {
         if (buf[offset + i] === 0) {
           break;
         }
       }
       return buf.toString("utf8", offset, offset + i);
     }
   }
 });
 
 // node_modules/mp4-box-encoding/index.js
 var require_mp4_box_encoding = __commonJS({
   "node_modules/mp4-box-encoding/index.js"(exports) {
     var uint64be = require_uint64be();
     var boxes = require_boxes();
     var UINT32_MAX = 4294967295;
     var Box = exports;
     var containers = exports.containers = {
       "moov": ["mvhd", "meta", "traks", "mvex"],
       "trak": ["tkhd", "tref", "trgr", "edts", "meta", "mdia", "udta"],
       "edts": ["elst"],
       "mdia": ["mdhd", "hdlr", "elng", "minf"],
       "minf": ["vmhd", "smhd", "hmhd", "sthd", "nmhd", "dinf", "stbl"],
       "dinf": ["dref"],
       "stbl": ["stsd", "stts", "ctts", "cslg", "stsc", "stsz", "stz2", "stco", "co64", "stss", "stsh", "padb", "stdp", "sdtp", "sbgps", "sgpds", "subss", "saizs", "saios"],
       "mvex": ["mehd", "trexs", "leva"],
       "moof": ["mfhd", "meta", "trafs"],
       "traf": ["tfhd", "tfdt", "trun", "sbgps", "sgpds", "subss", "saizs", "saios", "meta"]
     };
     Box.encode = function(obj, buffer, offset) {
       Box.encodingLength(obj);
       offset = offset || 0;
       buffer = buffer || Buffer.alloc(obj.length);
       return Box._encode(obj, buffer, offset);
     };
     Box._encode = function(obj, buffer, offset) {
       var type = obj.type;
       var len = obj.length;
       if (len > UINT32_MAX) {
         len = 1;
       }
       buffer.writeUInt32BE(len, offset);
       buffer.write(obj.type, offset + 4, 4, "ascii");
       var ptr = offset + 8;
       if (len === 1) {
         uint64be.encode(obj.length, buffer, ptr);
         ptr += 8;
       }
       if (boxes.fullBoxes[type]) {
         buffer.writeUInt32BE(obj.flags || 0, ptr);
         buffer.writeUInt8(obj.version || 0, ptr);
         ptr += 4;
       }
       if (containers[type]) {
         var contents = containers[type];
         contents.forEach(function(childType) {
           if (childType.length === 5) {
             var entry = obj[childType] || [];
             childType = childType.substr(0, 4);
             entry.forEach(function(child) {
               Box._encode(child, buffer, ptr);
               ptr += Box.encode.bytes;
             });
           } else if (obj[childType]) {
             Box._encode(obj[childType], buffer, ptr);
             ptr += Box.encode.bytes;
           }
         });
         if (obj.otherBoxes) {
           obj.otherBoxes.forEach(function(child) {
             Box._encode(child, buffer, ptr);
             ptr += Box.encode.bytes;
           });
         }
       } else if (boxes[type]) {
         var encode = boxes[type].encode;
         encode(obj, buffer, ptr);
         ptr += encode.bytes;
       } else if (obj.buffer) {
         var buf = obj.buffer;
         buf.copy(buffer, ptr);
         ptr += obj.buffer.length;
       } else {
         throw new Error("Either `type` must be set to a known type (not'" + type + "') or `buffer` must be set");
       }
       Box.encode.bytes = ptr - offset;
       return buffer;
     };
     Box.readHeaders = function(buffer, start, end) {
       start = start || 0;
       end = end || buffer.length;
       if (end - start < 8) {
         return 8;
       }
       var len = buffer.readUInt32BE(start);
       var type = buffer.toString("ascii", start + 4, start + 8);
       var ptr = start + 8;
       if (len === 1) {
         if (end - start < 16) {
           return 16;
         }
         len = uint64be.decode(buffer, ptr);
         ptr += 8;
       }
       var version;
       var flags;
       if (boxes.fullBoxes[type]) {
         version = buffer.readUInt8(ptr);
         flags = buffer.readUInt32BE(ptr) & 16777215;
         ptr += 4;
       }
       return {
         length: len,
         headersLen: ptr - start,
         contentLen: len - (ptr - start),
         type,
         version,
         flags
       };
     };
     Box.decode = function(buffer, start, end) {
       start = start || 0;
       end = end || buffer.length;
       var headers = Box.readHeaders(buffer, start, end);
       if (!headers || headers.length > end - start) {
         throw new Error("Data too short");
       }
       return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length);
     };
     Box.decodeWithoutHeaders = function(headers, buffer, start, end) {
       start = start || 0;
       end = end || buffer.length;
       var type = headers.type;
       var obj = {};
       if (containers[type]) {
         obj.otherBoxes = [];
         var contents = containers[type];
         var ptr = start;
         while (end - ptr >= 8) {
           var child = Box.decode(buffer, ptr, end);
           ptr += child.length;
           if (contents.indexOf(child.type) >= 0) {
             obj[child.type] = child;
           } else if (contents.indexOf(child.type + "s") >= 0) {
             var childType = child.type + "s";
             var entry = obj[childType] = obj[childType] || [];
             entry.push(child);
           } else {
             obj.otherBoxes.push(child);
           }
         }
       } else if (boxes[type]) {
         var decode = boxes[type].decode;
         obj = decode(buffer, start, end);
       } else {
         obj.buffer = Buffer.from(buffer.slice(start, end));
       }
       obj.length = headers.length;
       obj.contentLen = headers.contentLen;
       obj.type = headers.type;
       obj.version = headers.version;
       obj.flags = headers.flags;
       return obj;
     };
     Box.encodingLength = function(obj) {
       var type = obj.type;
       var len = 8;
       if (boxes.fullBoxes[type]) {
         len += 4;
       }
       if (containers[type]) {
         var contents = containers[type];
         contents.forEach(function(childType) {
           if (childType.length === 5) {
             var entry = obj[childType] || [];
             childType = childType.substr(0, 4);
             entry.forEach(function(child2) {
               child2.type = childType;
               len += Box.encodingLength(child2);
             });
           } else if (obj[childType]) {
             var child = obj[childType];
             child.type = childType;
             len += Box.encodingLength(child);
           }
         });
         if (obj.otherBoxes) {
           obj.otherBoxes.forEach(function(child) {
             len += Box.encodingLength(child);
           });
         }
       } else if (boxes[type]) {
         len += boxes[type].encodingLength(obj);
       } else if (obj.buffer) {
         len += obj.buffer.length;
       } else {
         throw new Error("Either `type` must be set to a known type (not'" + type + "') or `buffer` must be set");
       }
       if (len > UINT32_MAX) {
         len += 8;
       }
       obj.length = len;
       return len;
     };
   }
 });
 
 // node_modules/mp4-stream/decode.js
 var require_decode2 = __commonJS({
   "node_modules/mp4-stream/decode.js"(exports, module2) {
     var stream = require_readable();
     var nextEvent = require_next_event();
     var Box = require_mp4_box_encoding();
     var EMPTY = Buffer.alloc(0);
     var Decoder = class extends stream.Writable {
       constructor(opts) {
         super(opts);
         this.destroyed = false;
         this._pending = 0;
         this._missing = 0;
         this._ignoreEmpty = false;
         this._buf = null;
         this._str = null;
         this._cb = null;
         this._ondrain = null;
         this._writeBuffer = null;
         this._writeCb = null;
         this._ondrain = null;
         this._kick();
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         if (err)
           this.emit("error", err);
         this.emit("close");
       }
       _write(data, enc, next) {
         if (this.destroyed)
           return;
         var drained = !this._str || !this._str._writableState.needDrain;
         while (data.length && !this.destroyed) {
           if (!this._missing && !this._ignoreEmpty) {
             this._writeBuffer = data;
             this._writeCb = next;
             return;
           }
           var consumed = data.length < this._missing ? data.length : this._missing;
           if (this._buf)
             data.copy(this._buf, this._buf.length - this._missing);
           else if (this._str)
             drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed));
           this._missing -= consumed;
           if (!this._missing) {
             var buf = this._buf;
             var cb = this._cb;
             var stream2 = this._str;
             this._buf = this._cb = this._str = this._ondrain = null;
             drained = true;
             this._ignoreEmpty = false;
             if (stream2)
               stream2.end();
             if (cb)
               cb(buf);
           }
           data = consumed === data.length ? EMPTY : data.slice(consumed);
         }
         if (this._pending && !this._missing) {
           this._writeBuffer = data;
           this._writeCb = next;
           return;
         }
         if (drained)
           next();
         else
           this._ondrain(next);
       }
       _buffer(size, cb) {
         this._missing = size;
         this._buf = Buffer.alloc(size);
         this._cb = cb;
       }
       _stream(size, cb) {
         this._missing = size;
         this._str = new MediaData(this);
         this._ondrain = nextEvent(this._str, "drain");
         this._pending++;
         this._str.on("end", () => {
           this._pending--;
           this._kick();
         });
         this._cb = cb;
         return this._str;
       }
       _readBox() {
         const bufferHeaders = (len, buf) => {
           this._buffer(len, (additionalBuf) => {
             if (buf) {
               buf = Buffer.concat([buf, additionalBuf]);
             } else {
               buf = additionalBuf;
             }
             var headers = Box.readHeaders(buf);
             if (typeof headers === "number") {
               bufferHeaders(headers - buf.length, buf);
             } else {
               this._pending++;
               this._headers = headers;
               this.emit("box", headers);
             }
           });
         };
         bufferHeaders(8);
       }
       stream() {
         if (!this._headers)
           throw new Error("this function can only be called once after 'box' is emitted");
         var headers = this._headers;
         this._headers = null;
         return this._stream(headers.contentLen, () => {
           this._pending--;
           this._kick();
         });
       }
       decode(cb) {
         if (!this._headers)
           throw new Error("this function can only be called once after 'box' is emitted");
         var headers = this._headers;
         this._headers = null;
         this._buffer(headers.contentLen, (buf) => {
           var box = Box.decodeWithoutHeaders(headers, buf);
           cb(box);
           this._pending--;
           this._kick();
         });
       }
       ignore() {
         if (!this._headers)
           throw new Error("this function can only be called once after 'box' is emitted");
         var headers = this._headers;
         this._headers = null;
         this._missing = headers.contentLen;
         if (this._missing === 0) {
           this._ignoreEmpty = true;
         }
         this._cb = () => {
           this._pending--;
           this._kick();
         };
       }
       _kick() {
         if (this._pending)
           return;
         if (!this._buf && !this._str)
           this._readBox();
         if (this._writeBuffer) {
           var next = this._writeCb;
           var buffer = this._writeBuffer;
           this._writeBuffer = null;
           this._writeCb = null;
           this._write(buffer, null, next);
         }
       }
     };
     var MediaData = class extends stream.PassThrough {
       constructor(parent) {
         super();
         this._parent = parent;
         this.destroyed = false;
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         this._parent.destroy(err);
         if (err)
           this.emit("error", err);
         this.emit("close");
       }
     };
     module2.exports = Decoder;
   }
 });
 
 // node_modules/mp4-stream/encode.js
 var require_encode2 = __commonJS({
   "node_modules/mp4-stream/encode.js"(exports, module2) {
     var stream = require_readable();
     var Box = require_mp4_box_encoding();
     var queueMicrotask3 = require_queue_microtask();
     function noop2() {
     }
     var Encoder = class extends stream.Readable {
       constructor(opts) {
         super(opts);
         this.destroyed = false;
         this._finalized = false;
         this._reading = false;
         this._stream = null;
         this._drain = null;
         this._want = false;
         this._onreadable = () => {
           if (!this._want)
             return;
           this._want = false;
           this._read();
         };
         this._onend = () => {
           this._stream = null;
         };
       }
       mdat(size, cb) {
         this.mediaData(size, cb);
       }
       mediaData(size, cb) {
         var stream2 = new MediaData(this);
         this.box({ type: "mdat", contentLength: size, encodeBufferLen: 8, stream: stream2 }, cb);
         return stream2;
       }
       box(box, cb) {
         if (!cb)
           cb = noop2;
         if (this.destroyed)
           return cb(new Error("Encoder is destroyed"));
         var buf;
         if (box.encodeBufferLen) {
           buf = Buffer.alloc(box.encodeBufferLen);
         }
         if (box.stream) {
           box.buffer = null;
           buf = Box.encode(box, buf);
           this.push(buf);
           this._stream = box.stream;
           this._stream.on("readable", this._onreadable);
           this._stream.on("end", this._onend);
           this._stream.on("end", cb);
           this._forward();
         } else {
           buf = Box.encode(box, buf);
           var drained = this.push(buf);
           if (drained)
             return queueMicrotask3(cb);
           this._drain = cb;
         }
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         if (this._stream && this._stream.destroy)
           this._stream.destroy();
         this._stream = null;
         if (this._drain) {
           var cb = this._drain;
           this._drain = null;
           cb(err);
         }
         if (err)
           this.emit("error", err);
         this.emit("close");
       }
       finalize() {
         this._finalized = true;
         if (!this._stream && !this._drain) {
           this.push(null);
         }
       }
       _forward() {
         if (!this._stream)
           return;
         while (!this.destroyed) {
           var buf = this._stream.read();
           if (!buf) {
             this._want = !!this._stream;
             return;
           }
           if (!this.push(buf))
             return;
         }
       }
       _read() {
         if (this._reading || this.destroyed)
           return;
         this._reading = true;
         if (this._stream)
           this._forward();
         if (this._drain) {
           var drain = this._drain;
           this._drain = null;
           drain();
         }
         this._reading = false;
         if (this._finalized) {
           this.push(null);
         }
       }
     };
     var MediaData = class extends stream.PassThrough {
       constructor(parent) {
         super();
         this._parent = parent;
         this.destroyed = false;
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         this._parent.destroy(err);
         if (err)
           this.emit("error", err);
         this.emit("close");
       }
     };
     module2.exports = Encoder;
   }
 });
 
 // node_modules/mp4-stream/index.js
 var require_mp4_stream = __commonJS({
   "node_modules/mp4-stream/index.js"(exports) {
     var Decoder = require_decode2();
     var Encoder = require_encode2();
     exports.decode = (opts) => new Decoder(opts);
     exports.encode = (opts) => new Encoder(opts);
   }
 });
 
 // node_modules/range-slice-stream/index.js
 var require_range_slice_stream = __commonJS({
   "node_modules/range-slice-stream/index.js"(exports, module2) {
     var { Writable, PassThrough } = require_readable();
     var RangeSliceStream = class extends Writable {
       constructor(offset, opts = {}) {
         super(opts);
         this.destroyed = false;
         this._queue = [];
         this._position = offset || 0;
         this._cb = null;
         this._buffer = null;
         this._out = null;
       }
       _write(chunk, encoding, cb) {
         let drained = true;
         while (true) {
           if (this.destroyed) {
             return;
           }
           if (this._queue.length === 0) {
             this._buffer = chunk;
             this._cb = cb;
             return;
           }
           this._buffer = null;
           var currRange = this._queue[0];
           const writeStart = Math.max(currRange.start - this._position, 0);
           const writeEnd = currRange.end - this._position;
           if (writeStart >= chunk.length) {
             this._position += chunk.length;
             return cb(null);
           }
           let toWrite;
           if (writeEnd > chunk.length) {
             this._position += chunk.length;
             if (writeStart === 0) {
               toWrite = chunk;
             } else {
               toWrite = chunk.slice(writeStart);
             }
             drained = currRange.stream.write(toWrite) && drained;
             break;
           }
           this._position += writeEnd;
           toWrite = writeStart === 0 && writeEnd === chunk.length ? chunk : chunk.slice(writeStart, writeEnd);
           drained = currRange.stream.write(toWrite) && drained;
           if (currRange.last) {
             currRange.stream.end();
           }
           chunk = chunk.slice(writeEnd);
           this._queue.shift();
         }
         if (drained) {
           cb(null);
         } else {
           currRange.stream.once("drain", cb.bind(null, null));
         }
       }
       slice(ranges) {
         if (this.destroyed)
           return null;
         if (!Array.isArray(ranges))
           ranges = [ranges];
         const str = new PassThrough();
         ranges.forEach((range, i) => {
           this._queue.push({
             start: range.start,
             end: range.end,
             stream: str,
             last: i === ranges.length - 1
           });
         });
         if (this._buffer) {
           this._write(this._buffer, null, this._cb);
         }
         return str;
       }
       destroy(err) {
         if (this.destroyed)
           return;
         this.destroyed = true;
         if (err)
           this.emit("error", err);
       }
     };
     module2.exports = RangeSliceStream;
   }
 });
 
 // node_modules/videostream/mp4-remuxer.js
 var require_mp4_remuxer = __commonJS({
   "node_modules/videostream/mp4-remuxer.js"(exports, module2) {
     var bs = require_binary_search();
     var EventEmitter = require("events");
     var mp4 = require_mp4_stream();
     var Box = require_mp4_box_encoding();
     var RangeSliceStream = require_range_slice_stream();
     var FIND_MOOV_SEEK_SIZE = 4096;
     var MP4Remuxer = class extends EventEmitter {
       constructor(file) {
         super();
         this._tracks = [];
         this._file = file;
         this._decoder = null;
         this._findMoov(0);
       }
       _findMoov(offset) {
         if (this._decoder) {
           this._decoder.destroy();
         }
         let toSkip = 0;
         this._decoder = mp4.decode();
         const fileStream = this._file.createReadStream({
           start: offset
         });
         fileStream.pipe(this._decoder);
         const boxHandler = (headers) => {
           if (headers.type === "moov") {
             this._decoder.removeListener("box", boxHandler);
             this._decoder.decode((moov) => {
               fileStream.destroy();
               try {
                 this._processMoov(moov);
               } catch (err) {
                 err.message = `Cannot parse mp4 file: ${err.message}`;
                 this.emit("error", err);
               }
             });
           } else if (headers.length < FIND_MOOV_SEEK_SIZE) {
             toSkip += headers.length;
             this._decoder.ignore();
           } else {
             this._decoder.removeListener("box", boxHandler);
             toSkip += headers.length;
             fileStream.destroy();
             this._decoder.destroy();
             this._findMoov(offset + toSkip);
           }
         };
         this._decoder.on("box", boxHandler);
       }
       _processMoov(moov) {
         const traks = moov.traks;
         this._tracks = [];
         this._hasVideo = false;
         this._hasAudio = false;
         for (let i = 0; i < traks.length; i++) {
           const trak = traks[i];
           const stbl = trak.mdia.minf.stbl;
           const stsdEntry = stbl.stsd.entries[0];
           const handlerType = trak.mdia.hdlr.handlerType;
           let codec;
           let mime;
           if (handlerType === "vide" && stsdEntry.type === "avc1") {
             if (this._hasVideo) {
               continue;
             }
             this._hasVideo = true;
             codec = "avc1";
             if (stsdEntry.avcC) {
               codec += `.${stsdEntry.avcC.mimeCodec}`;
             }
             mime = `video/mp4; codecs="${codec}"`;
           } else if (handlerType === "soun" && stsdEntry.type === "mp4a") {
             if (this._hasAudio) {
               continue;
             }
             this._hasAudio = true;
             codec = "mp4a";
             if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
               codec += `.${stsdEntry.esds.mimeCodec}`;
             }
             mime = `audio/mp4; codecs="${codec}"`;
           } else {
             continue;
           }
           const samples = [];
           let sample = 0;
           let sampleInChunk = 0;
           let chunk = 0;
           let offsetInChunk = 0;
           let sampleToChunkIndex = 0;
           let dts = 0;
           const decodingTimeEntry = new RunLengthIndex(stbl.stts.entries);
           let presentationOffsetEntry = null;
           if (stbl.ctts) {
             presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries);
           }
           let syncSampleIndex = 0;
           while (true) {
             var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex];
             const size = stbl.stsz.entries[sample];
             const duration = decodingTimeEntry.value.duration;
             const presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0;
             let sync = true;
             if (stbl.stss) {
               sync = stbl.stss.entries[syncSampleIndex] === sample + 1;
             }
             const chunkOffsetTable = stbl.stco || stbl.co64;
             samples.push({
               size,
               duration,
               dts,
               presentationOffset,
               sync,
               offset: offsetInChunk + chunkOffsetTable.entries[chunk]
             });
             sample++;
             if (sample >= stbl.stsz.entries.length) {
               break;
             }
             sampleInChunk++;
             offsetInChunk += size;
             if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
               sampleInChunk = 0;
               offsetInChunk = 0;
               chunk++;
               const nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1];
               if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
                 sampleToChunkIndex++;
               }
             }
             dts += duration;
             decodingTimeEntry.inc();
             presentationOffsetEntry && presentationOffsetEntry.inc();
             if (sync) {
               syncSampleIndex++;
             }
           }
           trak.mdia.mdhd.duration = 0;
           trak.tkhd.duration = 0;
           const defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId;
           const trackMoov = {
             type: "moov",
             mvhd: moov.mvhd,
             traks: [{
               tkhd: trak.tkhd,
               mdia: {
                 mdhd: trak.mdia.mdhd,
                 hdlr: trak.mdia.hdlr,
                 elng: trak.mdia.elng,
                 minf: {
                   vmhd: trak.mdia.minf.vmhd,
                   smhd: trak.mdia.minf.smhd,
                   dinf: trak.mdia.minf.dinf,
                   stbl: {
                     stsd: stbl.stsd,
                     stts: empty(),
                     ctts: empty(),
                     stsc: empty(),
                     stsz: empty(),
                     stco: empty(),
                     stss: empty()
                   }
                 }
               }
             }],
             mvex: {
               mehd: {
                 fragmentDuration: moov.mvhd.duration
               },
               trexs: [{
                 trackId: trak.tkhd.trackId,
                 defaultSampleDescriptionIndex,
                 defaultSampleDuration: 0,
                 defaultSampleSize: 0,
                 defaultSampleFlags: 0
               }]
             }
           };
           this._tracks.push({
             fragmentSequence: 1,
             trackId: trak.tkhd.trackId,
             timeScale: trak.mdia.mdhd.timeScale,
             samples,
             currSample: null,
             currTime: null,
             moov: trackMoov,
             mime
           });
         }
         if (this._tracks.length === 0) {
           this.emit("error", new Error("no playable tracks"));
           return;
         }
         moov.mvhd.duration = 0;
         this._ftyp = {
           type: "ftyp",
           brand: "iso5",
           brandVersion: 0,
           compatibleBrands: [
             "iso5"
           ]
         };
         const ftypBuf = Box.encode(this._ftyp);
         const data = this._tracks.map((track) => {
           const moovBuf = Box.encode(track.moov);
           return {
             mime: track.mime,
             init: Buffer.concat([ftypBuf, moovBuf])
           };
         });
         this.emit("ready", data);
       }
       seek(time) {
         if (!this._tracks) {
           throw new Error("Not ready yet; wait for 'ready' event");
         }
         if (this._fileStream) {
           this._fileStream.destroy();
           this._fileStream = null;
         }
         let startOffset = -1;
         this._tracks.map((track, i) => {
           if (track.outStream) {
             track.outStream.destroy();
           }
           if (track.inStream) {
             track.inStream.destroy();
             track.inStream = null;
           }
           const outStream = track.outStream = mp4.encode();
           const fragment = this._generateFragment(i, time);
           if (!fragment) {
             return outStream.finalize();
           }
           if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
             startOffset = fragment.ranges[0].start;
           }
           const writeFragment = (frag) => {
             if (outStream.destroyed)
               return;
             outStream.box(frag.moof, (err) => {
               if (err)
                 return this.emit("error", err);
               if (outStream.destroyed)
                 return;
               const slicedStream = track.inStream.slice(frag.ranges);
               slicedStream.pipe(outStream.mediaData(frag.length, (err2) => {
                 if (err2)
                   return this.emit("error", err2);
                 if (outStream.destroyed)
                   return;
                 const nextFrag = this._generateFragment(i);
                 if (!nextFrag) {
                   return outStream.finalize();
                 }
                 writeFragment(nextFrag);
               }));
             });
           };
           writeFragment(fragment);
         });
         if (startOffset >= 0) {
           const fileStream = this._fileStream = this._file.createReadStream({
             start: startOffset
           });
           this._tracks.forEach((track) => {
             track.inStream = new RangeSliceStream(startOffset, {
               highWaterMark: 1e7
             });
             fileStream.pipe(track.inStream);
           });
         }
         return this._tracks.map((track) => {
           return track.outStream;
         });
       }
       _findSampleBefore(trackInd, time) {
         const track = this._tracks[trackInd];
         const scaledTime = Math.floor(track.timeScale * time);
         let sample = bs(track.samples, scaledTime, (sample2, t) => {
           const pts = sample2.dts + sample2.presentationOffset;
           return pts - t;
         });
         if (sample === -1) {
           sample = 0;
         } else if (sample < 0) {
           sample = -sample - 2;
         }
         while (!track.samples[sample].sync) {
           sample--;
         }
         return sample;
       }
       _generateFragment(track, time) {
         const currTrack = this._tracks[track];
         let firstSample;
         if (time !== void 0) {
           firstSample = this._findSampleBefore(track, time);
         } else {
           firstSample = currTrack.currSample;
         }
         if (firstSample >= currTrack.samples.length) {
           return null;
         }
         const startDts = currTrack.samples[firstSample].dts;
         let totalLen = 0;
         const ranges = [];
         for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
           const sample = currTrack.samples[currSample];
           if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
             break;
           }
           totalLen += sample.size;
           const currRange = ranges.length - 1;
           if (currRange < 0 || ranges[currRange].end !== sample.offset) {
             ranges.push({
               start: sample.offset,
               end: sample.offset + sample.size
             });
           } else {
             ranges[currRange].end += sample.size;
           }
         }
         currTrack.currSample = currSample;
         return {
           moof: this._generateMoof(track, firstSample, currSample),
           ranges,
           length: totalLen
         };
       }
       _generateMoof(track, firstSample, lastSample) {
         const currTrack = this._tracks[track];
         const entries = [];
         let trunVersion = 0;
         for (let j = firstSample; j < lastSample; j++) {
           const currSample = currTrack.samples[j];
           if (currSample.presentationOffset < 0) {
             trunVersion = 1;
           }
           entries.push({
             sampleDuration: currSample.duration,
             sampleSize: currSample.size,
             sampleFlags: currSample.sync ? 33554432 : 16842752,
             sampleCompositionTimeOffset: currSample.presentationOffset
           });
         }
         const moof = {
           type: "moof",
           mfhd: {
             sequenceNumber: currTrack.fragmentSequence++
           },
           trafs: [{
             tfhd: {
               flags: 131072,
               trackId: currTrack.trackId
             },
             tfdt: {
               baseMediaDecodeTime: currTrack.samples[firstSample].dts
             },
             trun: {
               flags: 3841,
               dataOffset: 8,
               entries,
               version: trunVersion
             }
           }]
         };
         moof.trafs[0].trun.dataOffset += Box.encodingLength(moof);
         return moof;
       }
     };
     var RunLengthIndex = class {
       constructor(entries, countName) {
         this._entries = entries;
         this._countName = countName || "count";
         this._index = 0;
         this._offset = 0;
         this.value = this._entries[0];
       }
       inc() {
         this._offset++;
         if (this._offset >= this._entries[this._index][this._countName]) {
           this._index++;
           this._offset = 0;
         }
         this.value = this._entries[this._index];
       }
     };
     function empty() {
       return {
         version: 0,
         flags: 0,
         entries: []
       };
     }
     var MIN_FRAGMENT_DURATION = 1;
     module2.exports = MP4Remuxer;
   }
 });
 
 // node_modules/videostream/videostream.js
 var require_videostream = __commonJS({
   "node_modules/videostream/videostream.js"(exports, module2) {
     var MediaElementWrapper = require_mediasource();
     var pump = require_pump();
     var MP4Remuxer = require_mp4_remuxer();
     function VideoStream(file, mediaElem, opts = {}) {
       if (!(this instanceof VideoStream)) {
         console.warn("Don't invoke VideoStream without the 'new' keyword.");
         return new VideoStream(file, mediaElem, opts);
       }
       this.detailedError = null;
       this._elem = mediaElem;
       this._elemWrapper = new MediaElementWrapper(mediaElem);
       this._waitingFired = false;
       this._trackMeta = null;
       this._file = file;
       this._tracks = null;
       if (this._elem.preload !== "none") {
         this._createMuxer();
       }
       this._onError = () => {
         this.detailedError = this._elemWrapper.detailedError;
         this.destroy();
       };
       this._onWaiting = () => {
         this._waitingFired = true;
         if (!this._muxer) {
           this._createMuxer();
         } else if (this._tracks) {
           this._pump();
         }
       };
       if (mediaElem.autoplay) {
         mediaElem.preload = "auto";
       }
       mediaElem.addEventListener("waiting", this._onWaiting);
       mediaElem.addEventListener("error", this._onError);
     }
     VideoStream.prototype = {
       _createMuxer() {
         this._muxer = new MP4Remuxer(this._file);
         this._muxer.on("ready", (data) => {
           this._tracks = data.map((trackData) => {
             const mediaSource = this._elemWrapper.createWriteStream(trackData.mime);
             mediaSource.on("error", (err) => {
               this._elemWrapper.error(err);
             });
             const track = {
               muxed: null,
               mediaSource,
               initFlushed: false,
               onInitFlushed: null
             };
             mediaSource.write(trackData.init, (err) => {
               track.initFlushed = true;
               if (track.onInitFlushed) {
                 track.onInitFlushed(err);
               }
             });
             return track;
           });
           if (this._waitingFired || this._elem.preload === "auto") {
             this._pump();
           }
         });
         this._muxer.on("error", (err) => {
           this._elemWrapper.error(err);
         });
       },
       _pump() {
         const muxed = this._muxer.seek(this._elem.currentTime, !this._tracks);
         this._tracks.forEach((track, i) => {
           const pumpTrack = () => {
             if (track.muxed) {
               track.muxed.destroy();
               track.mediaSource = this._elemWrapper.createWriteStream(track.mediaSource);
               track.mediaSource.on("error", (err) => {
                 this._elemWrapper.error(err);
               });
             }
             track.muxed = muxed[i];
             pump(track.muxed, track.mediaSource);
           };
           if (!track.initFlushed) {
             track.onInitFlushed = (err) => {
               if (err) {
                 this._elemWrapper.error(err);
                 return;
               }
               pumpTrack();
             };
           } else {
             pumpTrack();
           }
         });
       },
       destroy() {
         if (this.destroyed) {
           return;
         }
         this.destroyed = true;
         this._elem.removeEventListener("waiting", this._onWaiting);
         this._elem.removeEventListener("error", this._onError);
         if (this._tracks) {
           this._tracks.forEach((track) => {
             if (track.muxed) {
               track.muxed.destroy();
             }
           });
         }
         this._elem.src = "";
       }
     };
     module2.exports = VideoStream;
   }
 });
 
 // node_modules/render-media/index.js
 var require_render_media = __commonJS({
   "node_modules/render-media/index.js"(exports) {
     exports.render = render;
     exports.append = append;
     exports.mime = require_mime();
     var debug = require_src()("render-media");
     var isAscii = require_is_ascii();
     var MediaElementWrapper = require_mediasource();
     var path2 = require("path");
     var streamToBlobURL = require_stream_to_blob_url();
     var VideoStream = require_videostream();
     var VIDEOSTREAM_EXTS = [
       ".m4a",
       ".m4b",
       ".m4p",
       ".m4v",
       ".mp4"
     ];
     var MEDIASOURCE_VIDEO_EXTS = [
       ".m4v",
       ".mkv",
       ".mp4",
       ".webm"
     ];
     var MEDIASOURCE_AUDIO_EXTS = [
       ".m4a",
       ".m4b",
       ".m4p",
       ".mp3"
     ];
     var MEDIASOURCE_EXTS = [].concat(
       MEDIASOURCE_VIDEO_EXTS,
       MEDIASOURCE_AUDIO_EXTS
     );
     var VIDEO_EXTS = [
       ".mov",
       ".ogv"
     ];
     var AUDIO_EXTS = [
       ".aac",
       ".oga",
       ".ogg",
       ".wav",
       ".flac"
     ];
     var IMAGE_EXTS = [
       ".bmp",
       ".gif",
       ".jpeg",
       ".jpg",
       ".png",
       ".svg"
     ];
     var IFRAME_EXTS = [
       ".css",
       ".html",
       ".js",
       ".md",
       ".pdf",
       ".srt",
       ".txt"
     ];
     var MAX_BLOB_LENGTH = 200 * 1e3 * 1e3;
     var MediaSource = typeof window !== "undefined" && window.MediaSource;
     function render(file, elem, opts, cb) {
       if (typeof opts === "function") {
         cb = opts;
         opts = {};
       }
       if (!opts)
         opts = {};
       if (!cb)
         cb = () => {
         };
       validateFile(file);
       parseOpts(opts);
       if (typeof elem === "string")
         elem = document.querySelector(elem);
       renderMedia(file, (tagName) => {
         if (elem.nodeName !== tagName.toUpperCase()) {
           const extname = path2.extname(file.name).toLowerCase();
           throw new Error(
             `Cannot render "${extname}" inside a "${elem.nodeName.toLowerCase()}" element, expected "${tagName}"`
           );
         }
         if (tagName === "video" || tagName === "audio")
           setMediaOpts(elem, opts);
         return elem;
       }, opts, cb);
     }
     function append(file, rootElem, opts, cb) {
       if (typeof opts === "function") {
         cb = opts;
         opts = {};
       }
       if (!opts)
         opts = {};
       if (!cb)
         cb = () => {
         };
       validateFile(file);
       parseOpts(opts);
       if (typeof rootElem === "string")
         rootElem = document.querySelector(rootElem);
       if (rootElem && (rootElem.nodeName === "VIDEO" || rootElem.nodeName === "AUDIO")) {
         throw new Error(
           "Invalid video/audio node argument. Argument must be root element that video/audio tag will be appended to."
         );
       }
       renderMedia(file, getElem, opts, done);
       function getElem(tagName) {
         if (tagName === "video" || tagName === "audio")
           return createMedia(tagName);
         else
           return createElem(tagName);
       }
       function createMedia(tagName) {
         const elem = createElem(tagName);
         setMediaOpts(elem, opts);
         rootElem.appendChild(elem);
         return elem;
       }
       function createElem(tagName) {
         const elem = document.createElement(tagName);
         rootElem.appendChild(elem);
         return elem;
       }
       function done(err, elem) {
         if (err && elem)
           elem.remove();
         cb(err, elem);
       }
     }
     function renderMedia(file, getElem, opts, cb) {
       const extname = path2.extname(file.name).toLowerCase();
       let currentTime = 0;
       let elem;
       if (MEDIASOURCE_EXTS.includes(extname)) {
         renderMediaSource();
       } else if (VIDEO_EXTS.includes(extname)) {
         renderMediaElement("video");
       } else if (AUDIO_EXTS.includes(extname)) {
         renderMediaElement("audio");
       } else if (IMAGE_EXTS.includes(extname)) {
         renderImage();
       } else if (IFRAME_EXTS.includes(extname)) {
         renderIframe();
       } else {
         tryRenderIframe();
       }
       function renderMediaSource() {
         const tagName = MEDIASOURCE_VIDEO_EXTS.includes(extname) ? "video" : "audio";
         if (MediaSource) {
           if (VIDEOSTREAM_EXTS.includes(extname)) {
             useVideostream();
           } else {
             useMediaSource();
           }
         } else {
           useBlobURL();
         }
         function useVideostream() {
           debug(`Use \`videostream\` package for ${file.name}`);
           prepareElem();
           elem.addEventListener("error", fallbackToMediaSource);
           elem.addEventListener("loadstart", onLoadStart);
           elem.addEventListener("loadedmetadata", onLoadedMetadata);
           new VideoStream(file, elem);
         }
         function useMediaSource() {
           debug(`Use MediaSource API for ${file.name}`);
           prepareElem();
           elem.addEventListener("error", fallbackToBlobURL);
           elem.addEventListener("loadstart", onLoadStart);
           elem.addEventListener("loadedmetadata", onLoadedMetadata);
           const wrapper = new MediaElementWrapper(elem);
           const writable = wrapper.createWriteStream(getCodec(file.name));
           file.createReadStream().pipe(writable);
           if (currentTime)
             elem.currentTime = currentTime;
         }
         function useBlobURL() {
           debug(`Use Blob URL for ${file.name}`);
           prepareElem();
           elem.addEventListener("error", fatalError);
           elem.addEventListener("loadstart", onLoadStart);
           elem.addEventListener("loadedmetadata", onLoadedMetadata);
           getBlobURL(file, (err, url) => {
             if (err)
               return fatalError(err);
             elem.src = url;
             if (currentTime)
               elem.currentTime = currentTime;
           });
         }
         function fallbackToMediaSource(err) {
           debug("videostream error: fallback to MediaSource API: %o", err.message || err);
           elem.removeEventListener("error", fallbackToMediaSource);
           elem.removeEventListener("loadedmetadata", onLoadedMetadata);
           useMediaSource();
         }
         function fallbackToBlobURL(err) {
           debug("MediaSource API error: fallback to Blob URL: %o", err.message || err);
           if (!checkBlobLength())
             return;
           elem.removeEventListener("error", fallbackToBlobURL);
           elem.removeEventListener("loadedmetadata", onLoadedMetadata);
           useBlobURL();
         }
         function prepareElem() {
           if (!elem) {
             elem = getElem(tagName);
             elem.addEventListener("progress", () => {
               currentTime = elem.currentTime;
             });
           }
         }
       }
       function checkBlobLength() {
         if (typeof file.length === "number" && file.length > opts.maxBlobLength) {
           debug(
             "File length too large for Blob URL approach: %d (max: %d)",
             file.length,
             opts.maxBlobLength
           );
           fatalError(new Error(
             `File length too large for Blob URL approach: ${file.length} (max: ${opts.maxBlobLength})`
           ));
           return false;
         }
         return true;
       }
       function renderMediaElement(type) {
         if (!checkBlobLength())
           return;
         elem = getElem(type);
         getBlobURL(file, (err, url) => {
           if (err)
             return fatalError(err);
           elem.addEventListener("error", fatalError);
           elem.addEventListener("loadstart", onLoadStart);
           elem.addEventListener("loadedmetadata", onLoadedMetadata);
           elem.src = url;
         });
       }
       function onLoadStart() {
         elem.removeEventListener("loadstart", onLoadStart);
         if (opts.autoplay) {
           const playPromise = elem.play();
           if (typeof playPromise !== "undefined")
             playPromise.catch(fatalError);
         }
       }
       function onLoadedMetadata() {
         elem.removeEventListener("loadedmetadata", onLoadedMetadata);
         cb(null, elem);
       }
       function renderImage() {
         elem = getElem("img");
         getBlobURL(file, (err, url) => {
           if (err)
             return fatalError(err);
           elem.src = url;
           elem.alt = file.name;
           cb(null, elem);
         });
       }
       function renderIframe() {
         getBlobURL(file, (err, url) => {
           if (err)
             return fatalError(err);
           if (extname !== ".pdf") {
             elem = getElem("iframe");
             elem.sandbox = "allow-forms allow-scripts";
             elem.src = url;
           } else {
             elem = getElem("object");
             elem.setAttribute("typemustmatch", true);
             elem.setAttribute("type", "application/pdf");
             elem.setAttribute("data", url);
           }
           cb(null, elem);
         });
       }
       function tryRenderIframe() {
         debug('Unknown file extension "%s" - will attempt to render into iframe', extname);
         let str = "";
         file.createReadStream({ start: 0, end: 1e3 }).setEncoding("utf8").on("data", (chunk) => {
           str += chunk;
         }).on("end", done).on("error", cb);
         function done() {
           if (isAscii(str)) {
             debug('File extension "%s" appears ascii, so will render.', extname);
             renderIframe();
           } else {
             debug('File extension "%s" appears non-ascii, will not render.', extname);
             cb(new Error(`Unsupported file type "${extname}": Cannot append to DOM`));
           }
         }
       }
       function fatalError(err) {
         err.message = `Error rendering file "${file.name}": ${err.message}`;
         debug(err.message);
         cb(err);
       }
     }
     function getBlobURL(file, cb) {
       const extname = path2.extname(file.name).toLowerCase();
       streamToBlobURL(file.createReadStream(), exports.mime[extname]).then(
         (blobUrl) => cb(null, blobUrl),
         (err) => cb(err)
       );
     }
     function validateFile(file) {
       if (file == null) {
         throw new Error("file cannot be null or undefined");
       }
       if (typeof file.name !== "string") {
         throw new Error("missing or invalid file.name property");
       }
       if (typeof file.createReadStream !== "function") {
         throw new Error("missing or invalid file.createReadStream property");
       }
     }
     function getCodec(name) {
       const extname = path2.extname(name).toLowerCase();
       return {
         ".m4a": 'audio/mp4; codecs="mp4a.40.5"',
         ".m4b": 'audio/mp4; codecs="mp4a.40.5"',
         ".m4p": 'audio/mp4; codecs="mp4a.40.5"',
         ".m4v": 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
         ".mkv": 'video/webm; codecs="avc1.640029, mp4a.40.5"',
         ".mp3": "audio/mpeg",
         ".mp4": 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
         ".webm": 'video/webm; codecs="vorbis, vp8"'
       }[extname];
     }
     function parseOpts(opts) {
       if (opts.autoplay == null)
         opts.autoplay = false;
       if (opts.muted == null)
         opts.muted = false;
       if (opts.controls == null)
         opts.controls = true;
       if (opts.maxBlobLength == null)
         opts.maxBlobLength = MAX_BLOB_LENGTH;
     }
     function setMediaOpts(elem, opts) {
       elem.autoplay = !!opts.autoplay;
       elem.muted = !!opts.muted;
       elem.controls = !!opts.controls;
     }
   }
 });
 
 // node_modules/fast-blob-stream/index.js
 var require_fast_blob_stream = __commonJS({
   "node_modules/fast-blob-stream/index.js"(exports, module2) {
     var { Readable, Writable } = require_streamx();
     require_fast_readable_async_iterator();
     function BlobReadStream(blob, opts = {}) {
       return Readable.from(blob.stream(), opts);
     }
     var BlobWriteStream = class extends Writable {
       constructor(callback, opts = {}) {
         super(Object.assign({ decodeStrings: false }, opts));
         this.chunks = [];
         const mimeType = opts.mimeType;
         this.once("close", () => {
           const blob = mimeType != null ? new Blob(this.chunks, { type: mimeType }) : new Blob(this.chunks);
           callback(blob);
           this.emit("blob", blob);
         });
       }
       _write(data, cb) {
         this.chunks.push(data);
         cb();
       }
     };
     module2.exports = { BlobWriteStream, BlobReadStream };
   }
 });
 
 // node_modules/stream-with-known-length-to-buffer/index.js
 var require_stream_with_known_length_to_buffer = __commonJS({
   "node_modules/stream-with-known-length-to-buffer/index.js"(exports, module2) {
     var once = require_once();
     module2.exports = function getBuffer(stream, length, cb) {
       cb = once(cb);
       var buf = Buffer.alloc(length);
       var offset = 0;
       stream.on("data", function(chunk) {
         chunk.copy(buf, offset);
         offset += chunk.length;
       }).on("end", function() {
         cb(null, buf);
       }).on("error", cb);
     };
   }
 });
 
 // node_modules/range-parser/index.js
 var require_range_parser = __commonJS({
   "node_modules/range-parser/index.js"(exports, module2) {
     "use strict";
     module2.exports = rangeParser;
     function rangeParser(size, str, options) {
       if (typeof str !== "string") {
         throw new TypeError("argument str must be a string");
       }
       var index = str.indexOf("=");
       if (index === -1) {
         return -2;
       }
       var arr = str.slice(index + 1).split(",");
       var ranges = [];
       ranges.type = str.slice(0, index);
       for (var i = 0; i < arr.length; i++) {
         var range = arr[i].split("-");
         var start = parseInt(range[0], 10);
         var end = parseInt(range[1], 10);
         if (isNaN(start)) {
           start = size - end;
           end = size - 1;
         } else if (isNaN(end)) {
           end = size - 1;
         }
         if (end > size - 1) {
           end = size - 1;
         }
         if (isNaN(start) || isNaN(end) || start > end || start < 0) {
           continue;
         }
         ranges.push({
           start,
           end
         });
       }
       if (ranges.length < 1) {
         return -1;
       }
       return options && options.combine ? combineRanges(ranges) : ranges;
     }
     function combineRanges(ranges) {
       var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
       for (var j = 0, i = 1; i < ordered.length; i++) {
         var range = ordered[i];
         var current = ordered[j];
         if (range.start > current.end + 1) {
           ordered[++j] = range;
         } else if (range.end > current.end) {
           current.end = range.end;
           current.index = Math.min(current.index, range.index);
         }
       }
       ordered.length = j + 1;
       var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
       combined.type = ranges.type;
       return combined;
     }
     function mapWithIndex(range, index) {
       return {
         start: range.start,
         end: range.end,
         index
       };
     }
     function mapWithoutIndex(range) {
       return {
         start: range.start,
         end: range.end
       };
     }
     function sortByRangeIndex(a, b) {
       return a.index - b.index;
     }
     function sortByRangeStart(a, b) {
       return a.start - b.start;
     }
   }
 });
 
 // node_modules/mime/Mime.js
 var require_Mime = __commonJS({
   "node_modules/mime/Mime.js"(exports, module2) {
     "use strict";
     function Mime() {
       this._types = /* @__PURE__ */ Object.create(null);
       this._extensions = /* @__PURE__ */ Object.create(null);
       for (let i = 0; i < arguments.length; i++) {
         this.define(arguments[i]);
       }
       this.define = this.define.bind(this);
       this.getType = this.getType.bind(this);
       this.getExtension = this.getExtension.bind(this);
     }
     Mime.prototype.define = function(typeMap, force) {
       for (let type in typeMap) {
         let extensions = typeMap[type].map(function(t) {
           return t.toLowerCase();
         });
         type = type.toLowerCase();
         for (let i = 0; i < extensions.length; i++) {
           const ext = extensions[i];
           if (ext[0] === "*") {
             continue;
           }
           if (!force && ext in this._types) {
             throw new Error(
               'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
             );
           }
           this._types[ext] = type;
         }
         if (force || !this._extensions[type]) {
           const ext = extensions[0];
           this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
         }
       }
     };
     Mime.prototype.getType = function(path2) {
       path2 = String(path2);
       let last = path2.replace(/^.*[/\\]/, "").toLowerCase();
       let ext = last.replace(/^.*\./, "").toLowerCase();
       let hasPath = last.length < path2.length;
       let hasDot = ext.length < last.length - 1;
       return (hasDot || !hasPath) && this._types[ext] || null;
     };
     Mime.prototype.getExtension = function(type) {
       type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
       return type && this._extensions[type.toLowerCase()] || null;
     };
     module2.exports = Mime;
   }
 });
 
 // node_modules/mime/types/standard.js
 var require_standard = __commonJS({
   "node_modules/mime/types/standard.js"(exports, module2) {
     module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
   }
 });
 
 // node_modules/mime/types/other.js
 var require_other = __commonJS({
   "node_modules/mime/types/other.js"(exports, module2) {
     module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
   }
 });
 
 // node_modules/mime/index.js
 var require_mime2 = __commonJS({
   "node_modules/mime/index.js"(exports, module2) {
     "use strict";
     var Mime = require_Mime();
     module2.exports = new Mime(require_standard(), require_other());
   }
 });
 
 // node_modules/webtorrent/lib/file-stream.js
 var require_file_stream = __commonJS({
   "node_modules/webtorrent/lib/file-stream.js"(exports, module2) {
     var { Readable } = require_streamx();
     var debugFactory = require_src();
     var debug = debugFactory("webtorrent:file-stream");
     var FileStream = class extends Readable {
       constructor(file, opts) {
         super(opts ?? {});
         this._torrent = file._torrent;
         const start = opts && opts.start || 0;
         const end = opts && opts.end && opts.end < file.length ? opts.end : file.length - 1;
         const pieceLength = file._torrent.pieceLength;
         this._startPiece = (start + file.offset) / pieceLength | 0;
         this._endPiece = (end + file.offset) / pieceLength | 0;
         this._piece = this._startPiece;
         this._offset = start + file.offset - this._startPiece * pieceLength;
         this._missing = end - start + 1;
         this._reading = false;
         this._notifying = false;
         this._criticalLength = Math.min(1024 * 1024 / pieceLength | 0, 2);
         this._torrent.select(this._startPiece, this._endPiece, true, () => {
           this._notify();
         });
       }
       _read(cb) {
         if (this._reading)
           return;
         this._reading = true;
         this._notify(cb);
       }
       _notify(cb = () => {
       }) {
         if (!this._reading || this._missing === 0)
           return cb();
         if (!this._torrent.bitfield.get(this._piece)) {
           cb();
           return this._torrent.critical(this._piece, this._piece + this._criticalLength);
         }
         if (this._notifying)
           return cb();
         this._notifying = true;
         if (this._torrent.destroyed)
           return this.destroy(new Error("Torrent removed"));
         const p = this._piece;
         const getOpts = {};
         if (p === this._torrent.pieces.length - 1) {
           getOpts.length = this._torrent.lastPieceLength;
         }
         this._torrent.store.get(p, getOpts, (err, buffer) => {
           this._notifying = false;
           if (this.destroyed)
             return;
           debug("read %s (length %s) (err %s)", p, buffer && buffer.length, err && err.message);
           if (err)
             return this.destroy(err);
           if (this._offset) {
             buffer = buffer.slice(this._offset);
             this._offset = 0;
           }
           if (this._missing < buffer.length) {
             buffer = buffer.slice(0, this._missing);
           }
           this._missing -= buffer.length;
           debug("pushing buffer of length %s", buffer.length);
           this._reading = false;
           this.push(buffer);
           if (this._missing === 0)
             this.push(null);
           cb();
         });
         this._piece += 1;
       }
       _destroy(cb, err) {
         if (!this._torrent.destroyed) {
           this._torrent.deselect(this._startPiece, this._endPiece, true);
         }
         cb(err);
       }
     };
     module2.exports = FileStream;
   }
 });
 
 // node_modules/webtorrent/lib/file.js
 var require_file = __commonJS({
   "node_modules/webtorrent/lib/file.js"(exports, module2) {
     var EventEmitter = require("events");
     var { PassThrough } = require_streamx();
     var path2 = require("path");
     var render = require_render_media();
     var { BlobWriteStream } = require_fast_blob_stream();
     var streamToBuffer = require_stream_with_known_length_to_buffer();
     var queueMicrotask3 = require_queue_microtask();
     var rangeParser = require_range_parser();
     var mime = require_mime2();
     var eos = require_end_of_stream2();
     var FileStream = require_file_stream();
     var File = class extends EventEmitter {
       constructor(torrent, file) {
         super();
         this._torrent = torrent;
         this._destroyed = false;
         this._fileStreams = /* @__PURE__ */ new Set();
         this.name = file.name;
         this.path = file.path;
         this.length = file.length;
         this.offset = file.offset;
         this.done = false;
         const start = file.offset;
         const end = start + file.length - 1;
         this._startPiece = start / this._torrent.pieceLength | 0;
         this._endPiece = end / this._torrent.pieceLength | 0;
         if (this.length === 0) {
           this.done = true;
           this.emit("done");
         }
         this._serviceWorker = torrent.client.serviceWorker;
       }
       get downloaded() {
         if (this._destroyed || !this._torrent.bitfield)
           return 0;
         const { pieces, bitfield, pieceLength, lastPieceLength } = this._torrent;
         const { _startPiece: start, _endPiece: end } = this;
         const getPieceLength = (pieceIndex) => pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;
         const getPieceDownloaded = (pieceIndex) => {
           const len = pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;
           if (bitfield.get(pieceIndex)) {
             return len;
           } else {
             return len - pieces[pieceIndex].missing;
           }
         };
         let downloaded = 0;
         for (let index = start; index <= end; index += 1) {
           const pieceDownloaded = getPieceDownloaded(index);
           downloaded += pieceDownloaded;
           if (index === start) {
             const irrelevantFirstPieceBytes = this.offset % pieceLength;
             downloaded -= Math.min(irrelevantFirstPieceBytes, pieceDownloaded);
           }
           if (index === end) {
             const irrelevantLastPieceBytes = getPieceLength(end) - (this.offset + this.length) % pieceLength;
             downloaded -= Math.min(irrelevantLastPieceBytes, pieceDownloaded);
           }
         }
         return downloaded;
       }
       get progress() {
         return this.length ? this.downloaded / this.length : 0;
       }
       select(priority) {
         if (this.length === 0)
           return;
         this._torrent.select(this._startPiece, this._endPiece, priority);
       }
       deselect() {
         if (this.length === 0)
           return;
         this._torrent.deselect(this._startPiece, this._endPiece, false);
       }
       createReadStream(opts) {
         if (this.length === 0) {
           const empty = new PassThrough();
           queueMicrotask3(() => {
             empty.end();
           });
           return empty;
         }
         const fileStream = new FileStream(this, opts);
         this._fileStreams.add(fileStream);
         fileStream.once("close", () => {
           this._fileStreams.delete(fileStream);
         });
         return fileStream;
       }
       getBuffer(cb) {
         streamToBuffer(this.createReadStream(), this.length, cb);
       }
       getBlob(cb) {
         if (typeof window === "undefined")
           throw new Error("browser-only method");
         const writeStream = new BlobWriteStream((blob) => {
           cb(null, blob);
         }, { mimeType: this._getMimeType() });
         this.createReadStream().pipe(writeStream);
       }
       getBlobURL(cb) {
         this.getBlob((_err, blob) => {
           cb(null, URL.createObjectURL(blob));
         });
       }
       appendTo(elem, opts, cb) {
         if (typeof window === "undefined")
           throw new Error("browser-only method");
         render.append(this, elem, opts, cb);
       }
       renderTo(elem, opts, cb) {
         if (typeof window === "undefined")
           throw new Error("browser-only method");
         render.render(this, elem, opts, cb);
       }
       _serve(req) {
         const res = {
           status: 200,
           headers: {
             "Accept-Ranges": "bytes",
             "Content-Type": mime.getType(this.name),
             "Cache-Control": "no-cache, no-store, must-revalidate, max-age=0",
             Expires: "0"
           },
           body: req.method === "HEAD" ? "" : "STREAM"
         };
         if (req.destination === "document") {
           res.headers["Content-Type"] = "application/octet-stream";
           res.headers["Content-Disposition"] = "attachment";
           res.body = "DOWNLOAD";
         }
         let range = rangeParser(this.length, req.headers.range || "");
         if (range.constructor === Array) {
           res.status = 206;
           range = range[0];
           res.headers["Content-Range"] = `bytes ${range.start}-${range.end}/${this.length}`;
           res.headers["Content-Length"] = `${range.end - range.start + 1}`;
         } else {
           res.headers["Content-Length"] = this.length;
         }
         const stream = req.method === "GET" && this.createReadStream(range);
         let pipe = null;
         if (stream) {
           this.emit("stream", { stream, req, file: this }, (piped) => {
             pipe = piped;
             eos(piped, () => {
               if (piped)
                 piped.destroy();
               stream.destroy();
             });
           });
         }
         return [res, pipe || stream, pipe && stream];
       }
       getStreamURL(cb = () => {
       }) {
         if (typeof window === "undefined")
           throw new Error("browser-only method");
         if (!this._serviceWorker)
           throw new Error("No worker registered");
         if (this._serviceWorker.state !== "activated")
           throw new Error("Worker isn't activated");
         const workerPath = this._serviceWorker.scriptURL.slice(0, this._serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length);
         const url = `${workerPath}webtorrent/${this._torrent.infoHash}/${encodeURI(this.path)}`;
         cb(null, url);
       }
       streamTo(elem, cb = () => {
       }) {
         if (typeof window === "undefined")
           throw new Error("browser-only method");
         if (!this._serviceWorker)
           throw new Error("No worker registered");
         if (this._serviceWorker.state !== "activated")
           throw new Error("Worker isn't activated");
         const workerPath = this._serviceWorker.scriptURL.slice(0, this._serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length);
         elem.src = `${workerPath}webtorrent/${this._torrent.infoHash}/${encodeURI(this.path)}`;
         cb(null, elem);
       }
       _getMimeType() {
         return render.mime[path2.extname(this.name).toLowerCase()];
       }
       _destroy() {
         this._destroyed = true;
         this._torrent = null;
         for (const fileStream of this._fileStreams) {
           fileStream.destroy();
         }
         this._fileStreams.clear();
       }
     };
     module2.exports = File;
   }
 });
 
 // node_modules/webtorrent/lib/rarity-map.js
 var require_rarity_map = __commonJS({
   "node_modules/webtorrent/lib/rarity-map.js"(exports, module2) {
     var RarityMap = class {
       constructor(torrent) {
         this._torrent = torrent;
         this._numPieces = torrent.pieces.length;
         this._pieces = new Array(this._numPieces);
         this._onWire = (wire) => {
           this.recalculate();
           this._initWire(wire);
         };
         this._onWireHave = (index) => {
           this._pieces[index] += 1;
         };
         this._onWireBitfield = () => {
           this.recalculate();
         };
         this._torrent.wires.forEach((wire) => {
           this._initWire(wire);
         });
         this._torrent.on("wire", this._onWire);
         this.recalculate();
       }
       getRarestPiece(pieceFilterFunc) {
         let candidates = [];
         let min = Infinity;
         for (let i = 0; i < this._numPieces; ++i) {
           if (pieceFilterFunc && !pieceFilterFunc(i))
             continue;
           const availability = this._pieces[i];
           if (availability === min) {
             candidates.push(i);
           } else if (availability < min) {
             candidates = [i];
             min = availability;
           }
         }
         if (candidates.length) {
           return candidates[Math.random() * candidates.length | 0];
         } else {
           return -1;
         }
       }
       destroy() {
         this._torrent.removeListener("wire", this._onWire);
         this._torrent.wires.forEach((wire) => {
           this._cleanupWireEvents(wire);
         });
         this._torrent = null;
         this._pieces = null;
         this._onWire = null;
         this._onWireHave = null;
         this._onWireBitfield = null;
       }
       _initWire(wire) {
         wire._onClose = () => {
           this._cleanupWireEvents(wire);
           for (let i = 0; i < this._numPieces; ++i) {
             this._pieces[i] -= wire.peerPieces.get(i);
           }
         };
         wire.on("have", this._onWireHave);
         wire.on("bitfield", this._onWireBitfield);
         wire.once("close", wire._onClose);
       }
       recalculate() {
         this._pieces.fill(0);
         for (const wire of this._torrent.wires) {
           for (let i = 0; i < this._numPieces; ++i) {
             this._pieces[i] += wire.peerPieces.get(i);
           }
         }
       }
       _cleanupWireEvents(wire) {
         wire.removeListener("have", this._onWireHave);
         wire.removeListener("bitfield", this._onWireBitfield);
         if (wire._onClose)
           wire.removeListener("close", wire._onClose);
         wire._onClose = null;
       }
     };
     module2.exports = RarityMap;
   }
 });
 
 // node_modules/escape-html/index.js
 var require_escape_html = __commonJS({
   "node_modules/escape-html/index.js"(exports, module2) {
     "use strict";
     var matchHtmlRegExp = /["'&<>]/;
     module2.exports = escapeHtml;
     function escapeHtml(string) {
       var str = "" + string;
       var match = matchHtmlRegExp.exec(str);
       if (!match) {
         return str;
       }
       var escape2;
       var html = "";
       var index = 0;
       var lastIndex = 0;
       for (index = match.index; index < str.length; index++) {
         switch (str.charCodeAt(index)) {
           case 34:
             escape2 = "&quot;";
             break;
           case 38:
             escape2 = "&amp;";
             break;
           case 39:
             escape2 = "&#39;";
             break;
           case 60:
             escape2 = "&lt;";
             break;
           case 62:
             escape2 = "&gt;";
             break;
           default:
             continue;
         }
         if (lastIndex !== index) {
           html += str.substring(lastIndex, index);
         }
         lastIndex = index + 1;
         html += escape2;
       }
       return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
     }
   }
 });
 
 // node_modules/webtorrent/lib/server.js
 var require_server = __commonJS({
   "node_modules/webtorrent/lib/server.js"(exports, module2) {
     var http = require("http");
     var escapeHtml = require_escape_html();
     var mime = require_mime2();
     var pump = require_pump();
     var rangeParser = require_range_parser();
     var queueMicrotask3 = require_queue_microtask();
     function Server(torrent, opts = {}) {
       const server = http.createServer();
       if (!opts.origin)
         opts.origin = "*";
       const sockets = /* @__PURE__ */ new Set();
       const pendingReady = /* @__PURE__ */ new Set();
       let closed = false;
       const _listen = server.listen;
       const _close = server.close;
       server.listen = (...args) => {
         closed = false;
         server.on("connection", onConnection);
         server.on("request", onRequest);
         return _listen.apply(server, args);
       };
       server.close = (cb) => {
         closed = true;
         server.removeListener("connection", onConnection);
         server.removeListener("request", onRequest);
         pendingReady.forEach((onReady) => {
           torrent.removeListener("ready", onReady);
         });
         pendingReady.clear();
         _close.call(server, cb);
       };
       server.destroy = (cb) => {
         sockets.forEach((socket) => {
           socket.destroy();
         });
         if (!cb)
           cb = () => {
           };
         if (closed)
           queueMicrotask3(cb);
         else
           server.close(cb);
         torrent = null;
       };
       function isOriginAllowed(req) {
         if (opts.origin === false)
           return false;
         if (req.headers.origin == null)
           return false;
         if (opts.origin === "*")
           return true;
         return req.headers.origin === opts.origin;
       }
       function onConnection(socket) {
         socket.setTimeout(36e6);
         sockets.add(socket);
         socket.once("close", () => {
           sockets.delete(socket);
         });
       }
       function onRequest(req, res) {
         if (opts.hostname && req.headers.host !== `${opts.hostname}:${server.address().port}`) {
           return req.destroy();
         }
         const pathname = new URL(req.url, "http://example.com").pathname;
         if (isOriginAllowed(req)) {
           res.setHeader("Access-Control-Allow-Origin", req.headers.origin);
         }
         res.setHeader("X-Content-Type-Options", "nosniff");
         res.setHeader("Content-Security-Policy", "base-uri 'none'; default-src 'none'; frame-ancestors 'none'; form-action 'none';");
         if (pathname === "/favicon.ico") {
           return serve404Page();
         }
         if (req.method === "OPTIONS") {
           if (isOriginAllowed(req))
             return serveOptionsRequest();
           else
             return serveMethodNotAllowed();
         }
         if (req.method === "GET" || req.method === "HEAD") {
           if (torrent.ready) {
             return handleRequest();
           } else {
             pendingReady.add(onReady);
             torrent.once("ready", onReady);
             return;
           }
         }
         return serveMethodNotAllowed();
         function serveOptionsRequest() {
           res.statusCode = 204;
           res.setHeader("Access-Control-Max-Age", "600");
           res.setHeader("Access-Control-Allow-Methods", "GET,HEAD");
           if (req.headers["access-control-request-headers"]) {
             res.setHeader(
               "Access-Control-Allow-Headers",
               req.headers["access-control-request-headers"]
             );
           }
           res.end();
         }
         function onReady() {
           pendingReady.delete(onReady);
           handleRequest();
         }
         function handleRequest() {
           if (pathname === "/") {
             return serveIndexPage();
           }
           const index = Number(pathname.split("/")[1]);
           if (Number.isNaN(index) || index >= torrent.files.length) {
             return serve404Page();
           }
           const file = torrent.files[index];
           serveFile(file);
         }
         function serveIndexPage() {
           res.statusCode = 200;
           res.setHeader("Content-Type", "text/html");
           const listHtml = torrent.files.map((file, i) => `<li>
             <a
               download="${escapeHtml(file.name)}"
               href="${escapeHtml(i)}/${escapeHtml(file.name)}"
             >
               ${escapeHtml(file.path)}
             </a>
             (${escapeHtml(file.length)} bytes)
           </li>`).join("<br>");
           const html = getPageHTML(
             `${escapeHtml(torrent.name)} - WebTorrent`,
             `
           <h1>${escapeHtml(torrent.name)}</h1>
           <ol>${listHtml}</ol>
         `
           );
           res.end(html);
         }
         function serve404Page() {
           res.statusCode = 404;
           res.setHeader("Content-Type", "text/html");
           const html = getPageHTML(
             "404 - Not Found",
             "<h1>404 - Not Found</h1>"
           );
           res.end(html);
         }
         function serveFile(file) {
           res.setHeader("Content-Type", mime.getType(file.name) || "application/octet-stream");
           res.setHeader("Accept-Ranges", "bytes");
           res.setHeader(
             "Content-Disposition",
             `inline; filename*=UTF-8''${encodeRFC5987(file.name)}`
           );
           res.setHeader("transferMode.dlna.org", "Streaming");
           res.setHeader(
             "contentFeatures.dlna.org",
             "DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01700000000000000000000000000000"
           );
           let range = rangeParser(file.length, req.headers.range || "");
           if (Array.isArray(range)) {
             res.statusCode = 206;
             range = range[0];
             res.setHeader(
               "Content-Range",
               `bytes ${range.start}-${range.end}/${file.length}`
             );
             res.setHeader("Content-Length", range.end - range.start + 1);
           } else {
             res.statusCode = 200;
             range = null;
             res.setHeader("Content-Length", file.length);
           }
           if (req.method === "HEAD") {
             return res.end();
           }
           pump(file.createReadStream(range), res);
         }
         function serveMethodNotAllowed() {
           res.statusCode = 405;
           res.setHeader("Content-Type", "text/html");
           const html = getPageHTML(
             "405 - Method Not Allowed",
             "<h1>405 - Method Not Allowed</h1>"
           );
           res.end(html);
         }
       }
       return server;
     }
     function getPageHTML(title, pageHtml) {
       return `
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="utf-8">
         <title>${title}</title>
       </head>
       <body>
         ${pageHtml}
       </body>
     </html>
   `;
     }
     function encodeRFC5987(str) {
       return encodeURIComponent(str).replace(/['()]/g, escape).replace(/\*/g, "%2A").replace(/%(?:7C|60|5E)/g, unescape);
     }
     module2.exports = Server;
   }
 });
 
 // node_modules/webtorrent/package.json
 var require_package = __commonJS({
   "node_modules/webtorrent/package.json"(exports, module2) {
     module2.exports = {
       name: "webtorrent",
       description: "Streaming torrent client",
       version: "1.9.6",
       author: {
         name: "WebTorrent LLC",
         email: "feross@webtorrent.io",
         url: "https://webtorrent.io"
       },
       browser: {
         "./lib/server.js": false,
         "./lib/conn-pool.js": false,
         "./lib/utp.js": false,
         "bittorrent-dht/client": false,
         fs: false,
         "fs-chunk-store": "memory-chunk-store",
         "load-ip-set": false,
         net: false,
         os: false,
         ut_pex: false
       },
       browserify: {
         transform: [
           "package-json-versionify"
         ]
       },
       bugs: {
         url: "https://github.com/webtorrent/webtorrent/issues"
       },
       chromeapp: {
         "./lib/utp.js": false,
         "fs-chunk-store": "memory-chunk-store",
         http: "@webtorrent/http-node",
         "load-ip-set": false,
         net: "chrome-net",
         os: false
       },
       dependencies: {
         "@webtorrent/http-node": "^1.3.0",
         "addr-to-ip-port": "^1.5.4",
         bitfield: "^4.1.0",
         "bittorrent-dht": "^10.0.6",
         "bittorrent-protocol": "^3.5.5",
         "cache-chunk-store": "^3.2.2",
         "chrome-net": "^3.3.4",
         "chunk-store-stream": "^4.3.0",
         cpus: "^1.0.3",
         "create-torrent": "^5.0.9",
         debug: "^4.3.4",
         "end-of-stream": "^1.4.4",
         "escape-html": "^1.0.3",
         "fast-blob-stream": "^1.1.1",
         "fs-chunk-store": "^3.0.1",
         "immediate-chunk-store": "^2.2.0",
         "join-async-iterator": "^1.1.1",
         "load-ip-set": "^2.2.1",
         lt_donthave: "^1.0.1",
         "memory-chunk-store": "^1.3.5",
         mime: "^3.0.0",
         "package-json-versionify": "^1.0.4",
         "parse-torrent": "^9.1.5",
         pump: "^3.0.0",
         "queue-microtask": "^1.2.3",
         "random-iterate": "^1.0.1",
         randombytes: "^2.1.0",
         "range-parser": "^1.2.1",
         "render-media": "^4.1.0",
         "run-parallel": "^1.2.0",
         "run-parallel-limit": "^1.1.0",
         "simple-concat": "^1.0.1",
         "simple-get": "^4.0.1",
         "simple-peer": "^9.11.1",
         "simple-sha1": "^3.1.0",
         "speed-limiter": "^1.0.2",
         "stream-with-known-length-to-buffer": "^1.0.4",
         streamx: "^2.12.5",
         throughput: "^1.0.1",
         "torrent-discovery": "^9.4.14",
         "torrent-piece": "^2.0.1",
         "unordered-array-remove": "^1.0.2",
         ut_metadata: "^3.5.2",
         ut_pex: "^3.0.2"
       },
       devDependencies: {
         "@webtorrent/semantic-release-config": "1.0.8",
         airtap: "4.0.4",
         "airtap-manual": "1.0.0",
         "airtap-sauce": "1.1.2",
         "babel-minify": "0.5.2",
         "bittorrent-tracker": "9.19.0",
         browserify: "17.0.0",
         disc: "1.3.3",
         finalhandler: "1.2.0",
         "network-address": "1.1.2",
         "run-series": "1.1.9",
         "semantic-release": "19.0.5",
         "serve-static": "1.15.0",
         standard: "*",
         tape: "5.6.1",
         "webtorrent-fixtures": "1.7.5"
       },
       optionalDependencies: {
         "utp-native": "^2.5.3"
       },
       engines: {
         node: ">=14"
       },
       funding: [
         {
           type: "github",
           url: "https://github.com/sponsors/feross"
         },
         {
           type: "patreon",
           url: "https://www.patreon.com/feross"
         },
         {
           type: "consulting",
           url: "https://feross.org/support"
         }
       ],
       homepage: "https://webtorrent.io",
       keywords: [
         "bittorrent",
         "bittorrent client",
         "download",
         "mad science",
         "p2p",
         "peer-to-peer",
         "peers",
         "streaming",
         "swarm",
         "torrent",
         "web torrent",
         "webrtc",
         "webrtc data",
         "webtorrent"
       ],
       license: "MIT",
       main: "index.js",
       repository: {
         type: "git",
         url: "git://github.com/webtorrent/webtorrent.git"
       },
       scripts: {
         build: "npm run build-js && npm run build-js-worker && npm run build-chromeapp",
         "build-chromeapp": "browserify --browser-field=chromeapp --standalone WebTorrent . | minify --mangle=false > webtorrent.chromeapp.js",
         "build-chromeapp-debug": "browserify --browser-field=chromeapp --standalone WebTorrent . > webtorrent.chromeapp.js",
         "build-js": "browserify --standalone WebTorrent . | minify --mangle=false > webtorrent.min.js",
         "build-js-worker": "browserify ./lib/worker.js | minify --mangle=false > sw.min.js",
         "build-js-debug": "browserify --standalone WebTorrent . > webtorrent.debug.js",
         "build-js-worker-debug": "browserify ./lib/worker.js > sw.debug.js",
         prepublishOnly: "npm run build && npm run update-authors",
         preversion: "npm run build && npm run update-authors",
         size: "npm run size-js && npm run size-disc",
         "size-disc": "browserify --full-paths . | discify --open",
         "size-js": "npm run build && cat webtorrent.min.js | gzip | wc -c",
         test: "standard && npm run test-node && npm run test-browser",
         "test-browser": "airtap --concurrency 1 -- test/*.js test/browser/*.js",
         "test-browser-local": "airtap --preset local -- test/*.js test/browser/*.js",
         "test-node": "tape test/*.js test/node/*.js",
         "update-authors": "./scripts/update-authors.sh"
       },
       standard: {
         ignore: [
           "webtorrent.min.js",
           "sw.min.js",
           "webtorrent.chromeapp.js"
         ]
       },
       renovate: {
         extends: [
           "github>webtorrent/renovate-config"
         ],
         rangeStrategy: "bump"
       },
       release: {
         extends: "@webtorrent/semantic-release-config"
       }
     };
   }
 });
 
 // node_modules/webtorrent/lib/webconn.js
 var require_webconn = __commonJS({
   "node_modules/webtorrent/lib/webconn.js"(exports, module2) {
     var { default: BitField } = require_lib2();
     var debugFactory = require_src();
     var get = require_simple_get();
     var ltDontHave = require_lt_donthave();
     var sha1 = require_simple_sha1();
     var Wire = require_bittorrent_protocol();
     var debug = debugFactory("webtorrent:webconn");
     var VERSION = require_package().version;
     var SOCKET_TIMEOUT = 6e4;
     var RETRY_DELAY = 1e4;
     var WebConn = class extends Wire {
       constructor(url, torrent) {
         super();
         this.url = url;
         this.connId = url;
         this.webPeerId = sha1.sync(url);
         this._torrent = torrent;
         this._init();
       }
       _init() {
         this.setKeepAlive(true);
         this.use(ltDontHave());
         this.once("handshake", (infoHash, peerId) => {
           if (this.destroyed)
             return;
           this.handshake(infoHash, this.webPeerId);
           const numPieces = this._torrent.pieces.length;
           const bitfield = new BitField(numPieces);
           for (let i = 0; i <= numPieces; i++) {
             bitfield.set(i, true);
           }
           this.bitfield(bitfield);
         });
         this.once("interested", () => {
           debug("interested");
           this.unchoke();
         });
         this.on("uninterested", () => {
           debug("uninterested");
         });
         this.on("choke", () => {
           debug("choke");
         });
         this.on("unchoke", () => {
           debug("unchoke");
         });
         this.on("bitfield", () => {
           debug("bitfield");
         });
         this.lt_donthave.on("donthave", () => {
           debug("donthave");
         });
         this.on("request", (pieceIndex, offset, length, callback) => {
           debug("request pieceIndex=%d offset=%d length=%d", pieceIndex, offset, length);
           this.httpRequest(pieceIndex, offset, length, (err, data) => {
             if (err) {
               this.lt_donthave.donthave(pieceIndex);
               const retryTimeout = setTimeout(() => {
                 if (this.destroyed)
                   return;
                 this.have(pieceIndex);
               }, RETRY_DELAY);
               if (retryTimeout.unref)
                 retryTimeout.unref();
             }
             callback(err, data);
           });
         });
       }
       httpRequest(pieceIndex, offset, length, cb) {
         const pieceOffset = pieceIndex * this._torrent.pieceLength;
         const rangeStart = pieceOffset + offset;
         const rangeEnd = rangeStart + length - 1;
         const files = this._torrent.files;
         let requests;
         if (files.length <= 1) {
           requests = [{
             url: this.url,
             start: rangeStart,
             end: rangeEnd
           }];
         } else {
           const requestedFiles = files.filter((file) => file.offset <= rangeEnd && file.offset + file.length > rangeStart);
           if (requestedFiles.length < 1) {
             return cb(new Error("Could not find file corresponding to web seed range request"));
           }
           requests = requestedFiles.map((requestedFile) => {
             const fileEnd = requestedFile.offset + requestedFile.length - 1;
             const url = this.url + (this.url[this.url.length - 1] === "/" ? "" : "/") + requestedFile.path.replace(this._torrent.path, "");
             return {
               url,
               fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
               start: Math.max(rangeStart - requestedFile.offset, 0),
               end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
             };
           });
         }
         let numRequestsSucceeded = 0;
         let hasError = false;
         let ret;
         if (requests.length > 1) {
           ret = Buffer.alloc(length);
         }
         requests.forEach((request) => {
           const url = request.url;
           const start = request.start;
           const end = request.end;
           debug(
             "Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d",
             url,
             pieceIndex,
             offset,
             length,
             start,
             end
           );
           const opts = {
             url,
             method: "GET",
             headers: {
               "user-agent": `WebTorrent/${VERSION} (https://webtorrent.io)`,
               range: `bytes=${start}-${end}`
             },
             timeout: SOCKET_TIMEOUT
           };
           function onResponse(res, data) {
             if (res.statusCode < 200 || res.statusCode >= 300) {
               if (hasError)
                 return;
               hasError = true;
               return cb(new Error(`Unexpected HTTP status code ${res.statusCode}`));
             }
             debug("Got data of length %d", data.length);
             if (requests.length === 1) {
               cb(null, data);
             } else {
               data.copy(ret, request.fileOffsetInRange);
               if (++numRequestsSucceeded === requests.length) {
                 cb(null, ret);
               }
             }
           }
           get.concat(opts, (err, res, data) => {
             if (hasError)
               return;
             if (err) {
               if (typeof window === "undefined" || url.startsWith(`${window.location.origin}/`)) {
                 hasError = true;
                 return cb(err);
               }
               return get.head(url, (errHead, res2) => {
                 if (hasError)
                   return;
                 if (errHead) {
                   hasError = true;
                   return cb(errHead);
                 }
                 if (res2.statusCode < 200 || res2.statusCode >= 300) {
                   hasError = true;
                   return cb(new Error(`Unexpected HTTP status code ${res2.statusCode}`));
                 }
                 if (res2.url === url) {
                   hasError = true;
                   return cb(err);
                 }
                 opts.url = res2.url;
                 get.concat(opts, (err2, res3, data2) => {
                   if (hasError)
                     return;
                   if (err2) {
                     hasError = true;
                     return cb(err2);
                   }
                   onResponse(res3, data2);
                 });
               });
             }
             onResponse(res, data);
           });
         });
       }
       destroy() {
         super.destroy();
         this._torrent = null;
       }
     };
     module2.exports = WebConn;
   }
 });
 
 // node_modules/webtorrent/lib/torrent.js
 var require_torrent = __commonJS({
   "node_modules/webtorrent/lib/torrent.js"(exports, module2) {
     var EventEmitter = require("events");
     var fs2 = require("fs");
     var net = require("net");
     var os2 = require("os");
     var path2 = require("path");
     var addrToIPPort = require_addr_to_ip_port();
     var { default: BitField } = require_lib2();
     var CacheChunkStore = require_cache_chunk_store();
     var ChunkStoreWriteStream = require_write();
     var cpus = require_cpus();
     var debugFactory = require_src();
     var Discovery = require_torrent_discovery();
     var FSChunkStore = require_fs_chunk_store();
     var get = require_simple_get();
     var ImmediateChunkStore = require_immediate_chunk_store();
     var ltDontHave = require_lt_donthave();
     var MemoryChunkStore = require_memory_chunk_store();
     var joinIterator = require_join_async_iterator();
     var parallel2 = require_run_parallel();
     var parallelLimit = require_run_parallel_limit();
     var parseTorrent = require_parse_torrent();
     var Piece = require_torrent_piece();
     var pump = require_pump();
     var queueMicrotask3 = require_queue_microtask();
     var randomIterate = require_random_iterate();
     var sha1 = require_simple_sha1();
     var throughput = require_throughput();
     var utMetadata = require_ut_metadata();
     var utPex = require_ut_pex();
     var { Readable } = require_streamx();
     var File = require_file();
     var Peer = require_peer();
     var RarityMap = require_rarity_map();
     var Server = require_server();
     var utp = require_utp();
     var WebConn = require_webconn();
     var debug = debugFactory("webtorrent:torrent");
     var MAX_BLOCK_LENGTH = 128 * 1024;
     var PIECE_TIMEOUT = 3e4;
     var CHOKE_TIMEOUT = 5e3;
     var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH;
     var PIPELINE_MIN_DURATION = 0.5;
     var PIPELINE_MAX_DURATION = 1;
     var RECHOKE_INTERVAL = 1e4;
     var RECHOKE_OPTIMISTIC_DURATION = 2;
     var FILESYSTEM_CONCURRENCY = process.browser ? cpus().length : 2;
     var RECONNECT_WAIT = [1e3, 5e3, 15e3];
     var VERSION = require_package().version;
     var USER_AGENT = `WebTorrent/${VERSION} (https://webtorrent.io)`;
     var TMP2;
     try {
       TMP2 = path2.join(fs2.statSync("/tmp") && "/tmp", "webtorrent");
     } catch (err) {
       TMP2 = path2.join(typeof os2.tmpdir === "function" ? os2.tmpdir() : "/", "webtorrent");
     }
     var Torrent = class extends EventEmitter {
       constructor(torrentId, client, opts) {
         super();
         this._debugId = "unknown infohash";
         this.client = client;
         this.announce = opts.announce;
         this.urlList = opts.urlList;
         this.path = opts.path || TMP2;
         this.addUID = opts.addUID || false;
         this.skipVerify = !!opts.skipVerify;
         this._store = opts.store || FSChunkStore;
         this._preloadedStore = opts.preloadedStore || null;
         this._storeCacheSlots = opts.storeCacheSlots !== void 0 ? opts.storeCacheSlots : 20;
         this._destroyStoreOnDestroy = opts.destroyStoreOnDestroy || false;
         this._getAnnounceOpts = opts.getAnnounceOpts;
         if (typeof opts.private === "boolean")
           this.private = opts.private;
         this.strategy = opts.strategy || "sequential";
         this.maxWebConns = opts.maxWebConns || 4;
         this._rechokeNumSlots = opts.uploads === false || opts.uploads === 0 ? 0 : +opts.uploads || 10;
         this._rechokeOptimisticWire = null;
         this._rechokeOptimisticTime = 0;
         this._rechokeIntervalId = null;
         this.ready = false;
         this.destroyed = false;
         this.paused = opts.paused || false;
         this.done = false;
         this.metadata = null;
         this.store = null;
         this.storeOpts = opts.storeOpts;
         this.files = [];
         this.pieces = [];
         this._amInterested = false;
         this._selections = [];
         this._critical = [];
         this.wires = [];
         this._queue = [];
         this._peers = {};
         this._peersLength = 0;
         this.received = 0;
         this.uploaded = 0;
         this._downloadSpeed = throughput();
         this._uploadSpeed = throughput();
         this._servers = [];
         this._xsRequests = [];
         this._fileModtimes = opts.fileModtimes;
         if (torrentId !== null)
           this._onTorrentId(torrentId);
         this._debug("new torrent");
       }
       get timeRemaining() {
         if (this.done)
           return 0;
         if (this.downloadSpeed === 0)
           return Infinity;
         return (this.length - this.downloaded) / this.downloadSpeed * 1e3;
       }
       get downloaded() {
         if (!this.bitfield)
           return 0;
         let downloaded = 0;
         for (let index = 0, len = this.pieces.length; index < len; ++index) {
           if (this.bitfield.get(index)) {
             downloaded += index === len - 1 ? this.lastPieceLength : this.pieceLength;
           } else {
             const piece = this.pieces[index];
             downloaded += piece.length - piece.missing;
           }
         }
         return downloaded;
       }
       get downloadSpeed() {
         return this._downloadSpeed();
       }
       get uploadSpeed() {
         return this._uploadSpeed();
       }
       get progress() {
         return this.length ? this.downloaded / this.length : 0;
       }
       get ratio() {
         return this.uploaded / (this.received || this.length);
       }
       get numPeers() {
         return this.wires.length;
       }
       get torrentFileBlobURL() {
         if (typeof window === "undefined")
           throw new Error("browser-only property");
         if (!this.torrentFile)
           return null;
         return URL.createObjectURL(
           new Blob([this.torrentFile], { type: "application/x-bittorrent" })
         );
       }
       get _numQueued() {
         return this._queue.length + (this._peersLength - this._numConns);
       }
       get _numConns() {
         let numConns = 0;
         for (const id in this._peers) {
           if (this._peers[id].connected)
             numConns += 1;
         }
         return numConns;
       }
       _onTorrentId(torrentId) {
         if (this.destroyed)
           return;
         let parsedTorrent;
         try {
           parsedTorrent = parseTorrent(torrentId);
         } catch (err) {
         }
         if (parsedTorrent) {
           this.infoHash = parsedTorrent.infoHash;
           this._debugId = parsedTorrent.infoHash.toString("hex").substring(0, 7);
           queueMicrotask3(() => {
             if (this.destroyed)
               return;
             this._onParsedTorrent(parsedTorrent);
           });
         } else {
           parseTorrent.remote(torrentId, (err, parsedTorrent2) => {
             if (this.destroyed)
               return;
             if (err)
               return this._destroy(err);
             this._onParsedTorrent(parsedTorrent2);
           });
         }
       }
       _onParsedTorrent(parsedTorrent) {
         if (this.destroyed)
           return;
         this._processParsedTorrent(parsedTorrent);
         if (!this.infoHash) {
           return this._destroy(new Error("Malformed torrent data: No info hash"));
         }
         this._rechokeIntervalId = setInterval(() => {
           this._rechoke();
         }, RECHOKE_INTERVAL);
         if (this._rechokeIntervalId.unref)
           this._rechokeIntervalId.unref();
         this.emit("_infoHash", this.infoHash);
         if (this.destroyed)
           return;
         this.emit("infoHash", this.infoHash);
         if (this.destroyed)
           return;
         if (this.client.listening) {
           this._onListening();
         } else {
           this.client.once("listening", () => {
             this._onListening();
           });
         }
       }
       _processParsedTorrent(parsedTorrent) {
         this._debugId = parsedTorrent.infoHash.toString("hex").substring(0, 7);
         if (typeof this.private !== "undefined") {
           parsedTorrent.private = this.private;
         }
         if (this.announce) {
           parsedTorrent.announce = parsedTorrent.announce.concat(this.announce);
         }
         if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !parsedTorrent.private) {
           parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE);
         }
         if (this.urlList) {
           parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList);
         }
         parsedTorrent.announce = Array.from(new Set(parsedTorrent.announce));
         parsedTorrent.urlList = Array.from(new Set(parsedTorrent.urlList));
         Object.assign(this, parsedTorrent);
         this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent);
         this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent);
       }
       _onListening() {
         if (this.destroyed)
           return;
         if (this.info) {
           this._onMetadata(this);
         } else {
           if (this.xs)
             this._getMetadataFromServer();
           this._startDiscovery();
         }
       }
       _startDiscovery() {
         if (this.discovery || this.destroyed)
           return;
         let trackerOpts = this.client.tracker;
         if (trackerOpts) {
           trackerOpts = Object.assign({}, this.client.tracker, {
             getAnnounceOpts: () => {
               if (this.destroyed)
                 return;
               const opts = {
                 uploaded: this.uploaded,
                 downloaded: this.downloaded,
                 left: Math.max(this.length - this.downloaded, 0)
               };
               if (this.client.tracker.getAnnounceOpts) {
                 Object.assign(opts, this.client.tracker.getAnnounceOpts());
               }
               if (this._getAnnounceOpts) {
                 Object.assign(opts, this._getAnnounceOpts());
               }
               return opts;
             }
           });
         }
         if (this.peerAddresses) {
           this.peerAddresses.forEach((peer) => this.addPeer(peer));
         }
         this.discovery = new Discovery({
           infoHash: this.infoHash,
           announce: this.announce,
           peerId: this.client.peerId,
           dht: !this.private && this.client.dht,
           tracker: trackerOpts,
           port: this.client.torrentPort,
           userAgent: USER_AGENT,
           lsd: this.client.lsd
         });
         this.discovery.on("error", (err) => {
           this._destroy(err);
         });
         this.discovery.on("peer", (peer, source) => {
           this._debug("peer %s discovered via %s", peer, source);
           if (typeof peer === "string" && this.done)
             return;
           this.addPeer(peer);
         });
         this.discovery.on("trackerAnnounce", () => {
           this.emit("trackerAnnounce");
           if (this.numPeers === 0)
             this.emit("noPeers", "tracker");
         });
         this.discovery.on("dhtAnnounce", () => {
           this.emit("dhtAnnounce");
           if (this.numPeers === 0)
             this.emit("noPeers", "dht");
         });
         this.discovery.on("warning", (err) => {
           this.emit("warning", err);
         });
       }
       _getMetadataFromServer() {
         const self = this;
         const urls = Array.isArray(this.xs) ? this.xs : [this.xs];
         const tasks = urls.map((url) => (cb) => {
           getMetadataFromURL(url, cb);
         });
         parallel2(tasks);
         function getMetadataFromURL(url, cb) {
           if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0) {
             self.emit("warning", new Error(`skipping non-http xs param: ${url}`));
             return cb(null);
           }
           const opts = {
             url,
             method: "GET",
             headers: {
               "user-agent": USER_AGENT
             }
           };
           let req;
           try {
             req = get.concat(opts, onResponse);
           } catch (err) {
             self.emit("warning", new Error(`skipping invalid url xs param: ${url}`));
             return cb(null);
           }
           self._xsRequests.push(req);
           function onResponse(err, res, torrent) {
             if (self.destroyed)
               return cb(null);
             if (self.metadata)
               return cb(null);
             if (err) {
               self.emit("warning", new Error(`http error from xs param: ${url}`));
               return cb(null);
             }
             if (res.statusCode !== 200) {
               self.emit("warning", new Error(`non-200 status code ${res.statusCode} from xs param: ${url}`));
               return cb(null);
             }
             let parsedTorrent;
             try {
               parsedTorrent = parseTorrent(torrent);
             } catch (err2) {
             }
             if (!parsedTorrent) {
               self.emit("warning", new Error(`got invalid torrent file from xs param: ${url}`));
               return cb(null);
             }
             if (parsedTorrent.infoHash !== self.infoHash) {
               self.emit("warning", new Error(`got torrent file with incorrect info hash from xs param: ${url}`));
               return cb(null);
             }
             self._onMetadata(parsedTorrent);
             cb(null);
           }
         }
       }
       _onMetadata(metadata) {
         if (this.metadata || this.destroyed)
           return;
         this._debug("got metadata");
         this._xsRequests.forEach((req) => {
           req.abort();
         });
         this._xsRequests = [];
         let parsedTorrent;
         if (metadata && metadata.infoHash) {
           parsedTorrent = metadata;
         } else {
           try {
             parsedTorrent = parseTorrent(metadata);
           } catch (err) {
             return this._destroy(err);
           }
         }
         this._processParsedTorrent(parsedTorrent);
         this.metadata = this.torrentFile;
         if (this.client.enableWebSeeds) {
           this.urlList.forEach((url) => {
             this.addWebSeed(url);
           });
         }
         this._rarityMap = new RarityMap(this);
         this.files = this.files.map((file) => new File(this, file));
         let rawStore = this._preloadedStore;
         if (!rawStore) {
           rawStore = new this._store(this.pieceLength, {
             ...this.storeOpts,
             torrent: this,
             path: this.path,
             files: this.files,
             length: this.length,
             name: this.name + " - " + this.infoHash.slice(0, 8),
             addUID: this.addUID
           });
         }
         if (this._storeCacheSlots > 0 && !(rawStore instanceof MemoryChunkStore)) {
           rawStore = new CacheChunkStore(rawStore, {
             max: this._storeCacheSlots
           });
         }
         this.store = new ImmediateChunkStore(
           rawStore
         );
         if (this.so) {
           this.files.forEach((v, i) => {
             if (this.so.includes(i)) {
               this.files[i].select();
             } else {
               this.files[i].deselect();
             }
           });
         } else {
           if (this.pieces.length !== 0) {
             this.select(0, this.pieces.length - 1, false);
           }
         }
         this._hashes = this.pieces;
         this.pieces = this.pieces.map((hash, i) => {
           const pieceLength = i === this.pieces.length - 1 ? this.lastPieceLength : this.pieceLength;
           return new Piece(pieceLength);
         });
         this._reservations = this.pieces.map(() => []);
         this.bitfield = new BitField(this.pieces.length);
         this.emit("metadata");
         if (this.destroyed)
           return;
         if (this.skipVerify) {
           this._markAllVerified();
           this._onStore();
         } else {
           const onPiecesVerified = (err) => {
             if (err)
               return this._destroy(err);
             this._debug("done verifying");
             this._onStore();
           };
           this._debug("verifying existing torrent data");
           if (this._fileModtimes && this._store === FSChunkStore) {
             this.getFileModtimes((err, fileModtimes) => {
               if (err)
                 return this._destroy(err);
               const unchanged = this.files.map((_, index) => fileModtimes[index] === this._fileModtimes[index]).every((x) => x);
               if (unchanged) {
                 this._markAllVerified();
                 this._onStore();
               } else {
                 this._verifyPieces(onPiecesVerified);
               }
             });
           } else {
             this._verifyPieces(onPiecesVerified);
           }
         }
       }
       getFileModtimes(cb) {
         const ret = [];
         parallelLimit(this.files.map((file, index) => (cb2) => {
           const filePath = this.addUID ? path2.join(this.name + " - " + this.infoHash.slice(0, 8)) : path2.join(this.path, file.path);
           fs2.stat(filePath, (err, stat) => {
             if (err && err.code !== "ENOENT")
               return cb2(err);
             ret[index] = stat && stat.mtime.getTime();
             cb2(null);
           });
         }), FILESYSTEM_CONCURRENCY, (err) => {
           this._debug("done getting file modtimes");
           cb(err, ret);
         });
       }
       _verifyPieces(cb) {
         parallelLimit(this.pieces.map((piece, index) => (cb2) => {
           if (this.destroyed)
             return cb2(new Error("torrent is destroyed"));
           const getOpts = {};
           if (index === this.pieces.length - 1) {
             getOpts.length = this.lastPieceLength;
           }
           this.store.get(index, getOpts, (err, buf) => {
             if (this.destroyed)
               return cb2(new Error("torrent is destroyed"));
             if (err)
               return queueMicrotask3(() => cb2(null));
             sha1(buf, (hash) => {
               if (this.destroyed)
                 return cb2(new Error("torrent is destroyed"));
               if (hash === this._hashes[index]) {
                 this._debug("piece verified %s", index);
                 this._markVerified(index);
               } else {
                 this._debug("piece invalid %s", index);
               }
               cb2(null);
             });
           });
         }), FILESYSTEM_CONCURRENCY, cb);
       }
       rescanFiles(cb) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         if (!cb)
           cb = noop2;
         this._verifyPieces((err) => {
           if (err) {
             this._destroy(err);
             return cb(err);
           }
           this._checkDone();
           cb(null);
         });
       }
       _markAllVerified() {
         for (let index = 0; index < this.pieces.length; index++) {
           this._markVerified(index);
         }
       }
       _markVerified(index) {
         this.pieces[index] = null;
         this._reservations[index] = null;
         this.bitfield.set(index, true);
       }
       _hasAllPieces() {
         for (let index = 0; index < this.pieces.length; index++) {
           if (!this.bitfield.get(index))
             return false;
         }
         return true;
       }
       _hasNoPieces() {
         return !this._hasMorePieces(0);
       }
       _hasMorePieces(threshold) {
         let count = 0;
         for (let index = 0; index < this.pieces.length; index++) {
           if (this.bitfield.get(index)) {
             count += 1;
             if (count > threshold)
               return true;
           }
         }
         return false;
       }
       _onStore() {
         if (this.destroyed)
           return;
         this._debug("on store");
         this._startDiscovery();
         this.ready = true;
         this.emit("ready");
         this._checkDone();
         this._updateSelections();
         this.wires.forEach((wire) => {
           if (wire.ut_metadata)
             wire.ut_metadata.setMetadata(this.metadata);
           this._onWireWithMetadata(wire);
         });
       }
       destroy(opts, cb) {
         if (typeof opts === "function")
           return this.destroy(null, opts);
         this._destroy(null, opts, cb);
       }
       _destroy(err, opts, cb) {
         if (typeof opts === "function")
           return this._destroy(err, null, opts);
         if (this.destroyed)
           return;
         this.destroyed = true;
         this._debug("destroy");
         this.client._remove(this);
         clearInterval(this._rechokeIntervalId);
         this._xsRequests.forEach((req) => {
           req.abort();
         });
         if (this._rarityMap) {
           this._rarityMap.destroy();
         }
         for (const id in this._peers) {
           this.removePeer(id);
         }
         this.files.forEach((file) => {
           if (file instanceof File)
             file._destroy();
         });
         const tasks = this._servers.map((server) => (cb2) => {
           server.destroy(cb2);
         });
         if (this.discovery) {
           tasks.push((cb2) => {
             this.discovery.destroy(cb2);
           });
         }
         if (this.store) {
           let destroyStore = this._destroyStoreOnDestroy;
           if (opts && opts.destroyStore !== void 0) {
             destroyStore = opts.destroyStore;
           }
           tasks.push((cb2) => {
             if (destroyStore) {
               this.store.destroy(cb2);
             } else {
               this.store.close(cb2);
             }
           });
         }
         parallel2(tasks, cb);
         if (err) {
           if (this.listenerCount("error") === 0) {
             this.client.emit("error", err);
           } else {
             this.emit("error", err);
           }
         }
         this.emit("close");
         this.client = null;
         this.files = [];
         this.discovery = null;
         this.store = null;
         this._rarityMap = null;
         this._peers = null;
         this._servers = null;
         this._xsRequests = null;
       }
       addPeer(peer) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         if (!this.infoHash)
           throw new Error("addPeer() must not be called before the `infoHash` event");
         let host;
         if (this.client.blocked) {
           if (typeof peer === "string") {
             let parts;
             try {
               parts = addrToIPPort(peer);
             } catch (e) {
               this._debug("ignoring peer: invalid %s", peer);
               this.emit("invalidPeer", peer);
               return false;
             }
             host = parts[0];
           } else if (typeof peer.remoteAddress === "string") {
             host = peer.remoteAddress;
           }
           if (host && this.client.blocked.contains(host)) {
             this._debug("ignoring peer: blocked %s", peer);
             if (typeof peer !== "string")
               peer.destroy();
             this.emit("blockedPeer", peer);
             return false;
           }
         }
         const type = this.client.utp && this._isIPv4(host) ? "utp" : "tcp";
         const wasAdded = !!this._addPeer(peer, type);
         if (wasAdded) {
           this.emit("peer", peer);
         } else {
           this.emit("invalidPeer", peer);
         }
         return wasAdded;
       }
       _addPeer(peer, type) {
         if (this.destroyed) {
           if (typeof peer !== "string")
             peer.destroy();
           return null;
         }
         if (typeof peer === "string" && !this._validAddr(peer)) {
           this._debug("ignoring peer: invalid %s", peer);
           return null;
         }
         const id = peer && peer.id || peer;
         if (this._peers[id]) {
           this._debug("ignoring peer: duplicate (%s)", id);
           if (typeof peer !== "string")
             peer.destroy();
           return null;
         }
         if (this.paused) {
           this._debug("ignoring peer: torrent is paused");
           if (typeof peer !== "string")
             peer.destroy();
           return null;
         }
         this._debug("add peer %s", id);
         let newPeer;
         if (typeof peer === "string") {
           newPeer = type === "utp" ? Peer.createUTPOutgoingPeer(peer, this, this.client.throttleGroups) : Peer.createTCPOutgoingPeer(peer, this, this.client.throttleGroups);
         } else {
           newPeer = Peer.createWebRTCPeer(peer, this, this.client.throttleGroups);
         }
         this._registerPeer(newPeer);
         if (typeof peer === "string") {
           this._queue.push(newPeer);
           this._drain();
         }
         return newPeer;
       }
       addWebSeed(urlOrConn) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         let id;
         let conn;
         if (typeof urlOrConn === "string") {
           id = urlOrConn;
           if (!/^https?:\/\/.+/.test(id)) {
             this.emit("warning", new Error(`ignoring invalid web seed: ${id}`));
             this.emit("invalidPeer", id);
             return;
           }
           if (this._peers[id]) {
             this.emit("warning", new Error(`ignoring duplicate web seed: ${id}`));
             this.emit("invalidPeer", id);
             return;
           }
           conn = new WebConn(id, this);
         } else if (urlOrConn && typeof urlOrConn.connId === "string") {
           conn = urlOrConn;
           id = conn.connId;
           if (this._peers[id]) {
             this.emit("warning", new Error(`ignoring duplicate web seed: ${id}`));
             this.emit("invalidPeer", id);
             return;
           }
         } else {
           this.emit("warning", new Error("addWebSeed must be passed a string or connection object with id property"));
           return;
         }
         this._debug("add web seed %s", id);
         const newPeer = Peer.createWebSeedPeer(conn, id, this, this.client.throttleGroups);
         this._registerPeer(newPeer);
         this.emit("peer", id);
       }
       _addIncomingPeer(peer) {
         if (this.destroyed)
           return peer.destroy(new Error("torrent is destroyed"));
         if (this.paused)
           return peer.destroy(new Error("torrent is paused"));
         this._debug("add incoming peer %s", peer.id);
         this._registerPeer(peer);
       }
       _registerPeer(newPeer) {
         newPeer.on("download", (downloaded) => {
           if (this.destroyed)
             return;
           this.received += downloaded;
           this._downloadSpeed(downloaded);
           this.client._downloadSpeed(downloaded);
           this.emit("download", downloaded);
           if (this.destroyed)
             return;
           this.client.emit("download", downloaded);
         });
         newPeer.on("upload", (uploaded) => {
           if (this.destroyed)
             return;
           this.uploaded += uploaded;
           this._uploadSpeed(uploaded);
           this.client._uploadSpeed(uploaded);
           this.emit("upload", uploaded);
           if (this.destroyed)
             return;
           this.client.emit("upload", uploaded);
         });
         this._peers[newPeer.id] = newPeer;
         this._peersLength += 1;
       }
       removePeer(peer) {
         const id = peer?.id || peer;
         if (peer && !peer.id)
           peer = this._peers?.[id];
         if (!peer)
           return;
         peer.destroy();
         if (this.destroyed)
           return;
         this._debug("removePeer %s", id);
         delete this._peers[id];
         this._peersLength -= 1;
         this._drain();
       }
       select(start, end, priority, notify) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         if (start < 0 || end < start || this.pieces.length <= end) {
           throw new Error(`invalid selection ${start} : ${end}`);
         }
         priority = Number(priority) || 0;
         this._debug("select %s-%s (priority %s)", start, end, priority);
         this._selections.push({
           from: start,
           to: end,
           offset: 0,
           priority,
           notify: notify || noop2
         });
         this._selections.sort((a, b) => b.priority - a.priority);
         this._updateSelections();
       }
       deselect(start, end, priority) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         priority = Number(priority) || 0;
         this._debug("deselect %s-%s (priority %s)", start, end, priority);
         for (let i = 0; i < this._selections.length; ++i) {
           const s = this._selections[i];
           if (s.from === start && s.to === end && s.priority === priority) {
             this._selections.splice(i, 1);
             break;
           }
         }
         this._updateSelections();
       }
       critical(start, end) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         this._debug("critical %s-%s", start, end);
         for (let i = start; i <= end; ++i) {
           this._critical[i] = true;
         }
         this._updateSelections();
       }
       _onWire(wire, addr) {
         this._debug("got wire %s (%s)", wire._debugId, addr || "Unknown");
         this.wires.push(wire);
         if (addr) {
           const parts = addrToIPPort(addr);
           wire.remoteAddress = parts[0];
           wire.remotePort = parts[1];
         }
         if (this.client.dht && this.client.dht.listening) {
           wire.on("port", (port) => {
             if (this.destroyed || this.client.dht.destroyed) {
               return;
             }
             if (!wire.remoteAddress) {
               return this._debug("ignoring PORT from peer with no address");
             }
             if (port === 0 || port > 65536) {
               return this._debug("ignoring invalid PORT from peer");
             }
             this._debug("port: %s (from %s)", port, addr);
             this.client.dht.addNode({ host: wire.remoteAddress, port });
           });
         }
         wire.on("timeout", () => {
           this._debug("wire timeout (%s)", addr);
           wire.destroy();
         });
         if (wire.type !== "webSeed") {
           wire.setTimeout(PIECE_TIMEOUT, true);
         }
         wire.setKeepAlive(true);
         wire.use(utMetadata(this.metadata));
         wire.ut_metadata.on("warning", (err) => {
           this._debug("ut_metadata warning: %s", err.message);
         });
         if (!this.metadata) {
           wire.ut_metadata.on("metadata", (metadata) => {
             this._debug("got metadata via ut_metadata");
             this._onMetadata(metadata);
           });
           wire.ut_metadata.fetch();
         }
         if (typeof utPex === "function" && !this.private) {
           wire.use(utPex());
           wire.ut_pex.on("peer", (peer) => {
             if (this.done)
               return;
             this._debug("ut_pex: got peer: %s (from %s)", peer, addr);
             this.addPeer(peer);
           });
           wire.ut_pex.on("dropped", (peer) => {
             const peerObj = this._peers[peer];
             if (peerObj && !peerObj.connected) {
               this._debug("ut_pex: dropped peer: %s (from %s)", peer, addr);
               this.removePeer(peer);
             }
           });
           wire.once("close", () => {
             wire.ut_pex.reset();
           });
         }
         wire.use(ltDontHave());
         this.emit("wire", wire, addr);
         if (this.ready) {
           queueMicrotask3(() => {
             this._onWireWithMetadata(wire);
           });
         }
       }
       _onWireWithMetadata(wire) {
         let timeoutId = null;
         const onChokeTimeout = () => {
           if (this.destroyed || wire.destroyed)
             return;
           if (this._numQueued > 2 * (this._numConns - this.numPeers) && wire.amInterested) {
             wire.destroy();
           } else {
             timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
             if (timeoutId.unref)
               timeoutId.unref();
           }
         };
         let i;
         const updateSeedStatus = () => {
           if (wire.peerPieces.buffer.length !== this.bitfield.buffer.length)
             return;
           for (i = 0; i < this.pieces.length; ++i) {
             if (!wire.peerPieces.get(i))
               return;
           }
           wire.isSeeder = true;
           wire.choke();
         };
         wire.on("bitfield", () => {
           updateSeedStatus();
           this._update();
           this._updateWireInterest(wire);
         });
         wire.on("have", () => {
           updateSeedStatus();
           this._update();
           this._updateWireInterest(wire);
         });
         wire.lt_donthave.on("donthave", () => {
           updateSeedStatus();
           this._update();
           this._updateWireInterest(wire);
         });
         wire.on("have-all", () => {
           wire.isSeeder = true;
           wire.choke();
           this._update();
           this._updateWireInterest(wire);
         });
         wire.on("have-none", () => {
           wire.isSeeder = false;
           this._update();
           this._updateWireInterest(wire);
         });
         wire.on("allowed-fast", (index) => {
           this._update();
         });
         wire.once("interested", () => {
           wire.unchoke();
         });
         wire.once("close", () => {
           clearTimeout(timeoutId);
         });
         wire.on("choke", () => {
           clearTimeout(timeoutId);
           timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
           if (timeoutId.unref)
             timeoutId.unref();
         });
         wire.on("unchoke", () => {
           clearTimeout(timeoutId);
           this._update();
         });
         wire.on("request", (index, offset, length, cb) => {
           if (length > MAX_BLOCK_LENGTH) {
             return wire.destroy();
           }
           if (this.pieces[index])
             return;
           this.store.get(index, { offset, length }, cb);
         });
         if (wire.hasFast && this._hasAllPieces())
           wire.haveAll();
         else if (wire.hasFast && this._hasNoPieces())
           wire.haveNone();
         else
           wire.bitfield(this.bitfield);
         this._updateWireInterest(wire);
         if (wire.peerExtensions.dht && this.client.dht && this.client.dht.listening) {
           wire.port(this.client.dht.address().port);
         }
         if (wire.type !== "webSeed") {
           timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
           if (timeoutId.unref)
             timeoutId.unref();
         }
         wire.isSeeder = false;
         updateSeedStatus();
       }
       _updateSelections() {
         if (!this.ready || this.destroyed)
           return;
         queueMicrotask3(() => {
           this._gcSelections();
         });
         this._updateInterest();
         this._update();
       }
       _gcSelections() {
         for (let i = 0; i < this._selections.length; ++i) {
           const s = this._selections[i];
           const oldOffset = s.offset;
           while (this.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
             s.offset += 1;
           }
           if (oldOffset !== s.offset)
             s.notify();
           if (s.to !== s.from + s.offset)
             continue;
           if (!this.bitfield.get(s.from + s.offset))
             continue;
           this._selections.splice(i, 1);
           i -= 1;
           s.notify();
           this._updateInterest();
         }
         if (!this._selections.length)
           this.emit("idle");
       }
       _updateInterest() {
         const prev = this._amInterested;
         this._amInterested = !!this._selections.length;
         this.wires.forEach((wire) => this._updateWireInterest(wire));
         if (prev === this._amInterested)
           return;
         if (this._amInterested)
           this.emit("interested");
         else
           this.emit("uninterested");
       }
       _updateWireInterest(wire) {
         let interested = false;
         for (let index = 0; index < this.pieces.length; ++index) {
           if (this.pieces[index] && wire.peerPieces.get(index)) {
             interested = true;
             break;
           }
         }
         if (interested)
           wire.interested();
         else
           wire.uninterested();
       }
       _update() {
         if (this.destroyed)
           return;
         const ite = randomIterate(this.wires);
         let wire;
         while (wire = ite()) {
           this._updateWireWrapper(wire);
         }
       }
       _updateWireWrapper(wire) {
         const self = this;
         if (typeof window !== "undefined" && typeof window.requestIdleCallback === "function") {
           window.requestIdleCallback(() => {
             self._updateWire(wire);
           }, { timeout: 250 });
         } else {
           self._updateWire(wire);
         }
       }
       _updateWire(wire) {
         if (wire.destroyed)
           return false;
         const self = this;
         const minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION);
         if (wire.requests.length >= minOutstandingRequests)
           return;
         const maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
         if (wire.peerChoking) {
           if (wire.hasFast && wire.peerAllowedFastSet.length > 0 && !this._hasMorePieces(wire.peerAllowedFastSet.length - 1)) {
             requestAllowedFastSet();
           }
           return;
         }
         if (!wire.downloaded)
           return validateWire();
         trySelectWire(false) || trySelectWire(true);
         function requestAllowedFastSet() {
           if (wire.requests.length >= maxOutstandingRequests)
             return false;
           for (const piece of wire.peerAllowedFastSet) {
             if (wire.peerPieces.get(piece) && !self.bitfield.get(piece)) {
               while (self._request(wire, piece, false) && wire.requests.length < maxOutstandingRequests) {
               }
             }
             if (wire.requests.length < maxOutstandingRequests)
               continue;
             return true;
           }
           return false;
         }
         function genPieceFilterFunc(start, end, tried, rank) {
           return (i) => i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i));
         }
         function validateWire() {
           if (wire.requests.length)
             return;
           let i = self._selections.length;
           while (i--) {
             const next = self._selections[i];
             let piece;
             if (self.strategy === "rarest") {
               const start = next.from + next.offset;
               const end = next.to;
               const len = end - start + 1;
               const tried = {};
               let tries = 0;
               const filter = genPieceFilterFunc(start, end, tried);
               while (tries < len) {
                 piece = self._rarityMap.getRarestPiece(filter);
                 if (piece < 0)
                   break;
                 if (self._request(wire, piece, false))
                   return;
                 tried[piece] = true;
                 tries += 1;
               }
             } else {
               for (piece = next.to; piece >= next.from + next.offset; --piece) {
                 if (!wire.peerPieces.get(piece))
                   continue;
                 if (self._request(wire, piece, false))
                   return;
               }
             }
           }
         }
         function speedRanker() {
           const speed = wire.downloadSpeed() || 1;
           if (speed > SPEED_THRESHOLD)
             return () => true;
           const secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed;
           let tries = 10;
           let ptr = 0;
           return (index) => {
             if (!tries || self.bitfield.get(index))
               return true;
             let missing = self.pieces[index].missing;
             for (; ptr < self.wires.length; ptr++) {
               const otherWire = self.wires[ptr];
               const otherSpeed = otherWire.downloadSpeed();
               if (otherSpeed < SPEED_THRESHOLD)
                 continue;
               if (otherSpeed <= speed)
                 continue;
               if (!otherWire.peerPieces.get(index))
                 continue;
               if ((missing -= otherSpeed * secs) > 0)
                 continue;
               tries--;
               return false;
             }
             return true;
           };
         }
         function shufflePriority(i) {
           let last = i;
           for (let j = i; j < self._selections.length && self._selections[j].priority; j++) {
             last = j;
           }
           const tmp = self._selections[i];
           self._selections[i] = self._selections[last];
           self._selections[last] = tmp;
         }
         function trySelectWire(hotswap) {
           if (wire.requests.length >= maxOutstandingRequests)
             return true;
           const rank = speedRanker();
           for (let i = 0; i < self._selections.length; i++) {
             const next = self._selections[i];
             let piece;
             if (self.strategy === "rarest") {
               const start = next.from + next.offset;
               const end = next.to;
               const len = end - start + 1;
               const tried = {};
               let tries = 0;
               const filter = genPieceFilterFunc(start, end, tried, rank);
               while (tries < len) {
                 piece = self._rarityMap.getRarestPiece(filter);
                 if (piece < 0)
                   break;
                 while (self._request(wire, piece, self._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {
                 }
                 if (wire.requests.length < maxOutstandingRequests) {
                   tried[piece] = true;
                   tries++;
                   continue;
                 }
                 if (next.priority)
                   shufflePriority(i);
                 return true;
               }
             } else {
               for (piece = next.from + next.offset; piece <= next.to; piece++) {
                 if (!wire.peerPieces.get(piece) || !rank(piece))
                   continue;
                 while (self._request(wire, piece, self._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {
                 }
                 if (wire.requests.length < maxOutstandingRequests)
                   continue;
                 if (next.priority)
                   shufflePriority(i);
                 return true;
               }
             }
           }
           return false;
         }
       }
       _rechoke() {
         if (!this.ready)
           return;
         const wireStack = this.wires.map((wire) => ({ wire, random: Math.random() })).sort((objA, objB) => {
           const wireA = objA.wire;
           const wireB = objB.wire;
           if (wireA.downloadSpeed() !== wireB.downloadSpeed()) {
             return wireA.downloadSpeed() - wireB.downloadSpeed();
           }
           if (wireA.uploadSpeed() !== wireB.uploadSpeed()) {
             return wireA.uploadSpeed() - wireB.uploadSpeed();
           }
           if (wireA.amChoking !== wireB.amChoking) {
             return wireA.amChoking ? -1 : 1;
           }
           return objA.random - objB.random;
         }).map((obj) => obj.wire);
         if (this._rechokeOptimisticTime <= 0) {
           this._rechokeOptimisticWire = null;
         } else {
           this._rechokeOptimisticTime -= 1;
         }
         let numInterestedUnchoked = 0;
         while (wireStack.length > 0 && numInterestedUnchoked < this._rechokeNumSlots - 1) {
           const wire = wireStack.pop();
           if (wire.isSeeder || wire === this._rechokeOptimisticWire) {
             continue;
           }
           wire.unchoke();
           if (wire.peerInterested) {
             numInterestedUnchoked++;
           }
         }
         if (this._rechokeOptimisticWire === null && this._rechokeNumSlots > 0) {
           const remaining = wireStack.filter((wire) => wire.peerInterested);
           if (remaining.length > 0) {
             const newOptimisticPeer = remaining[randomInt(remaining.length)];
             newOptimisticPeer.unchoke();
             this._rechokeOptimisticWire = newOptimisticPeer;
             this._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION;
           }
         }
         wireStack.filter((wire) => wire !== this._rechokeOptimisticWire).forEach((wire) => wire.choke());
       }
       _hotswap(wire, index) {
         const speed = wire.downloadSpeed();
         if (speed < Piece.BLOCK_LENGTH)
           return false;
         if (!this._reservations[index])
           return false;
         const r = this._reservations[index];
         if (!r) {
           return false;
         }
         let minSpeed = Infinity;
         let minWire;
         let i;
         for (i = 0; i < r.length; i++) {
           const otherWire = r[i];
           if (!otherWire || otherWire === wire)
             continue;
           const otherSpeed = otherWire.downloadSpeed();
           if (otherSpeed >= SPEED_THRESHOLD)
             continue;
           if (2 * otherSpeed > speed || otherSpeed > minSpeed)
             continue;
           minWire = otherWire;
           minSpeed = otherSpeed;
         }
         if (!minWire)
           return false;
         for (i = 0; i < r.length; i++) {
           if (r[i] === minWire)
             r[i] = null;
         }
         for (i = 0; i < minWire.requests.length; i++) {
           const req = minWire.requests[i];
           if (req.piece !== index)
             continue;
           this.pieces[index].cancel(req.offset / Piece.BLOCK_LENGTH | 0);
         }
         this.emit("hotswap", minWire, wire, index);
         return true;
       }
       _request(wire, index, hotswap) {
         const self = this;
         const numRequests = wire.requests.length;
         const isWebSeed = wire.type === "webSeed";
         if (self.bitfield.get(index))
           return false;
         const maxOutstandingRequests = isWebSeed ? Math.min(
           getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),
           self.maxWebConns
         ) : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
         if (numRequests >= maxOutstandingRequests)
           return false;
         const piece = self.pieces[index];
         let reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
         if (reservation === -1 && hotswap && self._hotswap(wire, index)) {
           reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
         }
         if (reservation === -1)
           return false;
         let r = self._reservations[index];
         if (!r)
           r = self._reservations[index] = [];
         let i = r.indexOf(null);
         if (i === -1)
           i = r.length;
         r[i] = wire;
         const chunkOffset = piece.chunkOffset(reservation);
         const chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation);
         wire.request(index, chunkOffset, chunkLength, function onChunk(err, chunk) {
           if (self.destroyed)
             return;
           if (!self.ready)
             return self.once("ready", () => {
               onChunk(err, chunk);
             });
           if (r[i] === wire)
             r[i] = null;
           if (piece !== self.pieces[index])
             return onUpdateTick();
           if (err) {
             self._debug(
               "error getting piece %s (offset: %s length: %s) from %s: %s",
               index,
               chunkOffset,
               chunkLength,
               `${wire.remoteAddress}:${wire.remotePort}`,
               err.message
             );
             isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation);
             onUpdateTick();
             return;
           }
           self._debug(
             "got piece %s (offset: %s length: %s) from %s",
             index,
             chunkOffset,
             chunkLength,
             `${wire.remoteAddress}:${wire.remotePort}`
           );
           if (!piece.set(reservation, chunk, wire))
             return onUpdateTick();
           const buf = piece.flush();
           sha1(buf, (hash) => {
             if (self.destroyed)
               return;
             if (hash === self._hashes[index]) {
               self._debug("piece verified %s", index);
               self.store.put(index, buf, (err2) => {
                 if (err2) {
                   self._destroy(err2);
                   return;
                 } else {
                   self.pieces[index] = null;
                   self._markVerified(index);
                   self.wires.forEach((wire2) => {
                     wire2.have(index);
                   });
                 }
                 if (self._checkDone() && !self.destroyed)
                   self.discovery.complete();
                 onUpdateTick();
               });
             } else {
               self.pieces[index] = new Piece(piece.length);
               self.emit("warning", new Error(`Piece ${index} failed verification`));
               onUpdateTick();
             }
           });
         });
         function onUpdateTick() {
           queueMicrotask3(() => {
             self._update();
           });
         }
         return true;
       }
       _checkDone() {
         if (this.destroyed)
           return;
         this.files.forEach((file) => {
           if (file.done)
             return;
           for (let i = file._startPiece; i <= file._endPiece; ++i) {
             if (!this.bitfield.get(i))
               return;
           }
           file.done = true;
           file.emit("done");
           this._debug(`file done: ${file.name}`);
         });
         let done = true;
         for (const selection of this._selections) {
           for (let piece = selection.from; piece <= selection.to; piece++) {
             if (!this.bitfield.get(piece)) {
               done = false;
               break;
             }
           }
           if (!done)
             break;
         }
         if (!this.done && done) {
           this.done = true;
           this._debug(`torrent done: ${this.infoHash}`);
           this.emit("done");
         } else {
           this.done = false;
         }
         this._gcSelections();
         return done;
       }
       load(streams, cb) {
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         if (!this.ready)
           return this.once("ready", () => {
             this.load(streams, cb);
           });
         if (!Array.isArray(streams))
           streams = [streams];
         if (!cb)
           cb = noop2;
         const readable = Readable.from(joinIterator(streams));
         const writable = new ChunkStoreWriteStream(this.store, this.pieceLength);
         pump(readable, writable, (err) => {
           if (err)
             return cb(err);
           this._markAllVerified();
           this._checkDone();
           cb(null);
         });
       }
       createServer(requestListener) {
         if (typeof Server !== "function")
           throw new Error("node.js-only method");
         if (this.destroyed)
           throw new Error("torrent is destroyed");
         const server = new Server(this, requestListener);
         this._servers.push(server);
         return server;
       }
       pause() {
         if (this.destroyed)
           return;
         this._debug("pause");
         this.paused = true;
       }
       resume() {
         if (this.destroyed)
           return;
         this._debug("resume");
         this.paused = false;
         this._drain();
       }
       _debug() {
         const args = [].slice.call(arguments);
         args[0] = `[${this.client ? this.client._debugId : "No Client"}] [${this._debugId}] ${args[0]}`;
         debug(...args);
       }
       _drain() {
         this._debug("_drain numConns %s maxConns %s", this._numConns, this.client.maxConns);
         if (typeof net.connect !== "function" || this.destroyed || this.paused || this._numConns >= this.client.maxConns) {
           return;
         }
         this._debug("drain (%s queued, %s/%s peers)", this._numQueued, this.numPeers, this.client.maxConns);
         const peer = this._queue.shift();
         if (!peer)
           return;
         this._debug("%s connect attempt to %s", peer.type, peer.addr);
         const parts = addrToIPPort(peer.addr);
         const opts = {
           host: parts[0],
           port: parts[1]
         };
         if (this.client.utp && peer.type === "utpOutgoing") {
           peer.conn = utp.connect(opts.port, opts.host);
         } else {
           peer.conn = net.connect(opts);
         }
         const conn = peer.conn;
         conn.once("connect", () => {
           if (!this.destroyed)
             peer.onConnect();
         });
         conn.once("error", (err) => {
           peer.destroy(err);
         });
         peer.startConnectTimeout();
         conn.on("close", () => {
           if (this.destroyed)
             return;
           if (peer.retries >= RECONNECT_WAIT.length) {
             if (this.client.utp) {
               const newPeer = this._addPeer(peer.addr, "tcp");
               if (newPeer)
                 newPeer.retries = 0;
             } else {
               this._debug(
                 "conn %s closed: will not re-add (max %s attempts)",
                 peer.addr,
                 RECONNECT_WAIT.length
               );
             }
             return;
           }
           const ms = RECONNECT_WAIT[peer.retries];
           this._debug(
             "conn %s closed: will re-add to queue in %sms (attempt %s)",
             peer.addr,
             ms,
             peer.retries + 1
           );
           const reconnectTimeout = setTimeout(() => {
             if (this.destroyed)
               return;
             const host = addrToIPPort(peer.addr)[0];
             const type = this.client.utp && this._isIPv4(host) ? "utp" : "tcp";
             const newPeer = this._addPeer(peer.addr, type);
             if (newPeer)
               newPeer.retries = peer.retries + 1;
           }, ms);
           if (reconnectTimeout.unref)
             reconnectTimeout.unref();
         });
       }
       _validAddr(addr) {
         let parts;
         try {
           parts = addrToIPPort(addr);
         } catch (e) {
           return false;
         }
         const host = parts[0];
         const port = parts[1];
         return port > 0 && port < 65535 && !(host === "127.0.0.1" && port === this.client.torrentPort);
       }
       _isIPv4(addr) {
         const IPv4Pattern = /^((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/;
         return IPv4Pattern.test(addr);
       }
     };
     function getBlockPipelineLength(wire, duration) {
       let length = 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH);
       if (wire.peerExtendedHandshake) {
         const reqq = wire.peerExtendedHandshake.reqq;
         if (typeof reqq === "number" && reqq > 0) {
           length = Math.min(length, reqq);
         }
       }
       return length;
     }
     function getPiecePipelineLength(wire, duration, pieceLength) {
       return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength);
     }
     function randomInt(high) {
       return Math.random() * high | 0;
     }
     function noop2() {
     }
     module2.exports = Torrent;
   }
 });
 
 // node_modules/webtorrent/index.js
 var require_webtorrent = __commonJS({
   "node_modules/webtorrent/index.js"(exports, module2) {
     var EventEmitter = require("events");
     var path2 = require("path");
     var concat = require_simple_concat();
     var createTorrent = require_create_torrent();
     var debugFactory = require_src();
     var DHT = require_client();
     var loadIPSet = require_load_ip_set();
     var parallel2 = require_run_parallel();
     var parseTorrent = require_parse_torrent();
     var Peer = require_simple_peer();
     var queueMicrotask3 = require_queue_microtask();
     var randombytes2 = require_randombytes();
     var sha1 = require_simple_sha1();
     var throughput = require_throughput();
     var { ThrottleGroup } = require_speed_limiter();
     var ConnPool = require_conn_pool();
     var Torrent = require_torrent();
     var { version: VERSION } = require_package();
     var debug = debugFactory("webtorrent");
     var VERSION_STR = VERSION.replace(/\d*./g, (v) => `0${v % 100}`.slice(-2)).slice(0, 4);
     var VERSION_PREFIX = `-WW${VERSION_STR}-`;
     var WebTorrent2 = class extends EventEmitter {
       constructor(opts = {}) {
         super();
         if (typeof opts.peerId === "string") {
           this.peerId = opts.peerId;
         } else if (Buffer.isBuffer(opts.peerId)) {
           this.peerId = opts.peerId.toString("hex");
         } else {
           this.peerId = Buffer.from(VERSION_PREFIX + randombytes2(9).toString("base64")).toString("hex");
         }
         this.peerIdBuffer = Buffer.from(this.peerId, "hex");
         if (typeof opts.nodeId === "string") {
           this.nodeId = opts.nodeId;
         } else if (Buffer.isBuffer(opts.nodeId)) {
           this.nodeId = opts.nodeId.toString("hex");
         } else {
           this.nodeId = randombytes2(20).toString("hex");
         }
         this.nodeIdBuffer = Buffer.from(this.nodeId, "hex");
         this._debugId = this.peerId.toString("hex").substring(0, 7);
         this.destroyed = false;
         this.listening = false;
         this.torrentPort = opts.torrentPort || 0;
         this.dhtPort = opts.dhtPort || 0;
         this.tracker = opts.tracker !== void 0 ? opts.tracker : {};
         this.lsd = opts.lsd !== false;
         this.torrents = [];
         this.maxConns = Number(opts.maxConns) || 55;
         this.utp = WebTorrent2.UTP_SUPPORT && opts.utp !== false;
         this._downloadLimit = Math.max(typeof opts.downloadLimit === "number" ? opts.downloadLimit : -1, -1);
         this._uploadLimit = Math.max(typeof opts.uploadLimit === "number" ? opts.uploadLimit : -1, -1);
         this.serviceWorker = null;
         this.workerKeepAliveInterval = null;
         this.workerPortCount = 0;
         if (opts.secure === true) {
           require_peer().enableSecure();
         }
         this._debug(
           "new webtorrent (peerId %s, nodeId %s, port %s)",
           this.peerId,
           this.nodeId,
           this.torrentPort
         );
         this.throttleGroups = {
           down: new ThrottleGroup({ rate: Math.max(this._downloadLimit, 0), enabled: this._downloadLimit >= 0 }),
           up: new ThrottleGroup({ rate: Math.max(this._uploadLimit, 0), enabled: this._uploadLimit >= 0 })
         };
         if (this.tracker) {
           if (typeof this.tracker !== "object")
             this.tracker = {};
           if (globalThis.WRTC && !this.tracker.wrtc)
             this.tracker.wrtc = globalThis.WRTC;
         }
         if (typeof ConnPool === "function") {
           this._connPool = new ConnPool(this);
         } else {
           queueMicrotask3(() => {
             this._onListening();
           });
         }
         this._downloadSpeed = throughput();
         this._uploadSpeed = throughput();
         if (opts.dht !== false && typeof DHT === "function") {
           this.dht = new DHT(Object.assign({}, { nodeId: this.nodeId }, opts.dht));
           this.dht.once("error", (err) => {
             this._destroy(err);
           });
           this.dht.once("listening", () => {
             const address = this.dht.address();
             if (address)
               this.dhtPort = address.port;
           });
           this.dht.setMaxListeners(0);
           this.dht.listen(this.dhtPort);
         } else {
           this.dht = false;
         }
         this.enableWebSeeds = opts.webSeeds !== false;
         const ready = () => {
           if (this.destroyed)
             return;
           this.ready = true;
           this.emit("ready");
         };
         if (typeof loadIPSet === "function" && opts.blocklist != null) {
           loadIPSet(opts.blocklist, {
             headers: {
               "user-agent": `WebTorrent/${VERSION} (https://webtorrent.io)`
             }
           }, (err, ipSet) => {
             if (err)
               return console.error(`Failed to load blocklist: ${err.message}`);
             this.blocked = ipSet;
             ready();
           });
         } else {
           queueMicrotask3(ready);
         }
       }
       loadWorker(controller, cb = () => {
       }) {
         if (!(controller instanceof ServiceWorker))
           throw new Error("Invalid worker registration");
         if (controller.state !== "activated")
           throw new Error("Worker isn't activated");
         const keepAliveTime = 2e4;
         this.serviceWorker = controller;
         navigator.serviceWorker.addEventListener("message", (event) => {
           const { data } = event;
           if (!data.type || !data.type === "webtorrent" || !data.url)
             return null;
           let [infoHash, ...filePath] = data.url.slice(data.url.indexOf(data.scope + "webtorrent/") + 11 + data.scope.length).split("/");
           filePath = decodeURI(filePath.join("/"));
           if (!infoHash || !filePath)
             return null;
           const [port] = event.ports;
           const file = this.get(infoHash) && this.get(infoHash).files.find((file2) => file2.path === filePath);
           if (!file)
             return null;
           const [response, stream, raw] = file._serve(data);
           const asyncIterator = stream && stream[Symbol.asyncIterator]();
           const cleanup = () => {
             port.onmessage = null;
             if (stream)
               stream.destroy();
             if (raw)
               raw.destroy();
             this.workerPortCount--;
             if (!this.workerPortCount) {
               clearInterval(this.workerKeepAliveInterval);
               this.workerKeepAliveInterval = null;
             }
           };
           port.onmessage = async (msg) => {
             if (msg.data) {
               let chunk;
               try {
                 chunk = (await asyncIterator.next()).value;
               } catch (e) {
               }
               port.postMessage(chunk);
               if (!chunk)
                 cleanup();
               if (!this.workerKeepAliveInterval)
                 this.workerKeepAliveInterval = setInterval(() => fetch(`${this.serviceWorker.scriptURL.slice(0, this.serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length)}webtorrent/keepalive/`), keepAliveTime);
             } else {
               cleanup();
             }
           };
           this.workerPortCount++;
           port.postMessage(response);
         });
         fetch(`${this.serviceWorker.scriptURL.slice(0, this.serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length)}webtorrent/cancel/`).then((res) => {
           res.body.cancel();
         });
         cb(null, this.serviceWorker);
       }
       get downloadSpeed() {
         return this._downloadSpeed();
       }
       get uploadSpeed() {
         return this._uploadSpeed();
       }
       get progress() {
         const torrents = this.torrents.filter((torrent) => torrent.progress !== 1);
         const downloaded = torrents.reduce((total, torrent) => total + torrent.downloaded, 0);
         const length = torrents.reduce((total, torrent) => total + (torrent.length || 0), 0) || 1;
         return downloaded / length;
       }
       get ratio() {
         const uploaded = this.torrents.reduce((total, torrent) => total + torrent.uploaded, 0);
         const received = this.torrents.reduce((total, torrent) => total + torrent.received, 0) || 1;
         return uploaded / received;
       }
       get(torrentId) {
         if (torrentId instanceof Torrent) {
           if (this.torrents.includes(torrentId))
             return torrentId;
         } else {
           let parsed;
           try {
             parsed = parseTorrent(torrentId);
           } catch (err) {
           }
           if (!parsed)
             return null;
           if (!parsed.infoHash)
             throw new Error("Invalid torrent identifier");
           for (const torrent of this.torrents) {
             if (torrent.infoHash === parsed.infoHash)
               return torrent;
           }
         }
         return null;
       }
       add(torrentId, opts = {}, ontorrent = () => {
       }) {
         if (this.destroyed)
           throw new Error("client is destroyed");
         if (typeof opts === "function")
           [opts, ontorrent] = [{}, opts];
         const onInfoHash = () => {
           if (this.destroyed)
             return;
           for (const t of this.torrents) {
             if (t.infoHash === torrent.infoHash && t !== torrent) {
               torrent._destroy(new Error(`Cannot add duplicate torrent ${torrent.infoHash}`));
               ontorrent(t);
               return;
             }
           }
         };
         const onReady = () => {
           if (this.destroyed)
             return;
           ontorrent(torrent);
           this.emit("torrent", torrent);
         };
         function onClose() {
           torrent.removeListener("_infoHash", onInfoHash);
           torrent.removeListener("ready", onReady);
           torrent.removeListener("close", onClose);
         }
         this._debug("add");
         opts = opts ? Object.assign({}, opts) : {};
         const torrent = new Torrent(torrentId, this, opts);
         this.torrents.push(torrent);
         torrent.once("_infoHash", onInfoHash);
         torrent.once("ready", onReady);
         torrent.once("close", onClose);
         return torrent;
       }
       seed(input, opts, onseed) {
         if (this.destroyed)
           throw new Error("client is destroyed");
         if (typeof opts === "function")
           [opts, onseed] = [{}, opts];
         this._debug("seed");
         opts = opts ? Object.assign({}, opts) : {};
         opts.skipVerify = true;
         const isFilePath = typeof input === "string";
         if (isFilePath)
           opts.path = path2.dirname(input);
         if (!opts.createdBy)
           opts.createdBy = `WebTorrent/${VERSION_STR}`;
         const onTorrent = (torrent2) => {
           const tasks = [
             (cb) => {
               if (isFilePath || opts.preloadedStore)
                 return cb();
               torrent2.load(streams, cb);
             }
           ];
           if (this.dht) {
             tasks.push((cb) => {
               torrent2.once("dhtAnnounce", cb);
             });
           }
           parallel2(tasks, (err) => {
             if (this.destroyed)
               return;
             if (err)
               return torrent2._destroy(err);
             _onseed(torrent2);
           });
         };
         const _onseed = (torrent2) => {
           this._debug("on seed");
           if (typeof onseed === "function")
             onseed(torrent2);
           torrent2.emit("seed");
           this.emit("seed", torrent2);
         };
         const torrent = this.add(null, opts, onTorrent);
         let streams;
         if (isFileList(input))
           input = Array.from(input);
         else if (!Array.isArray(input))
           input = [input];
         parallel2(input.map((item) => (cb) => {
           if (!opts.preloadedStore && isReadable(item)) {
             concat(item, (err, buf) => {
               if (err)
                 return cb(err);
               buf.name = item.name;
               cb(null, buf);
             });
           } else {
             cb(null, item);
           }
         }), (err, input2) => {
           if (this.destroyed)
             return;
           if (err)
             return torrent._destroy(err);
           createTorrent.parseInput(input2, opts, (err2, files) => {
             if (this.destroyed)
               return;
             if (err2)
               return torrent._destroy(err2);
             streams = files.map((file) => file.getStream);
             createTorrent(input2, opts, (err3, torrentBuf) => {
               if (this.destroyed)
                 return;
               if (err3)
                 return torrent._destroy(err3);
               const existingTorrent = this.get(torrentBuf);
               if (existingTorrent) {
                 console.warn("A torrent with the same id is already being seeded");
                 torrent._destroy();
                 if (typeof onseed === "function")
                   onseed(existingTorrent);
               } else {
                 torrent._onTorrentId(torrentBuf);
               }
             });
           });
         });
         return torrent;
       }
       remove(torrentId, opts, cb) {
         if (typeof opts === "function")
           return this.remove(torrentId, null, opts);
         this._debug("remove");
         const torrent = this.get(torrentId);
         if (!torrent)
           throw new Error(`No torrent with id ${torrentId}`);
         this._remove(torrentId, opts, cb);
       }
       _remove(torrentId, opts, cb) {
         if (typeof opts === "function")
           return this._remove(torrentId, null, opts);
         const torrent = this.get(torrentId);
         if (!torrent)
           return;
         this.torrents.splice(this.torrents.indexOf(torrent), 1);
         torrent.destroy(opts, cb);
         if (this.dht) {
           this.dht._tables.remove(torrent.infoHash);
         }
       }
       address() {
         if (!this.listening)
           return null;
         return this._connPool ? this._connPool.tcpServer.address() : { address: "0.0.0.0", family: "IPv4", port: 0 };
       }
       throttleDownload(rate) {
         rate = Number(rate);
         if (isNaN(rate) || !isFinite(rate) || rate < -1)
           return false;
         this._downloadLimit = rate;
         if (this._downloadLimit < 0)
           return this.throttleGroups.down.setEnabled(false);
         this.throttleGroups.down.setEnabled(true);
         this.throttleGroups.down.setRate(this._downloadLimit);
       }
       throttleUpload(rate) {
         rate = Number(rate);
         if (isNaN(rate) || !isFinite(rate) || rate < -1)
           return false;
         this._uploadLimit = rate;
         if (this._uploadLimit < 0)
           return this.throttleGroups.up.setEnabled(false);
         this.throttleGroups.up.setEnabled(true);
         this.throttleGroups.up.setRate(this._uploadLimit);
       }
       destroy(cb) {
         if (this.destroyed)
           throw new Error("client already destroyed");
         this._destroy(null, cb);
       }
       _destroy(err, cb) {
         this._debug("client destroy");
         this.destroyed = true;
         const tasks = this.torrents.map((torrent) => (cb2) => {
           torrent.destroy(cb2);
         });
         if (this._connPool) {
           tasks.push((cb2) => {
             this._connPool.destroy(cb2);
           });
         }
         if (this.dht) {
           tasks.push((cb2) => {
             this.dht.destroy(cb2);
           });
         }
         parallel2(tasks, cb);
         if (err)
           this.emit("error", err);
         this.torrents = [];
         this._connPool = null;
         this.dht = null;
         this.throttleGroups.down.destroy();
         this.throttleGroups.up.destroy();
       }
       _onListening() {
         this._debug("listening");
         this.listening = true;
         if (this._connPool) {
           const address = this._connPool.tcpServer.address();
           if (address)
             this.torrentPort = address.port;
         }
         this.emit("listening");
       }
       _debug() {
         const args = [].slice.call(arguments);
         args[0] = `[${this._debugId}] ${args[0]}`;
         debug(...args);
       }
       _getByHash(infoHashHash) {
         for (const torrent of this.torrents) {
           if (!torrent.infoHashHash) {
             torrent.infoHashHash = sha1.sync(Buffer.from("72657132" + torrent.infoHash, "hex"));
           }
           if (infoHashHash === torrent.infoHashHash) {
             return torrent;
           }
         }
         return null;
       }
     };
     WebTorrent2.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT;
     WebTorrent2.UTP_SUPPORT = ConnPool.UTP_SUPPORT;
     WebTorrent2.VERSION = VERSION;
     function isReadable(obj) {
       return typeof obj === "object" && obj != null && typeof obj.pipe === "function";
     }
     function isFileList(obj) {
       return typeof FileList !== "undefined" && obj instanceof FileList;
     }
     module2.exports = WebTorrent2;
   }
 });
 
 // src/index.js
 var src_exports = {};
 __export(src_exports, {
   FSChunkStore: () => Storage,
   WebTorrent: () => import_webtorrent.default
 });
 module.exports = __toCommonJS(src_exports);
 var import_webtorrent = __toESM(require_webtorrent());
 
 // node_modules/fs-chunk-store/index.js
 var import_fs = __toESM(require("fs"), 1);
 var import_os = __toESM(require("os"), 1);
 var import_run_parallel = __toESM(require_run_parallel(), 1);
 var import_path = __toESM(require("path"), 1);
 var import_queue_microtask = __toESM(require_queue_microtask(), 1);
 var import_random_access_file = __toESM(require_random_access_file(), 1);
 var import_randombytes = __toESM(require_randombytes(), 1);
 var import_thunky = __toESM(require_thunky(), 1);
 var TMP;
 try {
   TMP = import_fs.default.statSync("/tmp") && "/tmp";
 } catch (err) {
   TMP = import_os.default.tmpdir();
 }
 var Storage = class {
   constructor(chunkLength, opts = {}) {
     this.chunkLength = Number(chunkLength);
     if (!this.chunkLength)
       throw new Error("First argument must be a chunk length");
     this.name = opts.name || import_path.default.join("fs-chunk-store", (0, import_randombytes.default)(20).toString("hex"));
     this.addUID = opts.addUID;
     if (opts.files) {
       this.path = opts.path;
       if (!Array.isArray(opts.files)) {
         throw new Error("`files` option must be an array");
       }
       this.files = opts.files.map((file, i, files) => {
         if (file.path == null)
           throw new Error("File is missing `path` property");
         if (file.length == null)
           throw new Error("File is missing `length` property");
         if (file.offset == null) {
           if (i === 0) {
             file.offset = 0;
           } else {
             const prevFile = files[i - 1];
             file.offset = prevFile.offset + prevFile.length;
           }
         }
         let newPath = file.path;
         if (this.path) {
           newPath = this.addUID ? import_path.default.resolve(import_path.default.join(this.path, this.name, file.path)) : import_path.default.resolve(import_path.default.join(this.path, file.path));
         }
         return { path: newPath, length: file.length, offset: file.offset };
       });
       this.length = this.files.reduce((sum, file) => {
         return sum + file.length;
       }, 0);
       if (opts.length != null && opts.length !== this.length) {
         throw new Error("total `files` length is not equal to explicit `length` option");
       }
     } else {
       const len = Number(opts.length) || Infinity;
       this.files = [{
         offset: 0,
         path: import_path.default.resolve(opts.path || import_path.default.join(TMP, this.name)),
         length: len
       }];
       this.length = len;
     }
     this.chunkMap = [];
     this.closed = false;
     this.files.forEach((file) => {
       file.open = (0, import_thunky.default)((cb) => {
         if (this.closed)
           return cb(new Error("Storage is closed"));
         import_fs.default.mkdir(import_path.default.dirname(file.path), { recursive: true }, (err) => {
           if (err)
             return cb(err);
           if (this.closed)
             return cb(new Error("Storage is closed"));
           cb(null, (0, import_random_access_file.default)(file.path));
         });
       });
     });
     if (this.length !== Infinity) {
       this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
       this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1;
       this.files.forEach((file) => {
         const fileStart = file.offset;
         const fileEnd = file.offset + file.length;
         const firstChunk = Math.floor(fileStart / this.chunkLength);
         const lastChunk = Math.floor((fileEnd - 1) / this.chunkLength);
         for (let p = firstChunk; p <= lastChunk; ++p) {
           const chunkStart = p * this.chunkLength;
           const chunkEnd = chunkStart + this.chunkLength;
           const from = fileStart < chunkStart ? 0 : fileStart - chunkStart;
           const to = fileEnd > chunkEnd ? this.chunkLength : fileEnd - chunkStart;
           const offset = fileStart > chunkStart ? 0 : chunkStart - fileStart;
           if (!this.chunkMap[p])
             this.chunkMap[p] = [];
           this.chunkMap[p].push({
             from,
             to,
             offset,
             file
           });
         }
       });
     }
   }
   put(index, buf, cb) {
     if (typeof cb !== "function")
       cb = noop;
     if (this.closed)
       return nextTick(cb, new Error("Storage is closed"));
     const isLastChunk = index === this.lastChunkIndex;
     if (isLastChunk && buf.length !== this.lastChunkLength) {
       return nextTick(cb, new Error("Last chunk length must be " + this.lastChunkLength));
     }
     if (!isLastChunk && buf.length !== this.chunkLength) {
       return nextTick(cb, new Error("Chunk length must be " + this.chunkLength));
     }
     if (this.length === Infinity) {
       this.files[0].open((err, file) => {
         if (err)
           return cb(err);
         file.write(index * this.chunkLength, buf, cb);
       });
     } else {
       const targets = this.chunkMap[index];
       if (!targets)
         return nextTick(cb, new Error("no files matching the request range"));
       const tasks = targets.map((target) => {
         return (cb2) => {
           target.file.open((err, file) => {
             if (err)
               return cb2(err);
             file.write(target.offset, buf.slice(target.from, target.to), cb2);
           });
         };
       });
       (0, import_run_parallel.default)(tasks, cb);
     }
   }
   get(index, opts, cb) {
     if (typeof opts === "function")
       return this.get(index, null, opts);
     if (this.closed)
       return nextTick(cb, new Error("Storage is closed"));
     const chunkLength = index === this.lastChunkIndex ? this.lastChunkLength : this.chunkLength;
     const rangeFrom = opts && opts.offset || 0;
     const rangeTo = opts && opts.length ? rangeFrom + opts.length : chunkLength;
     if (rangeFrom < 0 || rangeFrom < 0 || rangeTo > chunkLength) {
       return nextTick(cb, new Error("Invalid offset and/or length"));
     }
     if (this.length === Infinity) {
       if (rangeFrom === rangeTo)
         return nextTick(cb, null, Buffer.from(0));
       this.files[0].open((err, file) => {
         if (err)
           return cb(err);
         const offset = index * this.chunkLength + rangeFrom;
         file.read(offset, rangeTo - rangeFrom, cb);
       });
     } else {
       let targets = this.chunkMap[index];
       if (!targets)
         return nextTick(cb, new Error("no files matching the request range"));
       if (opts) {
         targets = targets.filter((target) => {
           return target.to > rangeFrom && target.from < rangeTo;
         });
         if (targets.length === 0) {
           return nextTick(cb, new Error("no files matching the requested range"));
         }
       }
       if (rangeFrom === rangeTo)
         return nextTick(cb, null, Buffer.from(0));
       const tasks = targets.map((target) => {
         return (cb2) => {
           let from = target.from;
           let to = target.to;
           let offset = target.offset;
           if (opts) {
             if (to > rangeTo)
               to = rangeTo;
             if (from < rangeFrom) {
               offset += rangeFrom - from;
               from = rangeFrom;
             }
           }
           target.file.open((err, file) => {
             if (err)
               return cb2(err);
             file.read(offset, to - from, cb2);
           });
         };
       });
       (0, import_run_parallel.default)(tasks, (err, buffers) => {
         if (err)
           return cb(err);
         cb(null, Buffer.concat(buffers));
       });
     }
   }
   close(cb) {
     if (this.closed)
       return nextTick(cb, new Error("Storage is closed"));
     this.closed = true;
     const tasks = this.files.map((file) => {
       return (cb2) => {
         file.open((err, file2) => {
           if (err)
             return cb2(null);
           file2.close(cb2);
         });
       };
     });
     (0, import_run_parallel.default)(tasks, cb);
   }
   destroy(cb) {
     this.close(() => {
       if (this.addUID && this.path) {
         import_fs.default.rm(import_path.default.resolve(import_path.default.join(this.path, this.name)), { recursive: true, maxBusyTries: 10 }, cb);
       } else {
         const tasks = this.files.map((file) => {
           return (cb2) => {
             import_fs.default.rm(file.path, { recursive: true, maxRetries: 10 }, (err) => {
               err && err.code === "ENOENT" ? cb2() : cb2(err);
             });
           };
         });
         (0, import_run_parallel.default)(tasks, cb);
       }
     });
   }
 };
 function nextTick(cb, err, val) {
   (0, import_queue_microtask.default)(() => {
     if (cb)
       cb(err, val);
   });
 }
 function noop() {
 }


 /*!
  * escape-html
  * Copyright(c) 2012-2013 TJ Holowaychuk
  * Copyright(c) 2015 Andreas Lubbe
  * Copyright(c) 2015 Tiancheng "Timothy" Gu
  * MIT Licensed
  */
 /*!
  * range-parser
  * Copyright(c) 2012-2014 TJ Holowaychuk
  * Copyright(c) 2015-2016 Douglas Christopher Wilson
  * MIT Licensed
  */
 /*! bittorrent-lsd. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! bittorrent-protocol. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! cache-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! cpus. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! create-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! fs-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! immediate-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! load-ip-set. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! lt_donthave. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! mediasource. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! parse-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! render-media. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! stream-to-blob-url. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! stream-to-blob. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! stream-with-known-length-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
 /*! torrent-discovery. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! torrent-piece. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! ut_metadata. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! ut_pex. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 /*! webtorrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
 

/************************************************************************************
 * MERGE
 *********************************************************************************/

 const MessageType = {
  DOWNLOAD_NO_PEERS: "DOWNLOAD_NO_PEERS",
  DOWNLOAD_WARNING: "DOWNLOAD_WARNING",
  DOWNLOAD_METADATA: "DOWNLOAD_METADATA",
  DOWNLOAD_INFOHASH: "DOWNLOAD_INFOHASH",
  UPLOAD_PROGRESS: "UPLOAD_PROGRESS",
  DOWNLOAD_PROGRESS: "DOWNLOAD_PROGRESS",
  DOWNLOAD_FINISHED: "DOWNLOAD_FINISHED",
  DOWNLOAD_ERROR: "DOWNLOAD_ERROR",
};

if (!isMainThread) {
  // Get parameters through workerData object
  const { magnetLink, path } = workerData;

  const THROTTLE_BYTES = 5 * 1e6; // 5mb in bytes

  // Create a webtorrent client
  const client = new import_webtorrent.default();

  client.add(
    magnetLink,
    {
      strategy: "rarest",
      store: Storage,
      path,
    },
    function (torrent) {
      // Throttle progress messages
      let _downloadBytes = 0;
      torrent.on("download", function (bytes) {
        _downloadBytes += bytes;

        if (_downloadBytes >= THROTTLE_BYTES) {
          parentPort.postMessage({
            type: MessageType.DOWNLOAD_PROGRESS,
            data: {
              magnetLink,
              downloaded: torrent.downloaded,
              downloadSpeed: torrent.downloadSpeed,
              progress: torrent.progress,
            },
          });
          _downloadBytes = 0;
        }
      });

      // Throttle progress messages
      let _uploadBytes = 0;
      torrent.on("upload", function (bytes) {
        _uploadBytes += bytes;

        if (_uploadBytes >= THROTTLE_BYTES) {
          parentPort.postMessage({
            type: MessageType.UPLOAD_PROGRESS,
            data: {
              magnetLink,
              downloaded: torrent.uploaded,
              downloadSpeed: torrent.uploadSpeed,
              progress: torrent.ratio,
            },
          });
          _uploadBytes = 0;
        }
      });

      torrent.on("done", function () {
        parentPort.postMessage({
          type: MessageType.DOWNLOAD_FINISHED,
          data: {
            magnetLink,
          },
        });
      });

      torrent.on("error", function (error) {
        parentPort.postMessage({
          type: MessageType.DOWNLOAD_ERROR,
          data: {
            error,
          },
        });
      });

      torrent.on("infoHash", function () {
        parentPort.postMessage({
          type: MessageType.DOWNLOAD_INFOHASH,
          data: {},
        });
      });

      torrent.on("metadata", function () {
        parentPort.postMessage({
          type: MessageType.DOWNLOAD_METADATA,
          data: {},
        });
      });

      torrent.on("warning", function (error) {
        parentPort.postMessage({
          type: MessageType.DOWNLOAD_WARNING,
          data: {
            error,
          },
        });
      });

      torrent.on("noPeers", function (announceType) {
        parentPort.postMessage({
          type: MessageType.DOWNLOAD_NO_PEERS,
          data: {
            announceType,
          },
        });
      });
    }
  );

  process.on("exit", () =>
    parentPort.postMessage({
      type: "ETC",
      data: "worker thread (inside) exited",
    })
  );
}
